
> inherbis@0.1.0 lint
> next lint --format json


 ⚠ The Next.js plugin was not detected in your ESLint configuration. See https://nextjs.org/docs/app/api-reference/config/eslint#migrating-existing-config
[{"filePath":"C:\\herbisveritas\\src\\actions\\__tests__\\cartActions.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ValidationErrorResult' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GeneralErrorResult' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isSuccessResult' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":74,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":89},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CartItem' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2428,2431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2428,2431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2675,2678],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2675,2678],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3084,3087],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3084,3087],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3096,3099],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3096,3099],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3128,3131],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3128,3131],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3140,3143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3140,3143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3176,3179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3176,3179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3188,3191],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3188,3191],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3222,3225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3222,3225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3234,3237],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3234,3237],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":110,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3269,3272],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3269,3272],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3304,3307],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3304,3307],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { revalidateTag } from \"next/cache\";\nimport { createSupabaseServerClient } from '../../lib/supabase/server';\nimport { createSupabaseAdminClient } from '../../lib/supabase/server-admin';\nimport { ValidationErrorResult, GeneralErrorResult, createSuccessResult, isSuccessResult } from '../../lib/cart-helpers';\nimport { CartItem, CartData } from '../../types/cart';\n\n// Mock des modules externes\njest.mock(\"next/cache\", () => ({\n  revalidateTag: jest.fn(),\n}));\njest.mock(\"../../lib/supabase/server\");\njest.mock(\"../../lib/supabase/server-admin\");\njest.mock(\"../../lib/cartReader\");\njest.mock(\"../../utils/authUtils\");\njest.mock(\"crypto\", () => ({\n  randomUUID: jest.fn(() => \"mock-uuid-123\"),\n}));\n\n// Import des fonctions à tester\nimport { \n  addItemToCartAction, \n  removeItemFromCartAction,\n  updateCartItemQuantityAction,\n  clearCartAction,\n  migrateAndGetCart \n} from \"../cartActions\";\nimport { getCart } from \"../../lib/cartReader\";\nimport { getActiveUserId } from \"../../utils/authUtils\";\n\n// Mocks typés\nconst mockGetCart = getCart as jest.Mock;\nconst mockGetActiveUserId = getActiveUserId as jest.Mock;\nconst mockedCreateSupabaseServerClient = createSupabaseServerClient as jest.Mock;\nconst mockedCreateSupabaseAdminClient = createSupabaseAdminClient as jest.Mock;\nconst mockRevalidateTag = revalidateTag as jest.Mock;\n\n// UUIDs valides pour les tests\nconst VALID_AUTH_USER_ID = \"123e4567-e89b-12d3-a456-426614174000\";\nconst VALID_PRODUCT_ID = \"550e8400-e29b-41d4-a716-446655440000\";\nconst VALID_CART_ITEM_ID = \"789e0123-e89b-12d3-a456-426614174000\";\n\n// Utility function to create FormData from object\nfunction createFormData(data: Record<string, string | undefined>): FormData {\n  const formData = new FormData();\n  Object.entries(data).forEach(([key, value]) => {\n    if (value !== undefined) {\n      formData.append(key, value);\n    }\n  });\n  return formData;\n}\n\n// Factory pour créer des données de test cohérentes\nfunction createTestCartData(overrides: Partial<CartData> = {}): CartData {\n  return {\n    id: \"test-cart-123\",\n    user_id: VALID_AUTH_USER_ID,\n    created_at: \"2024-01-01T00:00:00Z\",\n    updated_at: \"2024-01-01T00:00:00Z\",\n    items: [\n      {\n        id: VALID_CART_ITEM_ID,\n        productId: VALID_PRODUCT_ID,\n        name: \"Test Product\",\n        price: 10.99,\n        quantity: 1,\n        image: \"test.jpg\",\n      },\n    ],\n    ...overrides,\n  };\n}\n\nfunction createTestProduct(overrides: any = {}) {\n  return {\n    id: VALID_PRODUCT_ID,\n    name: \"Test Product\",\n    price: 10.99,\n    image_url: \"test.jpg\",\n    stock: 10,\n    slug: \"test-product\",\n    is_active: true,\n    ...overrides,\n  };\n}\n\nfunction createTestCartItem(overrides: any = {}) {\n  return {\n    id: VALID_CART_ITEM_ID,\n    product_id: VALID_PRODUCT_ID,\n    quantity: 1,\n    name: \"Test Product\",\n    price: 10.99,\n    image_url: \"test.jpg\",\n    cart_id: \"test-cart-123\",\n    products: {\n      stock: 10,\n      name: \"Test Product\",\n    },\n    ...overrides,\n  };\n}\n\n// Mock factory simplifié pour Supabase\nfunction createMockSupabaseClient(config: {\n  productResponse?: { data: any; error: any };\n  cartResponse?: { data: any; error: any };\n  cartItemResponse?: { data: any; error: any };\n  insertResponse?: { data: any; error: any };\n  updateResponse?: { error: any };\n  deleteResponse?: { error: any };\n} = {}) {\n  const {\n    productResponse = { data: createTestProduct(), error: null },\n    cartResponse = { data: null, error: null },\n    cartItemResponse = { data: null, error: null },\n    insertResponse = { data: { id: \"mock-uuid-123\" }, error: null },\n    updateResponse = { error: null },\n    deleteResponse = { error: null },\n  } = config;\n\n  const mockQuery = {\n    select: jest.fn().mockReturnThis(),\n    insert: jest.fn().mockReturnThis(),\n    update: jest.fn().mockReturnThis(),\n    delete: jest.fn().mockReturnThis(),\n    eq: jest.fn().mockReturnThis(),\n    single: jest.fn(),\n    maybeSingle: jest.fn(),\n  };\n\n  return {\n    auth: {\n      getUser: jest.fn().mockResolvedValue({\n        data: { user: { id: VALID_AUTH_USER_ID } },\n        error: null,\n      }),\n    },\n    from: jest.fn().mockImplementation((table: string) => {\n      const chainMock = { ...mockQuery };\n      \n      if (table === \"products\") {\n        chainMock.single.mockResolvedValue(productResponse);\n      } else if (table === \"carts\") {\n        chainMock.single.mockResolvedValue(cartResponse);\n        chainMock.maybeSingle.mockResolvedValue(cartResponse);\n        chainMock.insert.mockResolvedValue(insertResponse);\n        chainMock.delete.mockImplementation(() => ({\n          eq: jest.fn().mockResolvedValue(deleteResponse),\n        }));\n      } else if (table === \"cart_items\") {\n        chainMock.single.mockResolvedValue(cartItemResponse);\n        chainMock.insert.mockResolvedValue(insertResponse);\n        chainMock.update.mockImplementation(() => ({\n          eq: jest.fn().mockResolvedValue(updateResponse),\n        }));\n        chainMock.delete.mockImplementation(() => ({\n          eq: jest.fn().mockResolvedValue(deleteResponse),\n        }));\n      }\n      \n      return chainMock;\n    }),\n  };\n}\n\n// Type guards pour les tests\nfunction isTestGeneralError(result: {\n  success: boolean;\n  error?: string;\n}): result is { success: false; error: string } {\n  return result.success === false && typeof result.error === \"string\";\n}\n\nfunction isTestValidationError(result: {\n  success: boolean;\n  errors?: Record<string, string[] | undefined>;\n}): result is { success: false; errors: Record<string, string[] | undefined> } {\n  return result.success === false && typeof result.errors === \"object\";\n}\n\ndescribe(\"cartActions.ts - Complete Test Suite\", () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockGetActiveUserId.mockResolvedValue(VALID_AUTH_USER_ID);\n  });\n\n  describe(\"addItemToCartAction\", () => {\n    it(\"should add a new item to an existing cart successfully\", async () => {\n      const existingCart = createTestCartData({ items: [] });\n      \n      mockGetCart.mockResolvedValueOnce(createSuccessResult(existingCart))\n                .mockResolvedValueOnce(createSuccessResult(createTestCartData()));\n      \n      const mockSupabase = createMockSupabaseClient();\n      const mockAdminSupabase = createMockSupabaseClient();\n      \n      mockedCreateSupabaseServerClient.mockResolvedValue(mockSupabase);\n      mockedCreateSupabaseAdminClient.mockResolvedValue(mockAdminSupabase);\n\n      const formData = createFormData({\n        productId: VALID_PRODUCT_ID,\n        quantity: \"2\",\n      });\n\n      const result = await addItemToCartAction(null, formData);\n\n      expect(result.success).toBe(true);\n      expect(mockRevalidateTag).toHaveBeenCalledWith(\"cart\");\n    });\n\n    it(\"should update quantity of existing item in cart\", async () => {\n      const existingCart = createTestCartData();\n      \n      mockGetCart.mockResolvedValueOnce(createSuccessResult(existingCart))\n                .mockResolvedValueOnce(createSuccessResult(createTestCartData()));\n      \n      const mockSupabase = createMockSupabaseClient();\n      const mockAdminSupabase = createMockSupabaseClient();\n      \n      mockedCreateSupabaseServerClient.mockResolvedValue(mockSupabase);\n      mockedCreateSupabaseAdminClient.mockResolvedValue(mockAdminSupabase);\n\n      const formData = createFormData({\n        productId: VALID_PRODUCT_ID,\n        quantity: \"1\",\n      });\n\n      const result = await addItemToCartAction(null, formData);\n\n      expect(result.success).toBe(true);\n    });\n\n    it(\"should create a new cart if user has no cart\", async () => {\n      mockGetCart.mockResolvedValueOnce(createSuccessResult(null))\n                .mockResolvedValueOnce(createSuccessResult(createTestCartData()));\n      \n      const mockSupabase = createMockSupabaseClient();\n      const mockAdminSupabase = createMockSupabaseClient();\n      \n      mockedCreateSupabaseServerClient.mockResolvedValue(mockSupabase);\n      mockedCreateSupabaseAdminClient.mockResolvedValue(mockAdminSupabase);\n\n      const formData = createFormData({\n        productId: VALID_PRODUCT_ID,\n        quantity: \"1\",\n      });\n\n      const result = await addItemToCartAction(null, formData);\n\n      expect(result.success).toBe(true);\n    });\n\n    it(\"should return validation error for invalid productId\", async () => {\n      const formData = createFormData({\n        productId: \"invalid-uuid\",\n        quantity: \"1\",\n      });\n\n      const result = await addItemToCartAction(null, formData);\n\n      expect(result.success).toBe(false);\n      expect(isTestValidationError(result)).toBe(true);\n      if (isTestValidationError(result)) {\n        expect(result.errors.productId).toBeDefined();\n      }\n    });\n\n    it(\"should return validation error for invalid quantity\", async () => {\n      const formData = createFormData({\n        productId: VALID_PRODUCT_ID,\n        quantity: \"-1\",\n      });\n\n      const result = await addItemToCartAction(null, formData);\n\n      expect(result.success).toBe(false);\n      expect(isTestValidationError(result)).toBe(true);\n      if (isTestValidationError(result)) {\n        expect(result.errors.quantity).toBeDefined();\n      }\n    });\n\n    it(\"should return error when product not found\", async () => {\n      mockGetCart.mockResolvedValue(createSuccessResult(null));\n      \n      const mockSupabase = createMockSupabaseClient({\n        productResponse: { data: null, error: { message: \"Product not found\" } },\n      });\n      \n      mockedCreateSupabaseServerClient.mockResolvedValue(mockSupabase);\n\n      const formData = createFormData({\n        productId: VALID_PRODUCT_ID,\n        quantity: \"1\",\n      });\n\n      const result = await addItemToCartAction(null, formData);\n\n      expect(result.success).toBe(false);\n      if (isTestGeneralError(result)) {\n        expect(result.error).toBe(\"Produit non trouvé ou non disponible.\");\n      }\n    });\n\n    it(\"should return error when insufficient stock\", async () => {\n      mockGetCart.mockResolvedValue(createSuccessResult(null));\n      \n      const mockSupabase = createMockSupabaseClient({\n        productResponse: { data: createTestProduct({ stock: 1 }), error: null },\n      });\n      \n      mockedCreateSupabaseServerClient.mockResolvedValue(mockSupabase);\n\n      const formData = createFormData({\n        productId: VALID_PRODUCT_ID,\n        quantity: \"5\",\n      });\n\n      const result = await addItemToCartAction(null, formData);\n\n      expect(result.success).toBe(false);\n      if (isTestGeneralError(result)) {\n        expect(result.error).toBe(\"Stock insuffisant pour ce produit.\");\n      }\n    });\n  });\n\n  describe(\"removeItemFromCartAction\", () => {\n    it(\"should remove item from cart successfully\", async () => {\n      // Mock getCart pour retourner un panier vide après suppression\n      mockGetCart.mockResolvedValue(createSuccessResult(createTestCartData({ items: [] })));\n      \n      const mockAdminSupabase = createMockSupabaseClient({\n        deleteResponse: { error: null } // Succès de la suppression\n      });\n      mockedCreateSupabaseAdminClient.mockResolvedValue(mockAdminSupabase);\n\n      const formData = createFormData({\n        cartItemId: VALID_CART_ITEM_ID,\n      });\n\n      const result = await removeItemFromCartAction(null, formData);\n\n      expect(result.success).toBe(true);\n      expect(mockRevalidateTag).toHaveBeenCalledWith(\"cart\");\n    });\n\n    it(\"should return validation error for invalid cartItemId\", async () => {\n      const formData = createFormData({\n        cartItemId: \"invalid-uuid\",\n      });\n\n      const result = await removeItemFromCartAction(null, formData);\n\n      expect(result.success).toBe(false);\n      expect(isTestValidationError(result)).toBe(true);\n      if (isTestValidationError(result)) {\n        expect(result.errors.cartItemId).toBeDefined();\n      }\n    });\n\n    it(\"should handle database error during removal\", async () => {\n      const mockAdminSupabase = createMockSupabaseClient({\n        deleteResponse: { error: { message: \"Database error\" } },\n      });\n      mockedCreateSupabaseAdminClient.mockResolvedValue(mockAdminSupabase);\n\n      const formData = createFormData({\n        cartItemId: VALID_CART_ITEM_ID,\n      });\n\n      const result = await removeItemFromCartAction(null, formData);\n\n      expect(result.success).toBe(false);\n      if (isTestGeneralError(result)) {\n        expect(result.error).toBe(\"Erreur lors de la suppression de l'article.\");\n      }\n    });\n  });\n\n  describe(\"updateCartItemQuantityAction\", () => {\n    it(\"should update item quantity successfully\", async () => {\n      const mockSupabase = createMockSupabaseClient({\n        cartItemResponse: { data: createTestCartItem(), error: null },\n      });\n      const mockAdminSupabase = createMockSupabaseClient({\n        updateResponse: { error: null } // Succès de la mise à jour\n      });\n      \n      mockedCreateSupabaseServerClient.mockResolvedValue(mockSupabase);\n      mockedCreateSupabaseAdminClient.mockResolvedValue(mockAdminSupabase);\n      \n      // Mock getCart pour retourner le panier mis à jour\n      mockGetCart.mockResolvedValue(createSuccessResult(createTestCartData()));\n\n      const formData = createFormData({\n        cartItemId: VALID_CART_ITEM_ID,\n        quantity: \"3\",\n      });\n\n      const result = await updateCartItemQuantityAction(null, formData);\n\n      expect(result.success).toBe(true);\n      expect(mockRevalidateTag).toHaveBeenCalledWith(\"cart\");\n    });\n\n    it(\"should remove item when quantity is 0\", async () => {\n      // Mock getCart pour retourner un panier vide après suppression\n      mockGetCart.mockResolvedValue(createSuccessResult(createTestCartData({ items: [] })));\n      \n      const mockAdminSupabase = createMockSupabaseClient({\n        deleteResponse: { error: null } // Succès de la suppression via removeItemFromCartAction\n      });\n      mockedCreateSupabaseAdminClient.mockResolvedValue(mockAdminSupabase);\n\n      const formData = createFormData({\n        cartItemId: VALID_CART_ITEM_ID,\n        quantity: \"0\",\n      });\n\n      const result = await updateCartItemQuantityAction(null, formData);\n\n      expect(result.success).toBe(true);\n    });\n\n    it(\"should return validation error for invalid quantity\", async () => {\n      const formData = createFormData({\n        cartItemId: VALID_CART_ITEM_ID,\n        quantity: \"101\",\n      });\n\n      const result = await updateCartItemQuantityAction(null, formData);\n\n      expect(result.success).toBe(false);\n      expect(isTestValidationError(result)).toBe(true);\n      if (isTestValidationError(result)) {\n        expect(result.errors.quantity).toBeDefined();\n      }\n    });\n\n    it(\"should return error when cart item not found\", async () => {\n      const mockSupabase = createMockSupabaseClient({\n        cartItemResponse: { data: null, error: { message: \"Not found\" } },\n      });\n      \n      mockedCreateSupabaseServerClient.mockResolvedValue(mockSupabase);\n\n      const formData = createFormData({\n        cartItemId: VALID_CART_ITEM_ID,\n        quantity: \"2\",\n      });\n\n      const result = await updateCartItemQuantityAction(null, formData);\n\n      expect(result.success).toBe(false);\n      if (isTestGeneralError(result)) {\n        expect(result.error).toBe(\"Article non trouvé dans le panier.\");\n      }\n    });\n\n    it(\"should return error when insufficient stock\", async () => {\n      const mockSupabase = createMockSupabaseClient({\n        cartItemResponse: { \n          data: createTestCartItem({\n            products: { stock: 2, name: \"Test Product\" }\n          }), \n          error: null \n        },\n      });\n      \n      mockedCreateSupabaseServerClient.mockResolvedValue(mockSupabase);\n\n      const formData = createFormData({\n        cartItemId: VALID_CART_ITEM_ID,\n        quantity: \"5\",\n      });\n\n      const result = await updateCartItemQuantityAction(null, formData);\n\n      expect(result.success).toBe(false);\n      if (isTestGeneralError(result)) {\n        expect(result.error).toBe(\"Stock insuffisant pour cette quantité.\");\n      }\n    });\n  });\n\n  describe(\"clearCartAction\", () => {\n    it(\"should clear cart successfully\", async () => {\n      const existingCart = createTestCartData();\n      mockGetCart.mockResolvedValue(createSuccessResult(existingCart));\n      \n      const mockSupabase = createMockSupabaseClient();\n      const mockAdminSupabase = createMockSupabaseClient();\n      \n      mockedCreateSupabaseServerClient.mockResolvedValue(mockSupabase);\n      mockedCreateSupabaseAdminClient.mockResolvedValue(mockAdminSupabase);\n\n      const result = await clearCartAction();\n\n      expect(result.success).toBe(true);\n      expect(mockRevalidateTag).toHaveBeenCalledWith(\"cart\");\n      if (result.success) {\n        expect(result.message).toBe(\"Panier vidé avec succès.\");\n      }\n    });\n\n    it(\"should handle empty cart gracefully\", async () => {\n      mockGetCart.mockResolvedValue(createSuccessResult(null));\n\n      const result = await clearCartAction();\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.message).toBe(\"Panier déjà vide.\");\n      }\n    });\n\n    it(\"should handle database error during cart clearing\", async () => {\n      const existingCart = createTestCartData();\n      mockGetCart.mockResolvedValue(createSuccessResult(existingCart));\n      \n      const mockSupabase = createMockSupabaseClient();\n      const mockAdminSupabase = createMockSupabaseClient({\n        deleteResponse: { error: { message: \"Database error\" } },\n      });\n      \n      mockedCreateSupabaseServerClient.mockResolvedValue(mockSupabase);\n      mockedCreateSupabaseAdminClient.mockResolvedValue(mockAdminSupabase);\n\n      const result = await clearCartAction();\n\n      expect(result.success).toBe(false);\n      if (isTestGeneralError(result)) {\n        expect(result.error).toBe(\"Erreur lors de la suppression des articles.\");\n      }\n    });\n  });\n\n  describe(\"migrateAndGetCart\", () => {\n    it(\"should return current cart when no guest items provided\", async () => {\n      const currentCart = createTestCartData();\n      mockGetCart.mockResolvedValue(createSuccessResult(currentCart));\n\n      const result = await migrateAndGetCart([]);\n\n      expect(result.success).toBe(true);\n      if (result.success && result.data) {\n        expect(result.data.id).toBe(currentCart.id);\n      }\n    });\n\n    it(\"should migrate guest items to existing user cart\", async () => {\n      const guestItems = [\n        {\n          productId: VALID_PRODUCT_ID,\n          quantity: 2,\n        },\n      ];\n\n      const mockSupabase = createMockSupabaseClient({\n        cartResponse: { data: { id: \"user-cart-123\" }, error: null },\n        cartItemResponse: { data: null, error: null },\n      });\n      const mockAdminSupabase = createMockSupabaseClient();\n      \n      mockedCreateSupabaseServerClient.mockResolvedValue(mockSupabase);\n      mockedCreateSupabaseAdminClient.mockResolvedValue(mockAdminSupabase);\n      \n      const finalCart = createTestCartData({ id: \"user-cart-123\" });\n      mockGetCart.mockResolvedValue(createSuccessResult(finalCart));\n\n      const result = await migrateAndGetCart(guestItems);\n\n      expect(result.success).toBe(true);\n      expect(mockRevalidateTag).toHaveBeenCalledWith(\"cart\");\n    });\n\n    it(\"should handle unauthenticated user\", async () => {\n      mockGetActiveUserId.mockResolvedValue(null);\n\n      const result = await migrateAndGetCart([{ productId: VALID_PRODUCT_ID, quantity: 1 }]);\n\n      expect(result.success).toBe(false);\n      if (isTestGeneralError(result)) {\n        expect(result.error).toBe(\"Utilisateur non authentifié.\");\n      }\n    });\n  });\n\n  describe(\"Error Handling & Edge Cases\", () => {\n    it(\"should handle unexpected errors gracefully\", async () => {\n      mockGetActiveUserId.mockRejectedValue(new Error(\"Unexpected error\"));\n\n      const formData = createFormData({\n        productId: VALID_PRODUCT_ID,\n        quantity: \"1\",\n      });\n\n      const result = await addItemToCartAction(null, formData);\n\n      expect(result.success).toBe(false);\n      if (isTestGeneralError(result)) {\n        expect(result.error).toBe(\"Une erreur inattendue s'est produite.\");\n      }\n    });\n\n    it(\"should handle missing FormData fields\", async () => {\n      const formData = new FormData();\n\n      const result = await addItemToCartAction(null, formData);\n\n      expect(result.success).toBe(false);\n      expect(isTestValidationError(result)).toBe(true);\n    });\n\n    it(\"should handle malformed FormData\", async () => {\n      const formData = createFormData({\n        productId: VALID_PRODUCT_ID,\n        quantity: \"not-a-number\",\n      });\n\n      const result = await addItemToCartAction(null, formData);\n\n      expect(result.success).toBe(false);\n      expect(isTestValidationError(result)).toBe(true);\n    });\n  });\n\n  describe(\"Integration Tests\", () => {\n    it(\"should properly validate all input schemas\", async () => {\n      const invalidCases = [\n        {\n          action: addItemToCartAction,\n          data: { productId: \"invalid\", quantity: \"-1\" },\n          expectedErrors: [\"productId\", \"quantity\"],\n        },\n        {\n          action: removeItemFromCartAction,\n          data: { cartItemId: \"invalid\" },\n          expectedErrors: [\"cartItemId\"],\n        },\n        {\n          action: updateCartItemQuantityAction,\n          data: { cartItemId: \"invalid\", quantity: \"101\" },\n          expectedErrors: [\"cartItemId\", \"quantity\"],\n        },\n      ];\n\n      for (const testCase of invalidCases) {\n        const formData = createFormData(testCase.data);\n        const result = await testCase.action(null, formData);\n        \n        expect(result.success).toBe(false);\n        expect(isTestValidationError(result)).toBe(true);\n        \n        if (isTestValidationError(result)) {\n          testCase.expectedErrors.forEach(field => {\n            expect(result.errors[field]).toBeDefined();\n          });\n        }\n      }\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\actions\\__tests__\\marketActions.test.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":85,"column":7,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":85,"endColumn":39},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":103,"column":7,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":103,"endColumn":39},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":104,"column":7,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":104,"endColumn":42},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":122,"column":7,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":122,"endColumn":39},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":140,"column":7,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":140,"endColumn":39},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":156,"column":7,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":156,"endColumn":39},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":157,"column":7,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":157,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Market Actions Tests\n * \n * Tests for market CRUD server actions to verify functionality with new types\n */\n\nimport { createMarket, updateMarket, deleteMarket } from '../marketActions';\nimport { validateMarketForm } from '@/lib/validators/market';\n\n// Mock the dependencies\njest.mock('@/lib/supabase/server');\njest.mock('@/lib/auth/admin-service');\njest.mock('next/cache');\n\ndescribe('Market Actions', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('validateMarketForm', () => {\n    it('should validate valid market form data', () => {\n      const formData = new FormData();\n      formData.append('name', 'Test Market');\n      formData.append('start_date', '2025-07-01');\n      formData.append('end_date', '2025-08-31');\n      formData.append('day_of_week', '0');\n      formData.append('start_time', '18:00');\n      formData.append('end_time', '22:00');\n      formData.append('city', 'Test City');\n      formData.append('address', 'Test Address');\n      formData.append('description', 'Test Description');\n      formData.append('is_active', 'true');\n\n      const result = validateMarketForm(formData);\n      \n      expect(result).not.toBeNull();\n      expect(result?.name).toBe('Test Market');\n      expect(result?.city).toBe('Test City');\n      expect(result?.address).toBe('Test Address');\n      expect(result?.day_of_week).toBe(0);\n      expect(result?.is_active).toBe(true);\n    });\n\n    it('should reject invalid market form data', () => {\n      const formData = new FormData();\n      formData.append('name', ''); // Empty name should fail\n      \n      const result = validateMarketForm(formData);\n      \n      expect(result).toBeNull();\n    });\n\n    it('should handle optional fields correctly', () => {\n      const formData = new FormData();\n      formData.append('name', 'Test Market');\n      formData.append('start_date', '2025-07-01');\n      formData.append('end_date', '2025-08-31');\n      formData.append('day_of_week', '0');\n      formData.append('start_time', '18:00');\n      formData.append('end_time', '22:00');\n      formData.append('city', 'Test City');\n      formData.append('address', 'Test Address');\n      // No description - should be undefined\n      formData.append('hero_image_url', '');\n      formData.append('image_url', '');\n\n      const result = validateMarketForm(formData);\n      \n      expect(result).not.toBeNull();\n      expect(result?.description).toBeUndefined();\n      expect(result?.hero_image_url).toBeUndefined();\n      expect(result?.image_url).toBeUndefined();\n    });\n  });\n\n  describe('createMarket', () => {\n    it('should require authentication', async () => {\n      // Mock unauthenticated user\n      const mockSupabase = {\n        auth: {\n          getUser: jest.fn().mockResolvedValue({ data: { user: null } })\n        }\n      };\n      \n      require('@/lib/supabase/server').createSupabaseServerClient = jest.fn().mockResolvedValue(mockSupabase);\n\n      const formData = new FormData();\n      const result = await createMarket(formData);\n\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('Non authentifié');\n    });\n\n    it('should require admin role', async () => {\n      // Mock authenticated non-admin user\n      const mockUser = { id: 'user-123' };\n      const mockSupabase = {\n        auth: {\n          getUser: jest.fn().mockResolvedValue({ data: { user: mockUser } })\n        }\n      };\n      \n      require('@/lib/supabase/server').createSupabaseServerClient = jest.fn().mockResolvedValue(mockSupabase);\n      require('@/lib/auth/admin-service').checkAdminRole = jest.fn().mockResolvedValue(false);\n\n      const formData = new FormData();\n      const result = await createMarket(formData);\n\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('Accès non autorisé');\n    });\n  });\n\n  describe('updateMarket', () => {\n    it('should require authentication', async () => {\n      const mockSupabase = {\n        auth: {\n          getUser: jest.fn().mockResolvedValue({ data: { user: null } })\n        }\n      };\n      \n      require('@/lib/supabase/server').createSupabaseServerClient = jest.fn().mockResolvedValue(mockSupabase);\n\n      const formData = new FormData();\n      const result = await updateMarket('market-id', formData);\n\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('Non authentifié');\n    });\n  });\n\n  describe('deleteMarket', () => {\n    it('should require authentication', async () => {\n      const mockSupabase = {\n        auth: {\n          getUser: jest.fn().mockResolvedValue({ data: { user: null } })\n        }\n      };\n      \n      require('@/lib/supabase/server').createSupabaseServerClient = jest.fn().mockResolvedValue(mockSupabase);\n\n      const result = await deleteMarket('market-id');\n\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('Non authentifié');\n    });\n\n    it('should validate market ID', async () => {\n      const mockUser = { id: 'user-123' };\n      const mockSupabase = {\n        auth: {\n          getUser: jest.fn().mockResolvedValue({ data: { user: mockUser } })\n        }\n      };\n      \n      require('@/lib/supabase/server').createSupabaseServerClient = jest.fn().mockResolvedValue(mockSupabase);\n      require('@/lib/auth/admin-service').checkAdminRole = jest.fn().mockResolvedValue(true);\n\n      // Test with invalid ID\n      const result = await deleteMarket('');\n\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('ID de marché invalide');\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\actions\\cartActions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'z' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isGeneralErrorResult' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RemoveFromCartInput' is defined but never used. Allowed unused vars must match /^_/u.","line":33,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UpdateCartItemQuantityInput' is defined but never used. Allowed unused vars must match /^_/u.","line":34,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":278,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":278,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8043,8046],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8043,8046],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":325,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":325,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":369,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":369,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10603,10606],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10603,10606],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use server\";\n\n/**\n * Unified Cart Actions - Clean Architecture\n * \n * Consolidates all cart server actions with:\n * - Clean error handling\n * - Proper validation\n * - Optimistic update support\n * - Legacy compatibility\n */\n\nimport crypto from \"crypto\";\nimport { revalidateTag } from \"next/cache\";\nimport { z } from \"zod\";\n\nimport { getActiveUserId } from \"@/utils/authUtils\";\nimport {\n  createGeneralErrorResult,\n  createSuccessResult,\n  createValidationErrorResult,\n  isGeneralErrorResult,\n  type CartActionResult,\n} from \"@/lib/cart-helpers\";\nimport { getCart } from \"@/lib/cartReader\";\nimport { createSupabaseAdminClient } from \"@/lib/supabase/server-admin\";\nimport { createSupabaseServerClient } from \"@/lib/supabase/server\";\nimport type { CartData } from \"@/types/cart\";\nimport {\n  AddToCartInputSchema,\n  RemoveFromCartInputSchema,\n  UpdateCartItemQuantityInputSchema,\n  type RemoveFromCartInput,\n  type UpdateCartItemQuantityInput,\n} from \"@/lib/validators/cart.validator\";\n\n// Re-export getCart for external usage\nexport { getCart };\n\n// --- Core Cart Actions ---\n\n/**\n * Add item to cart with proper validation and error handling\n */\nexport async function addItemToCartAction(\n  prevState: unknown,\n  formData: FormData\n): Promise<CartActionResult<CartData | null>> {\n  try {\n    // Validate input\n    const validatedFields = AddToCartInputSchema.safeParse({\n      productId: formData.get(\"productId\"),\n      quantity: formData.get(\"quantity\"),\n    });\n\n    if (!validatedFields.success) {\n      return createValidationErrorResult(\n        validatedFields.error.flatten().fieldErrors,\n        \"Erreur de validation.\"\n      );\n    }\n\n    const { productId, quantity } = validatedFields.data;\n\n    // Get user context\n    const supabase = await createSupabaseServerClient();\n    const adminSupabase = await createSupabaseAdminClient();\n    const userId = await getActiveUserId(supabase);\n\n    // Fetch product details for validation\n    const { data: product, error: productError } = await supabase\n      .from(\"products\")\n      .select(\"id, name, price, image_url, stock, slug\")\n      .eq(\"id\", productId)\n      .eq(\"is_active\", true)\n      .single();\n\n    if (productError || !product) {\n      return createGeneralErrorResult(\"Produit non trouvé ou non disponible.\");\n    }\n\n    // Check stock availability\n    if (product.stock !== null && product.stock < quantity) {\n      return createGeneralErrorResult(\"Stock insuffisant pour ce produit.\");\n    }\n\n    // Get current cart\n    const cartResult = await getCart();\n    if (!cartResult.success) {\n      return createGeneralErrorResult(\"Erreur lors de la récupération du panier.\");\n    }\n\n    const currentCart = cartResult.data;\n    const existingItem = currentCart?.items.find(item => item.productId === productId);\n\n    if (existingItem) {\n      // Update existing item quantity\n      const newQuantity = existingItem.quantity + quantity;\n      \n      // Check total quantity against stock\n      if (product.stock !== null && product.stock < newQuantity) {\n        return createGeneralErrorResult(\"Stock insuffisant pour cette quantité.\");\n      }\n\n      const { error: updateError } = await adminSupabase\n        .from(\"cart_items\")\n        .update({ \n          quantity: newQuantity,\n          updated_at: new Date().toISOString()\n        })\n        .eq(\"id\", existingItem.id);\n\n      if (updateError) {\n        return createGeneralErrorResult(\"Erreur lors de la mise à jour du panier.\");\n      }\n    } else {\n      // Add new item to cart\n      const cartId = currentCart?.id || crypto.randomUUID();\n      \n      // Create cart if it doesn't exist\n      if (!currentCart?.id) {\n        const { error: cartError } = await adminSupabase\n          .from(\"carts\")\n          .insert({\n            id: cartId,\n            user_id: userId,\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n          });\n\n        if (cartError) {\n          return createGeneralErrorResult(\"Erreur lors de la création du panier.\");\n        }\n      }\n\n      // Add cart item\n      const { error: itemError } = await adminSupabase\n        .from(\"cart_items\")\n        .insert({\n          id: crypto.randomUUID(),\n          cart_id: cartId,\n          product_id: productId,\n          quantity,\n          added_at: new Date().toISOString(),\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        });\n\n      if (itemError) {\n        console.error(\"Error inserting cart item:\", itemError);\n        return createGeneralErrorResult(`Erreur lors de l'ajout au panier: ${itemError.message}`);\n      }\n    }\n\n    // Revalidate cart cache\n    revalidateTag(\"cart\");\n\n    // Get updated cart for response\n    const updatedCartResult = await getCart();\n    \n    // Determine appropriate success message based on action taken\n    const successMessage = existingItem \n      ? \"Quantité mise à jour dans le panier.\"\n      : \"Produit ajouté au panier avec succès !\";\n    \n    return createSuccessResult(\n      updatedCartResult.success ? updatedCartResult.data : null,\n      successMessage\n    );\n\n  } catch (error) {\n    console.error(\"Error in addItemToCart:\", error);\n    return createGeneralErrorResult(\"Une erreur inattendue s'est produite.\");\n  }\n}\n\n/**\n * Remove item from cart\n */\nexport async function removeItemFromCartAction(\n  prevState: unknown,\n  formData: FormData\n): Promise<CartActionResult<CartData | null>> {\n  try {\n    const validatedFields = RemoveFromCartInputSchema.safeParse({\n      cartItemId: formData.get(\"cartItemId\"),\n    });\n\n    if (!validatedFields.success) {\n      return createValidationErrorResult(\n        validatedFields.error.flatten().fieldErrors,\n        \"Erreur de validation.\"\n      );\n    }\n\n    const { cartItemId: itemId } = validatedFields.data;\n    const adminSupabase = await createSupabaseAdminClient();\n\n    // Remove the item\n    const { error } = await adminSupabase\n      .from(\"cart_items\")\n      .delete()\n      .eq(\"id\", itemId);\n\n    if (error) {\n      return createGeneralErrorResult(\"Erreur lors de la suppression de l'article.\");\n    }\n\n    // Revalidate cache\n    revalidateTag(\"cart\");\n\n    // Get updated cart\n    const updatedCartResult = await getCart();\n    \n    return createSuccessResult(\n      updatedCartResult.success ? updatedCartResult.data : null,\n      \"Article supprimé du panier.\"\n    );\n\n  } catch (error) {\n    console.error(\"Error in removeItemFromCart:\", error);\n    return createGeneralErrorResult(\"Une erreur inattendue s'est produite.\");\n  }\n}\n\n/**\n * Update cart item quantity\n */\nexport async function updateCartItemQuantityAction(\n  prevState: unknown,\n  formData: FormData\n): Promise<CartActionResult<CartData | null>> {\n  try {\n    const validatedFields = UpdateCartItemQuantityInputSchema.safeParse({\n      cartItemId: formData.get(\"cartItemId\"),\n      quantity: formData.get(\"quantity\"),\n    });\n\n    if (!validatedFields.success) {\n      return createValidationErrorResult(\n        validatedFields.error.flatten().fieldErrors,\n        \"Erreur de validation.\"\n      );\n    }\n\n    const { cartItemId: itemId, quantity } = validatedFields.data;\n\n    if (quantity <= 0) {\n      // If quantity is 0 or negative, remove the item\n      const removeFormData = new FormData();\n      removeFormData.append(\"cartItemId\", itemId);\n      return removeItemFromCartAction(null, removeFormData);\n    }\n\n    const adminSupabase = await createSupabaseAdminClient();\n    const supabase = await createSupabaseServerClient();\n\n    // Get cart item with product info for stock validation\n    const { data: cartItem, error: itemError } = await supabase\n      .from(\"cart_items\")\n      .select(`\n        id,\n        product_id,\n        quantity,\n        products!inner (\n          stock,\n          name\n        )\n      `)\n      .eq(\"id\", itemId)\n      .single();\n\n    if (itemError || !cartItem) {\n      return createGeneralErrorResult(\"Article non trouvé dans le panier.\");\n    }\n\n    // Check stock availability\n    const product = cartItem.products as any;\n    if (product.stock !== null && product.stock < quantity) {\n      return createGeneralErrorResult(\"Stock insuffisant pour cette quantité.\");\n    }\n\n    // Update quantity\n    const { error: updateError } = await adminSupabase\n      .from(\"cart_items\")\n      .update({ \n        quantity,\n        updated_at: new Date().toISOString()\n      })\n      .eq(\"id\", itemId);\n\n    if (updateError) {\n      return createGeneralErrorResult(\"Erreur lors de la mise à jour de la quantité.\");\n    }\n\n    // Revalidate cache\n    revalidateTag(\"cart\");\n\n    // Get updated cart\n    const updatedCartResult = await getCart();\n    \n    // Determine appropriate success message based on quantity change\n    const successMessage = quantity === 0 \n      ? \"Article retiré du panier.\"\n      : `Quantité mise à jour (${quantity}).`;\n    \n    return createSuccessResult(\n      updatedCartResult.success ? updatedCartResult.data : null,\n      successMessage\n    );\n\n  } catch (error) {\n    console.error(\"Error in updateCartItemQuantity:\", error);\n    return createGeneralErrorResult(\"Une erreur inattendue s'est produite.\");\n  }\n}\n\n/**\n * Clear entire cart\n */\nexport async function clearCartAction(): Promise<CartActionResult<CartData | null>> {\n  try {\n    const supabase = await createSupabaseServerClient();\n    const adminSupabase = await createSupabaseAdminClient();\n    const userId = await getActiveUserId(supabase);\n\n    // Get current cart\n    const cartResult = await getCart();\n    if (!cartResult.success || !cartResult.data) {\n      return createSuccessResult(null, \"Panier déjà vide.\");\n    }\n\n    // Delete all cart items\n    const { error: itemsError } = await adminSupabase\n      .from(\"cart_items\")\n      .delete()\n      .eq(\"cart_id\", cartResult.data.id);\n\n    if (itemsError) {\n      return createGeneralErrorResult(\"Erreur lors de la suppression des articles.\");\n    }\n\n    // Delete the cart\n    const { error: cartError } = await adminSupabase\n      .from(\"carts\")\n      .delete()\n      .eq(\"id\", cartResult.data.id);\n\n    if (cartError) {\n      console.warn(\"Could not delete cart:\", cartError);\n      // Non-critical error, items are already deleted\n    }\n\n    // Revalidate cache\n    revalidateTag(\"cart\");\n\n    return createSuccessResult(null, \"Panier vidé avec succès.\");\n\n  } catch (error) {\n    console.error(\"Error in clearCartAction:\", error);\n    return createGeneralErrorResult(\"Une erreur inattendue s'est produite.\");\n  }\n}\n\n/**\n * Migrate guest cart to authenticated user cart\n */\nexport async function migrateAndGetCart(\n  guestCartItems: any[] = []\n): Promise<CartActionResult<CartData | null>> {\n  try {\n    const supabase = await createSupabaseServerClient();\n    const userId = await getActiveUserId(supabase);\n    \n    if (!userId) {\n      return createGeneralErrorResult(\"Utilisateur non authentifié.\");\n    }\n\n    // If no guest items to migrate, just return current cart\n    if (!guestCartItems || guestCartItems.length === 0) {\n      const cartResult = await getCart();\n      return cartResult.success \n        ? createSuccessResult(cartResult.data, \"Panier récupéré.\")\n        : createGeneralErrorResult(\"Erreur lors de la récupération du panier.\");\n    }\n\n    const adminSupabase = await createSupabaseAdminClient();\n\n    // Get or create user cart\n    let { data: userCart } = await supabase\n      .from(\"carts\")\n      .select(\"id\")\n      .eq(\"user_id\", userId)\n      .single();\n\n    if (!userCart) {\n      const cartId = crypto.randomUUID();\n      const { error: cartError } = await adminSupabase\n        .from(\"carts\")\n        .insert({\n          id: cartId,\n          user_id: userId,\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        });\n\n      if (cartError) {\n        return createGeneralErrorResult(\"Erreur lors de la création du panier utilisateur.\");\n      }\n\n      userCart = { id: cartId };\n    }\n\n    // Migrate guest items to user cart\n    for (const guestItem of guestCartItems) {\n      // Check if product exists and is active\n      const { data: product } = await supabase\n        .from(\"products\")\n        .select(\"id, name, price, image_url, slug, stock\")\n        .eq(\"id\", guestItem.productId)\n        .eq(\"is_active\", true)\n        .single();\n\n      if (!product) continue; // Skip invalid products\n\n      // Check if item already exists in user cart\n      const { data: existingItem } = await supabase\n        .from(\"cart_items\")\n        .select(\"id, quantity\")\n        .eq(\"cart_id\", userCart.id)\n        .eq(\"product_id\", guestItem.productId)\n        .single();\n\n      if (existingItem) {\n        // Update existing item quantity\n        const newQuantity = existingItem.quantity + guestItem.quantity;\n        \n        // Check stock\n        if (product.stock !== null && product.stock < newQuantity) {\n          continue; // Skip if would exceed stock\n        }\n\n        await adminSupabase\n          .from(\"cart_items\")\n          .update({ \n            quantity: newQuantity,\n            updated_at: new Date().toISOString()\n          })\n          .eq(\"id\", existingItem.id);\n      } else {\n        // Add new item\n        if (product.stock !== null && product.stock < guestItem.quantity) {\n          continue; // Skip if exceeds stock\n        }\n\n        await adminSupabase\n          .from(\"cart_items\")\n          .insert({\n            id: crypto.randomUUID(),\n            cart_id: userCart.id,\n            product_id: guestItem.productId,\n            quantity: guestItem.quantity,\n            added_at: new Date().toISOString(),\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n          });\n      }\n    }\n\n    // Revalidate cache\n    revalidateTag(\"cart\");\n\n    // Return migrated cart\n    const cartResult = await getCart();\n    return cartResult.success \n      ? createSuccessResult(cartResult.data, \"Panier migré avec succès.\")\n      : createGeneralErrorResult(\"Erreur lors de la récupération du panier migré.\");\n\n  } catch (error) {\n    console.error(\"Error in migrateAndGetCart:\", error);\n    return createGeneralErrorResult(\"Une erreur inattendue s'est produite.\");\n  }\n}\n\n// --- Legacy Action Wrappers (for compatibility) ---\n\n/**\n * Form action wrapper for removeItemFromCartAction\n */\nexport async function removeItemFromCartFormAction(formData: FormData) {\n  return removeItemFromCartAction(null, formData);\n}\n\n/**\n * Form action wrapper for updateCartItemQuantityAction\n */\nexport async function updateCartItemQuantityFormAction(formData: FormData) {\n  return updateCartItemQuantityAction(null, formData);\n}\n\n// --- Export aliases for backward compatibility ---\nexport { addItemToCartAction as addItemToCart };\nexport { removeItemFromCartAction as removeItemFromCart };\nexport { updateCartItemQuantityAction as updateCartItemQuantity };","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\actions\\marketActions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CreateMarketData' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UpdateMarketData' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":57}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use server\";\n\n/**\n * Market Server Actions\n * \n * Server actions for CRUD operations on markets.\n * Includes authentication, validation, and event emission.\n */\n\nimport { createSupabaseServerClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { checkAdminRole } from \"@/lib/auth/admin-service\";\nimport { ActionResult } from \"@/lib/core/result\";\nimport type { Market, CreateMarketData, UpdateMarketData } from \"@/types/market\";\nimport { \n  createMarketSchema, \n  updateMarketSchema, \n  validateMarketForm,\n  validateUpdateMarketForm\n} from \"@/lib/validators/market\";\nimport {\n  uploadMarketImageCore,\n  UploadImageResult as CoreUploadImageResult,\n} from \"@/lib/storage/image-upload\";\n\n/**\n * Create a new market\n */\nexport async function createMarket(formData: FormData): Promise<ActionResult<{ id: string }>> {\n  try {\n    // 1. Check admin permissions\n    const supabase = await createSupabaseServerClient();\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n      return { success: false, error: \"Non authentifié\" };\n    }\n    const isAdmin = await checkAdminRole(user.id);\n    if (!isAdmin) {\n      return { \n        success: false, \n        error: \"Accès non autorisé. Seuls les administrateurs peuvent créer des marchés.\" \n      };\n    }\n\n    // 2. Validate form data\n    const validatedData = validateMarketForm(formData);\n    if (!validatedData) {\n      return { success: false, error: \"Données du formulaire invalides\" };\n    }\n\n    // 3. Validate with schema\n    const validation = createMarketSchema.safeParse(validatedData);\n    if (!validation.success) {\n      const firstError = validation.error.errors[0];\n      return { \n        success: false, \n        error: `Validation échouée: ${firstError.message}` \n      };\n    }\n\n    // 4. Insert into database\n    const { data, error } = await supabase\n      .from(\"markets\")\n      .insert(validation.data)\n      .select(\"id\")\n      .single();\n\n    if (error) {\n      console.error(\"Database error creating market:\", error);\n      return { \n        success: false, \n        error: \"Erreur lors de la création du marché en base de données\" \n      };\n    }\n\n    // 5. Revalidate cache\n    revalidatePath(\"/contact\");\n    revalidatePath(\"/admin/markets\");\n\n    // 6. TODO: Emit event (Phase 4)\n    // await emitMarketCreatedEvent(data.id, validation.data);\n\n    return { \n      success: true, \n      data: { id: data.id },\n      message: \"Marché créé avec succès\"\n    };\n\n  } catch (error) {\n    console.error(\"Unexpected error creating market:\", error);\n    return { \n      success: false, \n      error: \"Erreur inattendue lors de la création du marché\" \n    };\n  }\n}\n\n/**\n * Update an existing market\n */\nexport async function updateMarket(\n  id: string, \n  formData: FormData\n): Promise<ActionResult<void>> {\n  try {\n    // 1. Check admin permissions\n    const supabase = await createSupabaseServerClient();\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n      return { success: false, error: \"Non authentifié\" };\n    }\n    const isAdmin = await checkAdminRole(user.id);\n    if (!isAdmin) {\n      return { \n        success: false, \n        error: \"Accès non autorisé. Seuls les administrateurs peuvent modifier des marchés.\" \n      };\n    }\n\n    // 2. Validate form data for updates\n    const validatedData = validateUpdateMarketForm(formData);\n    if (!validatedData) {\n      return { success: false, error: \"Données du formulaire invalides\" };\n    }\n\n    // 3. Validate with schema\n    const validation = updateMarketSchema.safeParse({\n      id,\n      ...validatedData\n    });\n    if (!validation.success) {\n      const firstError = validation.error.errors[0];\n      return { \n        success: false, \n        error: `Validation échouée: ${firstError.message}` \n      };\n    }\n\n    // 4. Update in database\n    const { error } = await supabase\n      .from(\"markets\")\n      .update(validation.data)\n      .eq(\"id\", id);\n\n    if (error) {\n      console.error(\"Database error updating market:\", error);\n      return { \n        success: false, \n        error: \"Erreur lors de la modification du marché\" \n      };\n    }\n\n    // 5. Revalidate cache\n    revalidatePath(\"/contact\");\n    revalidatePath(\"/admin/markets\");\n\n    // 6. TODO: Emit event (Phase 4)\n    // await emitMarketUpdatedEvent(id, validation.data);\n\n    return { \n      success: true,\n      message: \"Marché modifié avec succès\"\n    };\n\n  } catch (error) {\n    console.error(\"Unexpected error updating market:\", error);\n    return { \n      success: false, \n      error: \"Erreur inattendue lors de la modification du marché\" \n    };\n  }\n}\n\n/**\n * Delete a market\n */\nexport async function deleteMarket(id: string): Promise<ActionResult<void>> {\n  try {\n    // 1. Check admin permissions\n    const supabase = await createSupabaseServerClient();\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n      return { success: false, error: \"Non authentifié\" };\n    }\n    const isAdmin = await checkAdminRole(user.id);\n    if (!isAdmin) {\n      return { \n        success: false, \n        error: \"Accès non autorisé. Seuls les administrateurs peuvent supprimer des marchés.\" \n      };\n    }\n\n    // 2. Validate ID\n    if (!id || typeof id !== 'string') {\n      return { success: false, error: \"ID de marché invalide\" };\n    }\n\n    // 3. Get market details before deletion (for event emission)\n    const { data: market, error: fetchError } = await supabase\n      .from(\"markets\")\n      .select(\"name, city\")\n      .eq(\"id\", id)\n      .single();\n\n    if (fetchError) {\n      return { \n        success: false, \n        error: \"Marché non found ou erreur d'accès\" \n      };\n    }\n\n    // 4. Delete from database\n    const { error } = await supabase\n      .from(\"markets\")\n      .delete()\n      .eq(\"id\", id);\n\n    if (error) {\n      console.error(\"Database error deleting market:\", error);\n      return { \n        success: false, \n        error: \"Erreur lors de la suppression du marché\" \n      };\n    }\n\n    // 5. Revalidate cache\n    revalidatePath(\"/contact\");\n    revalidatePath(\"/admin/markets\");\n\n    // 6. TODO: Emit event (Phase 4)\n    // await emitMarketDeletedEvent(id, market);\n\n    return { \n      success: true,\n      message: `Marché \"${market.name}\" supprimé avec succès`\n    };\n\n  } catch (error) {\n    console.error(\"Unexpected error deleting market:\", error);\n    return { \n      success: false, \n      error: \"Erreur inattendue lors de la suppression du marché\" \n    };\n  }\n}\n\n/**\n * Get all markets (for admin interface)\n */\nexport async function getMarkets(): Promise<ActionResult<Market[]>> {\n  try {\n    const supabase = await createSupabaseServerClient();\n    const { data: markets, error } = await supabase\n      .from(\"markets\")\n      .select(\"*\")\n      .order(\"start_date\", { ascending: true });\n\n    if (error) {\n      console.error(\"Database error fetching markets:\", error);\n      return { \n        success: false, \n        error: \"Erreur lors de la récupération des marchés\" \n      };\n    }\n\n    return { \n      success: true, \n      data: markets || [] \n    };\n\n  } catch (error) {\n    console.error(\"Unexpected error fetching markets:\", error);\n    return { \n      success: false, \n      error: \"Erreur inattendue lors de la récupération des marchés\" \n    };\n  }\n}\n\n/**\n * Get a single market by ID\n */\nexport async function getMarketById(id: string): Promise<ActionResult<Market>> {\n  try {\n    if (!id || typeof id !== 'string') {\n      return { success: false, error: \"ID de marché invalide\" };\n    }\n\n    const supabase = await createSupabaseServerClient();\n    const { data: market, error } = await supabase\n      .from(\"markets\")\n      .select(\"*\")\n      .eq(\"id\", id)\n      .single();\n\n    if (error) {\n      console.error(\"Database error fetching market:\", error);\n      return { \n        success: false, \n        error: \"Marché non trouvé\" \n      };\n    }\n\n    return { \n      success: true, \n      data: market \n    };\n\n  } catch (error) {\n    console.error(\"Unexpected error fetching market:\", error);\n    return { \n      success: false, \n      error: \"Erreur inattendue lors de la récupération du marché\" \n    };\n  }\n}\n\n/**\n * Redirect to markets admin page\n */\nexport async function redirectToMarketsAdmin(): Promise<never> {\n  redirect(\"/admin/markets\");\n}\n\n/**\n * Upload market image\n */\nexport type UploadImageResult = CoreUploadImageResult;\nexport const uploadMarketImage = uploadMarketImageCore;","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\actions\\partnerActions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CreatePartnerData' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UpdatePartnerData' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":60}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use server\";\n\n/**\n * Partner Server Actions\n * \n * Server actions for CRUD operations on partners.\n * Includes authentication, validation, and event emission.\n */\n\nimport { createSupabaseServerClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { checkAdminRole } from \"@/lib/auth/admin-service\";\nimport { ActionResult } from \"@/lib/core/result\";\nimport type { Partner, CreatePartnerData, UpdatePartnerData } from \"@/types/partner\";\nimport { \n  createPartnerSchema, \n  updatePartnerSchema, \n  validatePartnerForm,\n  updatePartnerOrderSchema,\n  togglePartnerStatusSchema\n} from \"@/lib/validators/partner\";\nimport {\n  uploadPartnerImageCore,\n  UploadImageResult as CoreUploadImageResult,\n} from \"@/lib/storage/image-upload\";\n\n/**\n * Create a new partner\n */\nexport async function createPartner(formData: FormData): Promise<ActionResult<{ id: string }>> {\n  try {\n    // 1. Check admin permissions\n    const supabase = await createSupabaseServerClient();\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n      return { success: false, error: \"Non authentifié\" };\n    }\n    const isAdmin = await checkAdminRole(user.id);\n    if (!isAdmin) {\n      return { \n        success: false, \n        error: \"Accès non autorisé. Seuls les administrateurs peuvent créer des partenaires.\" \n      };\n    }\n\n    // 2. Validate form data\n    const validatedData = validatePartnerForm(formData);\n    if (!validatedData) {\n      return { success: false, error: \"Données du formulaire invalides\" };\n    }\n\n    // 3. Validate with schema\n    const validation = createPartnerSchema.safeParse(validatedData);\n    if (!validation.success) {\n      const firstError = validation.error.errors[0];\n      return { \n        success: false, \n        error: `Validation échouée: ${firstError.message}` \n      };\n    }\n\n    // 4. Insert into database\n    const { data, error } = await supabase\n      .from(\"partners\")\n      .insert(validation.data)\n      .select(\"id\")\n      .single();\n\n    if (error) {\n      console.error(\"Database error creating partner:\", error);\n      return { \n        success: false, \n        error: \"Erreur lors de la création du partenaire en base de données\" \n      };\n    }\n\n    // 5. Revalidate cache\n    revalidatePath(\"/partenaires\");\n    revalidatePath(\"/admin/partners\");\n\n    // 6. TODO: Emit event (Phase 4)\n    // await emitPartnerCreatedEvent(data.id, validation.data);\n\n    return { \n      success: true, \n      data: { id: data.id },\n      message: \"Partenaire créé avec succès\"\n    };\n\n  } catch (error) {\n    console.error(\"Unexpected error creating partner:\", error);\n    return { \n      success: false, \n      error: \"Erreur inattendue lors de la création du partenaire\" \n    };\n  }\n}\n\n/**\n * Update an existing partner\n */\nexport async function updatePartner(\n  id: string, \n  formData: FormData\n): Promise<ActionResult<void>> {\n  try {\n    // 1. Check admin permissions\n    const supabase = await createSupabaseServerClient();\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n      return { success: false, error: \"Non authentifié\" };\n    }\n    const isAdmin = await checkAdminRole(user.id);\n    if (!isAdmin) {\n      return { \n        success: false, \n        error: \"Accès non autorisé. Seuls les administrateurs peuvent modifier des partenaires.\" \n      };\n    }\n\n    // 2. Validate form data\n    const validatedData = validatePartnerForm(formData);\n    if (!validatedData) {\n      return { success: false, error: \"Données du formulaire invalides\" };\n    }\n\n    // 3. Validate with schema\n    const validation = updatePartnerSchema.safeParse({\n      id,\n      ...validatedData\n    });\n    if (!validation.success) {\n      const firstError = validation.error.errors[0];\n      return { \n        success: false, \n        error: `Validation échouée: ${firstError.message}` \n      };\n    }\n\n    // 4. Update in database\n    const { error } = await supabase\n      .from(\"partners\")\n      .update(validation.data)\n      .eq(\"id\", id);\n\n    if (error) {\n      console.error(\"Database error updating partner:\", error);\n      return { \n        success: false, \n        error: \"Erreur lors de la modification du partenaire\" \n      };\n    }\n\n    // 5. Revalidate cache\n    revalidatePath(\"/partenaires\");\n    revalidatePath(\"/admin/partners\");\n\n    // 6. TODO: Emit event (Phase 4)\n    // await emitPartnerUpdatedEvent(id, validation.data);\n\n    return { \n      success: true,\n      message: \"Partenaire modifié avec succès\"\n    };\n\n  } catch (error) {\n    console.error(\"Unexpected error updating partner:\", error);\n    return { \n      success: false, \n      error: \"Erreur inattendue lors de la modification du partenaire\" \n    };\n  }\n}\n\n/**\n * Delete a partner\n */\nexport async function deletePartner(id: string): Promise<ActionResult<void>> {\n  try {\n    // 1. Check admin permissions\n    const supabase = await createSupabaseServerClient();\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n      return { success: false, error: \"Non authentifié\" };\n    }\n    const isAdmin = await checkAdminRole(user.id);\n    if (!isAdmin) {\n      return { \n        success: false, \n        error: \"Accès non autorisé. Seuls les administrateurs peuvent supprimer des partenaires.\" \n      };\n    }\n\n    // 2. Validate ID\n    if (!id || typeof id !== 'string') {\n      return { success: false, error: \"ID de partenaire invalide\" };\n    }\n\n    // 3. Get partner details before deletion (for event emission)\n    const { data: partner, error: fetchError } = await supabase\n      .from(\"partners\")\n      .select(\"name\")\n      .eq(\"id\", id)\n      .single();\n\n    if (fetchError) {\n      return { \n        success: false, \n        error: \"Partenaire non trouvé ou erreur d'accès\" \n      };\n    }\n\n    // 4. Delete from database\n    const { error } = await supabase\n      .from(\"partners\")\n      .delete()\n      .eq(\"id\", id);\n\n    if (error) {\n      console.error(\"Database error deleting partner:\", error);\n      return { \n        success: false, \n        error: \"Erreur lors de la suppression du partenaire\" \n      };\n    }\n\n    // 5. Revalidate cache\n    revalidatePath(\"/partenaires\");\n    revalidatePath(\"/admin/partners\");\n\n    // 6. TODO: Emit event (Phase 4)\n    // await emitPartnerDeletedEvent(id, partner);\n\n    return { \n      success: true,\n      message: `Partenaire \"${partner.name}\" supprimé avec succès`\n    };\n\n  } catch (error) {\n    console.error(\"Unexpected error deleting partner:\", error);\n    return { \n      success: false, \n      error: \"Erreur inattendue lors de la suppression du partenaire\" \n    };\n  }\n}\n\n/**\n * Get all partners (for admin interface)\n */\nexport async function getPartners(): Promise<ActionResult<Partner[]>> {\n  try {\n    const supabase = await createSupabaseServerClient();\n    const { data: partners, error } = await supabase\n      .from(\"partners\")\n      .select(\"*\")\n      .order(\"display_order\", { ascending: true });\n\n    if (error) {\n      console.error(\"Database error fetching partners:\", error);\n      return { \n        success: false, \n        error: \"Erreur lors de la récupération des partenaires\" \n      };\n    }\n\n    return { \n      success: true, \n      data: partners || [] \n    };\n\n  } catch (error) {\n    console.error(\"Unexpected error fetching partners:\", error);\n    return { \n      success: false, \n      error: \"Erreur inattendue lors de la récupération des partenaires\" \n    };\n  }\n}\n\n/**\n * Get a single partner by ID\n */\nexport async function getPartnerById(id: string): Promise<ActionResult<Partner>> {\n  try {\n    if (!id || typeof id !== 'string') {\n      return { success: false, error: \"ID de partenaire invalide\" };\n    }\n\n    const supabase = await createSupabaseServerClient();\n    const { data: partner, error } = await supabase\n      .from(\"partners\")\n      .select(\"*\")\n      .eq(\"id\", id)\n      .single();\n\n    if (error) {\n      console.error(\"Database error fetching partner:\", error);\n      return { \n        success: false, \n        error: \"Partenaire non trouvé\" \n      };\n    }\n\n    return { \n      success: true, \n      data: partner \n    };\n\n  } catch (error) {\n    console.error(\"Unexpected error fetching partner:\", error);\n    return { \n      success: false, \n      error: \"Erreur inattendue lors de la récupération du partenaire\" \n    };\n  }\n}\n\n/**\n * Update partners display order\n */\nexport async function updatePartnersOrder(\n  partnersOrder: Array<{ id: string; display_order: number }>\n): Promise<ActionResult<void>> {\n  try {\n    // 1. Check admin permissions\n    const supabase = await createSupabaseServerClient();\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n      return { success: false, error: \"Non authentifié\" };\n    }\n    const isAdmin = await checkAdminRole(user.id);\n    if (!isAdmin) {\n      return { \n        success: false, \n        error: \"Accès non autorisé. Seuls les administrateurs peuvent réorganiser les partenaires.\" \n      };\n    }\n\n    // 2. Validate data\n    const validation = updatePartnerOrderSchema.safeParse({ partners: partnersOrder });\n    if (!validation.success) {\n      const firstError = validation.error.errors[0];\n      return { \n        success: false, \n        error: `Validation échouée: ${firstError.message}` \n      };\n    }\n\n    // 3. Update in database (batch update)\n    const updatePromises = validation.data.partners.map(({ id, display_order }) =>\n      supabase\n        .from(\"partners\")\n        .update({ display_order })\n        .eq(\"id\", id)\n    );\n\n    const results = await Promise.all(updatePromises);\n    const hasError = results.some(result => result.error);\n\n    if (hasError) {\n      console.error(\"Database error updating partners order:\", results.filter(r => r.error));\n      return { \n        success: false, \n        error: \"Erreur lors de la mise à jour de l'ordre des partenaires\" \n      };\n    }\n\n    // 4. Revalidate cache\n    revalidatePath(\"/partenaires\");\n    revalidatePath(\"/admin/partners\");\n\n    // 5. TODO: Emit event (Phase 4)\n    // await emitPartnersOrderUpdatedEvent(validation.data.partners);\n\n    return { \n      success: true,\n      message: \"Ordre des partenaires mis à jour avec succès\"\n    };\n\n  } catch (error) {\n    console.error(\"Unexpected error updating partners order:\", error);\n    return { \n      success: false, \n      error: \"Erreur inattendue lors de la mise à jour de l'ordre\" \n    };\n  }\n}\n\n/**\n * Toggle partner active status\n */\nexport async function togglePartnerStatus(\n  id: string, \n  isActive: boolean\n): Promise<ActionResult<void>> {\n  try {\n    // 1. Check admin permissions\n    const supabase = await createSupabaseServerClient();\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n      return { success: false, error: \"Non authentifié\" };\n    }\n    const isAdmin = await checkAdminRole(user.id);\n    if (!isAdmin) {\n      return { \n        success: false, \n        error: \"Accès non autorisé. Seuls les administrateurs peuvent modifier le statut des partenaires.\" \n      };\n    }\n\n    // 2. Validate data\n    const validation = togglePartnerStatusSchema.safeParse({ id, is_active: isActive });\n    if (!validation.success) {\n      const firstError = validation.error.errors[0];\n      return { \n        success: false, \n        error: `Validation échouée: ${firstError.message}` \n      };\n    }\n\n    // 3. Update in database\n    const { error } = await supabase\n      .from(\"partners\")\n      .update({ is_active: validation.data.is_active })\n      .eq(\"id\", validation.data.id);\n\n    if (error) {\n      console.error(\"Database error toggling partner status:\", error);\n      return { \n        success: false, \n        error: \"Erreur lors de la modification du statut du partenaire\" \n      };\n    }\n\n    // 4. Revalidate cache\n    revalidatePath(\"/partenaires\");\n    revalidatePath(\"/admin/partners\");\n\n    // 5. TODO: Emit event (Phase 4)\n    // await emitPartnerStatusChangedEvent(validation.data.id, validation.data.is_active);\n\n    const statusText = validation.data.is_active ? \"activé\" : \"désactivé\";\n    return { \n      success: true,\n      message: `Partenaire ${statusText} avec succès`\n    };\n\n  } catch (error) {\n    console.error(\"Unexpected error toggling partner status:\", error);\n    return { \n      success: false, \n      error: \"Erreur inattendue lors de la modification du statut\" \n    };\n  }\n}\n\n/**\n * Redirect to partners admin page\n */\nexport async function redirectToPartnersAdmin(): Promise<never> {\n  redirect(\"/admin/partners\");\n}\n\n/**\n * Upload partner image\n */\nexport type UploadImageResult = CoreUploadImageResult;\nexport const uploadPartnerImage = uploadPartnerImageCore;","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\app\\[locale]\\admin\\markets\\market-form.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used. Allowed unused caught errors must match /^_/u.","line":68,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":68,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport { useState, useTransition, useRef } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createMarket, updateMarket } from \"@/actions/marketActions\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { AlertCircle, Loader2 } from \"lucide-react\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport type { Market } from \"@/types/market\";\nimport { ImageUploadButton } from \"@/components/shared/image-upload-button\";\nimport { uploadMarketImageCore } from \"@/lib/storage/image-upload\";\n\ninterface MarketFormProps {\n  market?: Market;\n  mode?: \"create\" | \"edit\";\n}\n\nconst DAYS_OF_WEEK = [\n  { value: \"0\", label: \"Dimanche\" },\n  { value: \"1\", label: \"Lundi\" },\n  { value: \"2\", label: \"Mardi\" },\n  { value: \"3\", label: \"Mercredi\" },\n  { value: \"4\", label: \"Jeudi\" },\n  { value: \"5\", label: \"Vendredi\" },\n  { value: \"6\", label: \"Samedi\" },\n];\n\nexport function MarketForm({ market, mode = \"create\" }: MarketFormProps) {\n  const router = useRouter();\n  const [isPending, startTransition] = useTransition();\n  const [error, setError] = useState<string | null>(null);\n  const [success, setSuccess] = useState(false);\n  const heroImageRef = useRef<HTMLInputElement>(null);\n  const imageRef = useRef<HTMLInputElement>(null);\n\n  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    setError(null);\n    setSuccess(false);\n\n    const formData = new FormData(event.currentTarget);\n\n    startTransition(async () => {\n      try {\n        let result;\n        \n        if (mode === \"edit\" && market) {\n          result = await updateMarket(market.id, formData);\n        } else {\n          result = await createMarket(formData);\n        }\n\n        if (result.success) {\n          setSuccess(true);\n          // Redirect after a brief delay to show success message\n          setTimeout(() => {\n            router.push(\"/admin/markets\");\n          }, 1500);\n        } else {\n          setError(result.error);\n        }\n      } catch (err) {\n        setError(\"Une erreur inattendue s'est produite\");\n      }\n    });\n  };\n\n  return (\n    <Card className=\"max-w-2xl\">\n      <CardHeader>\n        <CardTitle>\n          {mode === \"edit\" ? \"Modifier le marché\" : \"Nouveau marché\"}\n        </CardTitle>\n        <CardDescription>\n          {mode === \"edit\" \n            ? \"Modifiez les informations du marché\" \n            : \"Remplissez les informations du nouveau marché\"\n          }\n        </CardDescription>\n      </CardHeader>\n      <CardContent>\n        {error && (\n          <Alert variant=\"destructive\" className=\"mb-6\">\n            <AlertCircle className=\"h-4 w-4\" />\n            <AlertDescription>{error}</AlertDescription>\n          </Alert>\n        )}\n\n        {success && (\n          <Alert className=\"mb-6 border-green-200 bg-green-50\">\n            <AlertCircle className=\"h-4 w-4 text-green-600\" />\n            <AlertDescription className=\"text-green-800\">\n              Marché {mode === \"edit\" ? \"modifié\" : \"créé\"} avec succès ! Redirection...\n            </AlertDescription>\n          </Alert>\n        )}\n\n        <form onSubmit={handleSubmit} className=\"space-y-6\">\n          {/* Nom du marché */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"name\">Nom du marché *</Label>\n            <Input\n              id=\"name\"\n              name=\"name\"\n              defaultValue={market?.name}\n              required\n              placeholder=\"ex: Marché nocturne de Portiragnes\"\n            />\n          </div>\n\n          {/* Ville */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"city\">Ville *</Label>\n            <Input\n              id=\"city\"\n              name=\"city\"\n              defaultValue={market?.city}\n              required\n              placeholder=\"ex: Portiragnes\"\n            />\n          </div>\n\n          {/* Adresse */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"address\">Adresse *</Label>\n            <Input\n              id=\"address\"\n              name=\"address\"\n              defaultValue={market?.address}\n              required\n              placeholder=\"ex: Front de mer, 34420 Portiragnes\"\n            />\n          </div>\n\n          {/* Dates */}\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"start_date\">Date de début *</Label>\n              <Input\n                id=\"start_date\"\n                name=\"start_date\"\n                type=\"date\"\n                defaultValue={market?.start_date}\n                required\n              />\n            </div>\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"end_date\">Date de fin *</Label>\n              <Input\n                id=\"end_date\"\n                name=\"end_date\"\n                type=\"date\"\n                defaultValue={market?.end_date}\n                required\n              />\n            </div>\n          </div>\n\n          {/* Jour de la semaine */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"day_of_week\">Jour de la semaine *</Label>\n            <Select name=\"day_of_week\" defaultValue={market?.day_of_week?.toString()}>\n              <SelectTrigger>\n                <SelectValue placeholder=\"Sélectionnez un jour\" />\n              </SelectTrigger>\n              <SelectContent>\n                {DAYS_OF_WEEK.map((day) => (\n                  <SelectItem key={day.value} value={day.value}>\n                    {day.label}\n                  </SelectItem>\n                ))}\n              </SelectContent>\n            </Select>\n          </div>\n\n          {/* Horaires */}\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"start_time\">Heure de début *</Label>\n              <Input\n                id=\"start_time\"\n                name=\"start_time\"\n                type=\"time\"\n                defaultValue={market?.start_time}\n                required\n              />\n            </div>\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"end_time\">Heure de fin *</Label>\n              <Input\n                id=\"end_time\"\n                name=\"end_time\"\n                type=\"time\"\n                defaultValue={market?.end_time}\n                required\n              />\n            </div>\n          </div>\n\n          {/* Description */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"description\">Description</Label>\n            <Textarea\n              id=\"description\"\n              name=\"description\"\n              defaultValue={market?.description || \"\"}\n              placeholder=\"Description du marché (optionnel)\"\n              rows={3}\n            />\n          </div>\n\n          {/* Lien GPS */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"gps_link\">Lien GPS</Label>\n            <Input\n              id=\"gps_link\"\n              name=\"gps_link\"\n              type=\"url\"\n              defaultValue={market?.gps_link || \"\"}\n              placeholder=\"https://maps.google.com/...\"\n            />\n          </div>\n\n          {/* Images avec upload */}\n          <div className=\"grid grid-cols-1 gap-4\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"hero_image_url\">Image principale</Label>\n              <div className=\"flex gap-2\">\n                <Input\n                  ref={heroImageRef}\n                  id=\"hero_image_url\"\n                  name=\"hero_image_url\"\n                  type=\"url\"\n                  defaultValue={market?.hero_image_url || \"\"}\n                  placeholder=\"https://example.com/image.jpg\"\n                  className=\"flex-1\"\n                />\n                <ImageUploadButton\n                  onUploadSuccess={(url) => {\n                    if (heroImageRef.current) {\n                      heroImageRef.current.value = url;\n                    }\n                  }}\n                  uploadFunction={uploadMarketImageCore}\n                  label=\"Upload\"\n                />\n              </div>\n              {market?.hero_image_url && (\n                <img \n                  src={market.hero_image_url} \n                  alt=\"Image principale\" \n                  className=\"h-24 w-auto rounded-md\"\n                />\n              )}\n            </div>\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"image_url\">Image secondaire</Label>\n              <div className=\"flex gap-2\">\n                <Input\n                  ref={imageRef}\n                  id=\"image_url\"\n                  name=\"image_url\"\n                  type=\"url\"\n                  defaultValue={market?.image_url || \"\"}\n                  placeholder=\"https://example.com/image2.jpg\"\n                  className=\"flex-1\"\n                />\n                <ImageUploadButton\n                  onUploadSuccess={(url) => {\n                    if (imageRef.current) {\n                      imageRef.current.value = url;\n                    }\n                  }}\n                  uploadFunction={uploadMarketImageCore}\n                  label=\"Upload\"\n                />\n              </div>\n              {market?.image_url && (\n                <img \n                  src={market.image_url} \n                  alt=\"Image secondaire\" \n                  className=\"h-24 w-auto rounded-md\"\n                />\n              )}\n            </div>\n          </div>\n\n          {/* Statut actif */}\n          <div className=\"flex items-center space-x-2\">\n            <Switch\n              id=\"is_active\"\n              name=\"is_active\"\n              defaultChecked={market?.is_active ?? true}\n            />\n            <Label htmlFor=\"is_active\">Marché actif</Label>\n          </div>\n\n          {/* Actions */}\n          <div className=\"flex gap-4 pt-4\">\n            <Button type=\"submit\" disabled={isPending}>\n              {isPending && <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />}\n              {mode === \"edit\" ? \"Mettre à jour\" : \"Créer\"}\n            </Button>\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              onClick={() => router.push(\"/admin/markets\")}\n              disabled={isPending}\n            >\n              Annuler\n            </Button>\n          </div>\n        </form>\n      </CardContent>\n    </Card>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\app\\[locale]\\admin\\partners\\partner-form.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used. Allowed unused caught errors must match /^_/u.","line":56,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport { useState, useTransition, useRef } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { createPartner, updatePartner } from \"@/actions/partnerActions\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { AlertCircle, Loader2 } from \"lucide-react\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport type { Partner } from \"@/types/partner\";\nimport { ImageUploadButton } from \"@/components/shared/image-upload-button\";\nimport { uploadPartnerImageCore } from \"@/lib/storage/image-upload\";\n\ninterface PartnerFormProps {\n  partner?: Partner;\n  mode?: \"create\" | \"edit\";\n}\n\nexport function PartnerForm({ partner, mode = \"create\" }: PartnerFormProps) {\n  const router = useRouter();\n  const [isPending, startTransition] = useTransition();\n  const [error, setError] = useState<string | null>(null);\n  const [success, setSuccess] = useState(false);\n  const imageUrlRef = useRef<HTMLInputElement>(null);\n\n  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    setError(null);\n    setSuccess(false);\n\n    const formData = new FormData(event.currentTarget);\n\n    startTransition(async () => {\n      try {\n        let result;\n        \n        if (mode === \"edit\" && partner) {\n          result = await updatePartner(partner.id, formData);\n        } else {\n          result = await createPartner(formData);\n        }\n\n        if (result.success) {\n          setSuccess(true);\n          // Redirect after a brief delay to show success message\n          setTimeout(() => {\n            router.push(\"/admin/partners\");\n          }, 1500);\n        } else {\n          setError(result.error);\n        }\n      } catch (err) {\n        setError(\"Une erreur inattendue s'est produite\");\n      }\n    });\n  };\n\n  return (\n    <Card className=\"max-w-2xl\">\n      <CardHeader>\n        <CardTitle>\n          {mode === \"edit\" ? \"Modifier le partenaire\" : \"Nouveau partenaire\"}\n        </CardTitle>\n        <CardDescription>\n          {mode === \"edit\" \n            ? \"Modifiez les informations du partenaire\" \n            : \"Remplissez les informations du nouveau partenaire\"\n          }\n        </CardDescription>\n      </CardHeader>\n      <CardContent>\n        {error && (\n          <Alert variant=\"destructive\" className=\"mb-6\">\n            <AlertCircle className=\"h-4 w-4\" />\n            <AlertDescription>{error}</AlertDescription>\n          </Alert>\n        )}\n\n        {success && (\n          <Alert className=\"mb-6 border-green-200 bg-green-50\">\n            <AlertCircle className=\"h-4 w-4 text-green-600\" />\n            <AlertDescription className=\"text-green-800\">\n              Partenaire {mode === \"edit\" ? \"modifié\" : \"créé\"} avec succès ! Redirection...\n            </AlertDescription>\n          </Alert>\n        )}\n\n        <form onSubmit={handleSubmit} className=\"space-y-6\">\n          {/* Nom du partenaire */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"name\">Nom du partenaire *</Label>\n            <Input\n              id=\"name\"\n              name=\"name\"\n              defaultValue={partner?.name}\n              required\n              placeholder=\"ex: La Touche essentielle\"\n            />\n          </div>\n\n          {/* Description */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"description\">Description *</Label>\n            <Textarea\n              id=\"description\"\n              name=\"description\"\n              defaultValue={partner?.description}\n              required\n              placeholder=\"Description des services ou produits du partenaire\"\n              rows={4}\n            />\n          </div>\n\n          {/* Adresse */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"address\">Adresse *</Label>\n            <Input\n              id=\"address\"\n              name=\"address\"\n              defaultValue={partner?.address}\n              required\n              placeholder=\"ex: 24 rue Anatole France, 34120 Pézenas\"\n            />\n          </div>\n\n          {/* URL de l'image avec upload */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"image_url\">URL de l'image *</Label>\n            <div className=\"flex gap-2\">\n              <Input\n                ref={imageUrlRef}\n                id=\"image_url\"\n                name=\"image_url\"\n                type=\"url\"\n                defaultValue={partner?.image_url}\n                required\n                placeholder=\"https://example.com/image.jpg\"\n                className=\"flex-1\"\n              />\n              <ImageUploadButton\n                onUploadSuccess={(url) => {\n                  if (imageUrlRef.current) {\n                    imageUrlRef.current.value = url;\n                  }\n                }}\n                uploadFunction={uploadPartnerImageCore}\n                label=\"Upload\"\n              />\n            </div>\n            {partner?.image_url && (\n              <img \n                src={partner.image_url} \n                alt=\"Logo partenaire\" \n                className=\"h-24 w-auto rounded-md\"\n              />\n            )}\n          </div>\n\n          {/* URL Facebook */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"facebook_url\">URL Facebook</Label>\n            <Input\n              id=\"facebook_url\"\n              name=\"facebook_url\"\n              type=\"url\"\n              defaultValue={partner?.facebook_url || \"\"}\n              placeholder=\"https://facebook.com/...\"\n            />\n          </div>\n\n          {/* Ordre d'affichage */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"display_order\">Ordre d'affichage</Label>\n            <Input\n              id=\"display_order\"\n              name=\"display_order\"\n              type=\"number\"\n              min=\"0\"\n              defaultValue={partner?.display_order ?? 0}\n              placeholder=\"0\"\n            />\n            <p className=\"text-sm text-muted-foreground\">\n              Plus le nombre est petit, plus le partenaire apparaîtra en haut de la liste\n            </p>\n          </div>\n\n          {/* Statut actif */}\n          <div className=\"flex items-center space-x-2\">\n            <Switch\n              id=\"is_active\"\n              name=\"is_active\"\n              defaultChecked={partner?.is_active ?? true}\n            />\n            <Label htmlFor=\"is_active\">Partenaire actif</Label>\n          </div>\n\n          {/* Actions */}\n          <div className=\"flex gap-4 pt-4\">\n            <Button type=\"submit\" disabled={isPending}>\n              {isPending && <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />}\n              {mode === \"edit\" ? \"Mettre à jour\" : \"Créer\"}\n            </Button>\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              onClick={() => router.push(\"/admin/partners\")}\n              disabled={isPending}\n            >\n              Annuler\n            </Button>\n          </div>\n        </form>\n      </CardContent>\n    </Card>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\app\\[locale]\\admin\\users\\page.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[468,471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[468,471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getUsers } from \"@/actions/userActions\";\nimport { columns } from \"@/app/[locale]/admin/users/columns\";\nimport { DataTable } from \"@/app/[locale]/admin/users/data-table\";\n\nexport default async function AdminUsersPage() {\n  const result = await getUsers();\n\n  if (!result.success) {\n    return <div className=\"text-red-500\">Error: {result.error}</div>;\n  }\n\n  // TypeScript now knows result.success is true, so result.data exists\n  const users = result.data as any;\n\n  return (\n    <section className=\"container mx-auto py-10\">\n      <h1 className=\"mb-6 text-3xl font-bold\">User Management</h1>\n      <DataTable columns={columns} data={users} />\n    </section>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\app\\[locale]\\profile\\ProfileNavLinks.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1069,1072],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1069,1072],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1367,1370],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1367,1370],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1845,1848],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1845,1848],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport { useTranslations } from \"next-intl\";\nimport { Link, usePathname } from \"@/i18n/navigation\";\nimport { cn } from \"@/utils/cn\";\nimport { ArrowLeft } from \"lucide-react\";\n\n// Définir un type plus spécifique pour les chemins du profil\ntype ProfilePathname =\n  | \"/profile/account\"\n  | \"/profile/addresses\"\n  | \"/profile/orders\"\n  | \"/profile/password\";\n\ninterface NavLinkItem {\n  href: ProfilePathname;\n  labelKey: string;\n}\n\nconst mainLink: NavLinkItem = { href: \"/profile/account\", labelKey: \"account\" };\nconst subLinks: NavLinkItem[] = [\n  { href: \"/profile/addresses\", labelKey: \"addresses\" },\n  { href: \"/profile/orders\", labelKey: \"orders\" },\n  { href: \"/profile/password\", labelKey: \"password\" },\n];\n\nexport default function ProfileNavLinks() {\n  const t = useTranslations(\"ProfileNav\");\n  const pathname = usePathname();\n\n  const isSubPage = (pathname as string) !== mainLink.href;\n\n  return (\n    <nav aria-label={t(\"navigationLabel\")} className=\"flex flex-col space-y-4\">\n      {isSubPage && (\n        <Link\n          href={mainLink.href as any}\n          className=\"inline-flex items-center text-sm font-medium text-muted-foreground hover:text-accent-foreground\"\n        >\n          <ArrowLeft className=\"mr-2 h-4 w-4\" />\n          {t(\"backToAccount\")}\n        </Link>\n      )}\n\n      <div>\n        <Link\n          href={mainLink.href as any}\n          className={cn(\n            \"block rounded-md px-3 py-2 text-base font-semibold text-foreground\",\n            !isSubPage && \"bg-accent\"\n          )}\n        >\n          {t(mainLink.labelKey)}\n        </Link>\n\n        <div className=\"mt-2 space-y-1 pl-4\">\n          {subLinks.map((link) => {\n            const isActive = (pathname as string) === link.href;\n            return (\n              <Link\n                key={link.href}\n                href={link.href as any}\n                className={cn(\n                  \"block rounded-md px-3 py-2 text-sm font-medium text-muted-foreground hover:bg-accent hover:text-accent-foreground\",\n                  isActive && \"bg-accent font-semibold text-accent-foreground\"\n                )}\n                aria-current={isActive ? \"page\" : undefined}\n              >\n                {t(link.labelKey)}\n              </Link>\n            );\n          })}\n        </div>\n      </div>\n    </nav>\n  );\n}\n\n// N'oubliez pas d'ajouter les clés suivantes à vos fichiers de traduction (en.json, fr.json)\n// sous le namespace \"ProfileNav\":\n// \"navigationLabel\": \"Profile Navigation\" (ou \"Navigation du profil\")\n// \"account\": \"My Account\" (ou \"Mon Compte\")\n// \"addresses\": \"My Addresses\" (ou \"Mes Adresses\")\n// \"orders\": \"My Orders\" (ou \"Mes Commandes\")\n// \"password\": \"My Password\" (ou \"Mon Mot de Passe\")\n","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\app\\[locale]\\shop\\page.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":185,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6308,6311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6308,6311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getTranslations } from \"next-intl/server\";\nimport { MainLayout } from \"@/components/layout/main-layout\";\nimport { type Metadata } from \"next\";\nimport { ShopClientContent } from \"@/components/domain/shop/shop-client-content\";\nimport { getAllProducts, ProductForShopQuery } from \"@/lib/supabase/queries/products\";\nimport { getCart } from \"@/lib/cartReader\";\nimport { isSuccessResult } from \"@/lib/cart-helpers\";\nimport type { CartData } from \"@/types/cart\";\nimport { Locale } from \"@/i18n-config\";\nimport { Hero } from \"@/components/shared/hero\";\nimport { getActiveFeaturedHeroItem, type FeaturedHeroItem } from \"@/lib/supabase/queries/hero\";\nimport { Link } from \"@/i18n/navigation\";\n\n// Type for route parameters\ntype PageParams = {\n  locale: Locale;\n};\n\n// Props for ShopPage component\ntype ShopPageProps = {\n  params: Promise<PageParams>; // ✅ params est maintenant une Promise\n};\n\n// Define the type for the data mapped for the grid\nexport type ProductListItem = {\n  id: string;\n  slug: string;\n  price: number;\n  image_url?: string | null;\n  stock: number;\n  is_new?: boolean | null;\n  is_on_promotion?: boolean | null;\n  labels?: string[] | null;\n  name: string;\n  short_description?: string | null;\n  unit?: string | null;\n};\n\n// ✅ Correction de generateMetadata\nexport async function generateMetadata({ params }: ShopPageProps): Promise<Metadata> {\n  const resolvedParams = await params; // ✅ Attendre params\n  const t = await getTranslations({\n    locale: resolvedParams.locale,\n    namespace: \"ShopPage\",\n  });\n  return {\n    title: t(\"title\"),\n  };\n}\n\n// ✅ Correction de la fonction principale\nexport default async function ShopPage({ params }: ShopPageProps) {\n  // ✅ Attendre params en premier\n  const resolvedParams = await params;\n\n  const t = await getTranslations({\n    locale: resolvedParams.locale,\n    namespace: \"ShopPage\",\n  });\n  const tHero = await getTranslations({\n    locale: resolvedParams.locale,\n    namespace: \"HeroComponent\",\n  });\n  const _tProduct = await getTranslations({\n    locale: resolvedParams.locale,\n    namespace: \"ProductCard\",\n  });\n\n  // --- Fetch Data ---\n  // ✅ Utiliser resolvedParams.locale au lieu de params.locale\n  const [heroResult, productsResult, cartResult] = await Promise.allSettled([\n    getActiveFeaturedHeroItem(),\n    getAllProducts(resolvedParams.locale), // ✅ Correction ici\n    getCart(),\n  ]);\n\n  let featuredHeroItem: FeaturedHeroItem | null = null;\n  if (heroResult.status === \"fulfilled\") {\n    featuredHeroItem = heroResult.value;\n  } else {\n    console.error(\"Error fetching featured hero item for ShopPage:\", heroResult.reason);\n  }\n\n  let productsData: ProductForShopQuery[] = [];\n  let fetchError: Error | null = null;\n  let initialCartData: CartData | null = null;\n\n  if (productsResult.status === \"fulfilled\") {\n    productsData = productsResult.value;\n  } else {\n    fetchError =\n      productsResult.reason instanceof Error\n        ? productsResult.reason\n        : new Error(\"Unknown error fetching products\");\n    console.error(\"Error fetching products for ShopPage:\", productsResult.reason);\n    productsData = [];\n  }\n\n  // --- Handle Cart Fetch ---\n  if (cartResult.status === \"fulfilled\" && isSuccessResult(cartResult.value)) {\n    initialCartData = cartResult.value.data;\n  } else if (cartResult.status === \"fulfilled\" && !isSuccessResult(cartResult.value)) {\n    // Log warning for cart fetch issues\n  } else if (cartResult.status === \"rejected\") {\n    console.error(\"[ShopPage] Error fetching initial cart data:\", cartResult.reason);\n  }\n\n  // --- Handle Product Fetch Error ---\n  if (fetchError && productsResult.status === \"rejected\") {\n    return (\n      <MainLayout>\n        <div className=\"container py-8 text-center\">\n          <h1 className=\"mb-6 text-3xl font-bold text-red-600\">{t(\"errorFetchingData\")}</h1>\n          <p>{t(\"tryAgainLater\", { defaultMessage: \"Veuillez réessayer plus tard.\" })}</p>\n          {process.env.NODE_ENV === \"development\" && fetchError && (\n            <pre className=\"mt-4 text-left text-xs text-muted-foreground\">{fetchError.message}</pre>\n          )}\n        </div>\n      </MainLayout>\n    );\n  }\n\n  // --- Prepare Hero Props ---\n  let heroPropsForComponent = null;\n  if (featuredHeroItem) {\n    heroPropsForComponent = {\n      heading: featuredHeroItem.productName,\n      description: (\n        <>\n          {featuredHeroItem.customSubtitle\n            ? featuredHeroItem.customSubtitle\n            : tHero(\"fallbackDescription\")}\n        </>\n      ),\n      imageUrl: featuredHeroItem.heroImageUrl || featuredHeroItem.productImageUrl || undefined,\n      imageAlt: featuredHeroItem.productName\n        ? `Image de ${featuredHeroItem.productName}`\n        : tHero(\"defaultImageAlt\"),\n      ctaLabel:\n        tHero(\"ctaLabel\", { productName: featuredHeroItem.productName }) ||\n        tHero(\"defaultCtaLabel\"),\n      ctaLink: `/products/${featuredHeroItem.productSlug}`,\n    };\n  } else {\n    heroPropsForComponent = {\n      heading: tHero(\"fallbackHeading\"),\n      description: tHero(\"fallbackDescription\"),\n      imageUrl: undefined,\n      imageAlt: tHero(\"fallbackImageAlt\"),\n      ctaLabel: tHero(\"fallbackCtaLabel\"),\n      ctaLink: { pathname: \"/products\" as const } satisfies React.ComponentProps<\n        typeof Link\n      >[\"href\"],\n    };\n  }\n\n  // --- Prepare Product List Items for ShopClientContent ---\n  const productListItems: ProductListItem[] = productsData\n    .filter((p) => p.price !== null)\n    .map((p: ProductForShopQuery) => ({\n      id: p.id,\n      slug: p.slug,\n      name:\n        p.product_translations?.[0]?.name ??\n        t(\"defaultProductName\", { ns: \"translationFallbacks\" }),\n      short_description: p.product_translations?.[0]?.short_description ?? undefined,\n      price: p.price as number,\n      image_url: p.image_url,\n      stock: p.stock ?? 0,\n      is_new: p.is_new,\n      is_on_promotion: p.is_on_promotion,\n      labels: p.labels,\n      unit: p.unit,\n    }));\n\n  // --- Render Page ---\n  return (\n    <MainLayout>\n      <Hero\n        heading={heroPropsForComponent.heading}\n        description={heroPropsForComponent.description}\n        imageUrl={heroPropsForComponent.imageUrl}\n        imageAlt={heroPropsForComponent.imageAlt}\n        ctaLabel={heroPropsForComponent.ctaLabel}\n        ctaLink={heroPropsForComponent.ctaLink as any}\n      />\n\n      <div className=\"container py-8\">\n        <h1 className=\"mb-6 text-3xl font-bold\">{t(\"title\")}</h1>\n        <ShopClientContent initialProducts={productListItems} initialCart={initialCartData} />\n      </div>\n    </MainLayout>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\components\\domain\\colissimo\\ColissimoWidget.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'callbackId.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'callbackId.current' to a variable inside the effect, and use that variable in the cleanup function.","line":218,"column":44,"nodeType":"Identifier","endLine":218,"endColumn":51},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'containerRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'containerRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":227,"column":47,"nodeType":"Identifier","endLine":227,"endColumn":54}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1615,1618],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1615,1618],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2079,2082],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2079,2082],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2267,2270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2267,2270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2370,2373],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2370,2373],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2884,2887],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2884,2887],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3028,3031],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3028,3031],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":154,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4929,4932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4929,4932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6073,6076],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6073,6076],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":190,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":190,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6377,6380],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6377,6380],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":220,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7425,7428],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7425,7428],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":222,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7549,7552],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7549,7552],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\nimport { useEffect, useRef, useState } from \"react\";\nimport $ from \"jquery\";\nimport \"mapbox-gl/dist/mapbox-gl.css\";\n\n// Déclaration globale pour jQuery Colissimo plugin\ndeclare global {\n  interface Window {\n    handleColissimoSelect?: (point: PointRetrait) => void;\n  }\n  interface JQuery {\n    frameColissimoOpen(options: ColissimoWidgetOptions): void;\n    frameColissimoClose(): void;\n  }\n}\n\nexport interface PointRetrait {\n  id: string;\n  name: string;\n  address: string;\n  zipCode: string;\n  city: string;\n  latitude: number;\n  longitude: number;\n  distance: number; // en mètres\n  typeDePoint?: string;\n  horairesOuverture?: string;\n}\n\ninterface ColissimoWidgetOptions {\n  URLColissimo: string;\n  callBackFrame: string;\n  ceCountry: string;\n  ceAddress?: string;\n  ceZipCode?: string;\n  ceTown?: string;\n  origin: string;\n  filterRelay: string;\n  token: string;\n  dyPreparationTime?: number;\n}\n\ninterface DefaultAddress {\n  address?: string;\n  zipCode?: string;\n  city?: string;\n}\n\ninterface ColissimoWidgetProps {\n  token: string;\n  defaultAddress?: DefaultAddress;\n  onSelect: (point: PointRetrait) => void;\n  onError?: (error: string) => void;\n  className?: string;\n}\n\n// Utilitaire pour charger dynamiquement le script jQuery Colissimo\nconst loadColissimoScript = (src: string): Promise<void> => {\n  return new Promise((resolve, reject) => {\n    // Vérifier si le script est déjà chargé et si le plugin est disponible\n    const existingScript = document.querySelector(`script[src=\"${src}\"]`);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (existingScript && ($ as any).fn.frameColissimoOpen) {\n      console.log(\"Script Colissimo déjà chargé et plugin disponible\");\n      resolve();\n      return;\n    }\n\n    // Supprimer tous les scripts Colissimo existants pour éviter les conflits\n    document.querySelectorAll('script[src*=\"colissimo\"]').forEach((script) => script.remove());\n\n    // S'assurer que jQuery est disponible globalement\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (typeof (window as any).jQuery === \"undefined\") {\n      console.log(\"jQuery non disponible globalement, exposition...\");\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (window as any).jQuery = $;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (window as any).$ = $;\n    }\n\n    console.log(\"Chargement du script Colissimo...\");\n    const script = document.createElement(\"script\");\n    script.src = src;\n    script.async = false; // Chargement synchrone pour garantir l'ordre\n    script.type = \"text/javascript\";\n\n    script.onload = () => {\n      console.log(\"Script Colissimo chargé\");\n\n      // Vérifier que le plugin jQuery est bien disponible\n      const checkPlugin = () => {\n        const jQueryAvailable =\n          typeof $ !== \"undefined\" && typeof (window as any).jQuery !== \"undefined\"; // eslint-disable-line @typescript-eslint/no-explicit-any\n        const pluginAvailable = jQueryAvailable && ($ as any).fn.frameColissimoOpen; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n        console.log(`jQuery disponible: ${jQueryAvailable}, Plugin disponible: ${pluginAvailable}`);\n\n        if (pluginAvailable) {\n          console.log(\"Plugin jQuery Colissimo disponible\");\n          resolve();\n        } else if (Date.now() - startTime > 5000) {\n          // Timeout après 5 secondes\n          reject(new Error(\"Timeout: Plugin jQuery Colissimo non disponible après 5 secondes\"));\n        } else {\n          console.log(\"Plugin jQuery Colissimo non disponible, nouvelle tentative...\");\n          setTimeout(checkPlugin, 100);\n        }\n      };\n\n      const startTime = Date.now();\n      // Attendre un peu que le plugin s'initialise\n      setTimeout(checkPlugin, 100);\n    };\n\n    script.onerror = () => {\n      console.error(\"Erreur lors du chargement du script Colissimo\");\n      reject(new Error(`Failed to load script: ${src}`));\n    };\n\n    document.head.appendChild(script);\n  });\n};\n\nexport default function ColissimoWidget({\n  token,\n  defaultAddress,\n  onSelect,\n  onError,\n  className = \"\",\n}: ColissimoWidgetProps) {\n  const containerRef = useRef<HTMLElement>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const callbackId = useRef(`handleColissimoSelect_${Date.now()}`);\n\n  useEffect(() => {\n    if (!token || !containerRef.current) {\n      return;\n    }\n\n    const initializeWidget = async () => {\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Charger le script jQuery Colissimo\n        await loadColissimoScript(\n          \"https://ws.colissimo.fr/widget-colissimo/js/jquery.plugin.colissimo.min.js\"\n        );\n\n        // Vérification finale que le plugin est bien disponible\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (!$ || !($ as any).fn.frameColissimoOpen) {\n          throw new Error(\"Le plugin jQuery Colissimo n'est pas disponible après chargement\");\n        }\n\n        const container = $(containerRef.current!);\n\n        // Vérifier que le conteneur jQuery est valide\n        if (!container.length) {\n          throw new Error(\"Conteneur DOM non trouvé pour le widget Colissimo\");\n        }\n\n        // Configuration du widget\n        const widgetOptions: ColissimoWidgetOptions = {\n          URLColissimo: \"https://ws.colissimo.fr\",\n          callBackFrame: callbackId.current,\n          ceCountry: \"FR\",\n          ceAddress: defaultAddress?.address || \"\",\n          ceZipCode: defaultAddress?.zipCode || \"\",\n          ceTown: defaultAddress?.city || \"\",\n          origin: \"WIDGET\",\n          filterRelay: \"1\", // Tous les points de retrait\n          token,\n          dyPreparationTime: 1, // 1 jour ouvrable de préparation\n        };\n\n        console.log(\"Configuration du widget Colissimo:\", widgetOptions);\n\n        // Définir la callback globale unique pour cette instance\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (window as any)[callbackId.current] = (point: PointRetrait) => {\n          console.log(\"Point de retrait sélectionné:\", point);\n          onSelect(point);\n\n          // Fermer le widget après sélection\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (($ as any).fn.frameColissimoClose) {\n              container.frameColissimoClose();\n            }\n          } catch (closeError) {\n            console.warn(\"Erreur lors de la fermeture du widget:\", closeError);\n          }\n        };\n\n        // Initialiser le widget\n        console.log(\"Initialisation du widget Colissimo...\");\n        container.frameColissimoOpen(widgetOptions);\n\n        console.log(\"Widget Colissimo initialisé avec succès\");\n        setIsLoading(false);\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : \"Erreur inconnue\";\n        console.error(\"Erreur lors de l'initialisation du widget Colissimo:\", err);\n        setError(errorMessage);\n        setIsLoading(false);\n        onError?.(errorMessage);\n      }\n    };\n\n    initializeWidget();\n\n    // Cleanup function\n    return () => {\n      // Nettoyer la callback globale\n      const currentCallbackId = callbackId.current; // Copy to avoid ref issues\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if ((window as any)[currentCallbackId]) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        delete (window as any)[currentCallbackId];\n      }\n\n      // Fermer le widget s'il est ouvert\n      try {\n        const currentContainer = containerRef.current; // Copy to avoid ref issues\n        if (currentContainer) {\n          $(currentContainer).frameColissimoClose();\n        }\n      } catch (closeError) {\n        console.warn(\"Erreur lors du nettoyage du widget:\", closeError);\n      }\n    };\n  }, [token, defaultAddress, onSelect, onError]);\n\n  if (error) {\n    return (\n      <aside className={`rounded-lg border border-red-200 bg-red-50 p-4 ${className}`} role=\"alert\">\n        <header className=\"flex items-center text-red-800\">\n          <svg className=\"mr-2 h-5 w-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\" aria-hidden=\"true\">\n            <path\n              fillRule=\"evenodd\"\n              d=\"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z\"\n              clipRule=\"evenodd\"\n            />\n          </svg>\n          <span className=\"text-sm font-medium\">Erreur de chargement du widget Colissimo</span>\n        </header>\n        <p className=\"mt-1 text-sm text-red-700\">{error}</p>\n      </aside>\n    );\n  }\n\n  return (\n    <section\n      className={`relative ${className}`}\n      aria-label=\"Sélection du point de retrait Colissimo\"\n    >\n      {isLoading && (\n        <aside\n          className=\"flex items-center justify-center rounded-lg bg-gray-50 p-8\"\n          role=\"status\"\n          aria-live=\"polite\"\n        >\n          <header className=\"flex items-center space-x-2\">\n            <span\n              className=\"h-5 w-5 animate-spin rounded-full border-b-2 border-blue-600\"\n              aria-hidden=\"true\"\n            ></span>\n            <span className=\"text-sm text-gray-600\">Chargement du widget Colissimo...</span>\n          </header>\n        </aside>\n      )}\n\n      <main\n        ref={containerRef}\n        id=\"colissimo-widget-container\"\n        className={`${isLoading ? \"hidden\" : \"\"}`}\n        aria-label=\"Interface de sélection des points de retrait\"\n      />\n    </section>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\components\\domain\\shop\\product-detail-display.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: '_syncWithServer'. Either include it or remove the dependency array.","line":77,"column":6,"nodeType":"ArrayExpression","endLine":77,"endColumn":16,"suggestions":[{"desc":"Update the dependencies array to be: [_syncWithServer, state, t]","fix":{"range":[3088,3098],"text":"[_syncWithServer, state, t]"}}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'sectionRefs'. Either include it or remove the dependency array.","line":109,"column":6,"nodeType":"ArrayExpression","endLine":109,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [sectionRefs]","fix":{"range":[4002,4004],"text":"[sectionRefs]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport React, { useState, useEffect, useActionState, useRef } from \"react\";\nimport { useFormStatus } from \"react-dom\";\nimport Image from \"next/image\";\nimport { useLocale, useTranslations } from \"next-intl\";\nimport { type Locale } from \"@/i18n-config\";\nimport { QuantityInput } from \"./quantity-input\";\nimport { ProductDetailData } from \"@/types/product-types\";\nimport { addItemToCart } from \"@/actions/cartActions\";\nimport {\n  type CartActionResult,\n  isGeneralErrorResult, // ✅ Corriger les noms d'imports\n  isSuccessResult,\n  isValidationErrorResult, // ✅ Corriger les noms d'imports\n} from \"@/lib/cart-helpers\";\nimport type { CartDataFromServer } from \"@/types/cart\"; // ✅ Import depuis le bon fichier\nimport { toast } from \"sonner\";\nimport { Button } from \"@/components/ui/button\";\nimport { useCartItems } from \"@/stores/cart.store\";\nimport { useCartOperations } from \"@/lib/store-sync/cart-sync\";\nimport { Price } from \"@/components/ui/price\";\nimport clsx from \"clsx\";\n\ninterface ProductDetailDisplayProps {\n  product: ProductDetailData;\n  // Add other props if needed, e.g., onAddToCart handler from the page\n  // onAddToCart: (productId: string | number, quantity: number) => void;\n}\n\nexport default function ProductDetailDisplay({ product }: ProductDetailDisplayProps) {\n  const locale = useLocale() as Locale;\n  const [activeTab, setActiveTab] = useState(\"description\");\n  const sectionRefs = {\n    description: useRef<HTMLElement>(null),\n    properties: useRef<HTMLElement>(null),\n    composition: useRef<HTMLElement>(null),\n    usage: useRef<HTMLElement>(null),\n  };\n  const t = useTranslations();\n  const [quantity, setQuantity] = useState(1);\n  const _cartItems = useCartItems();\n  const { syncWithServer: _syncWithServer } = useCartOperations();\n\n  // ✅ Define a clear, initial state for the action avec le bon type\n  const initialState: CartActionResult<CartDataFromServer | null> = React.useMemo(\n    () => ({\n      success: false,\n      error: \"Initial state\", // Use a specific error message to identify the initial state\n    }),\n    []\n  );\n  const [state, formAction] = useActionState(addItemToCart, initialState);\n\n  useEffect(() => {\n    // ✅ Do not show any toast if the state is still the initial one.\n    // This is a robust way to prevent toasts on mount, especially with React 18's Strict Mode double-invoking effects.\n    if (isGeneralErrorResult(state) && state.error === \"Initial state\") {\n      return;\n    }\n\n    if (isSuccessResult(state)) {\n      toast.success(state.message || t(\"ProductDetailModal.itemAddedSuccess\"));\n      // Synchronisation avec le serveur après succès\n      _syncWithServer();\n    } else if (state.success === false) {\n      let errorMessage: string | undefined;\n\n      // ✅ Utiliser les bons noms de fonctions\n      if (isValidationErrorResult(state) && state.errors) {\n        errorMessage = Object.values(state.errors).flat()[0];\n      } else if (isGeneralErrorResult(state)) {\n        errorMessage = state.error;\n      }\n      toast.error(state.message || errorMessage || t(\"Global.errors.generic\"));\n    }\n  }, [state, t]); // Removed syncWithServer from dependencies to prevent infinite loops\n\n  useEffect(() => {\n    const observerOptions = {\n      rootMargin: \"-120px 0px -50% 0px\", // Adjust top margin based on sticky header height\n      threshold: 0,\n    };\n\n    const observerCallback = (entries: IntersectionObserverEntry[]) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          setActiveTab(entry.target.id);\n        }\n      });\n    };\n\n    const observer = new IntersectionObserver(observerCallback, observerOptions);\n\n    Object.values(sectionRefs).forEach((ref) => {\n      if (ref.current) {\n        observer.observe(ref.current);\n      }\n    });\n\n    return () => {\n      Object.values(sectionRefs).forEach((ref) => {\n        if (ref.current) {\n          observer.unobserve(ref.current);\n        }\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // Refs are stable, no need to re-run\n\n  const tabs = [\n    { id: \"description\", label: t(\"ProductDetail.tabs.description\") },\n    { id: \"properties\", label: t(\"ProductDetail.tabs.properties\") },\n    { id: \"composition\", label: t(\"ProductDetail.tabs.composition\") },\n    { id: \"usage\", label: t(\"ProductDetail.tabs.usage\") },\n  ];\n\n  return (\n    <div className=\"mx-auto max-w-7xl px-4 py-12 sm:px-6 lg:px-8\">\n      {/* Top section with image and main info */}\n      <div className=\"flex flex-col md:flex-row md:items-stretch md:gap-12\">\n        {/* Image Column */}\n        <div className=\"md:w-1/2\">\n          <div className=\"relative h-full w-full rounded-lg bg-card p-4 shadow-sm lg:p-6\">\n            <Image\n              alt={product.name}\n              src={product.images?.[0]?.src ?? \"/images/placeholder.png\"}\n              fill={true}\n              className=\"rounded-lg object-contain object-center\"\n              sizes=\"(max-width: 768px) 100vw, 50vw\"\n            />\n          </div>\n        </div>\n\n        {/* Info Column */}\n        <div className=\"mt-6 flex flex-col pt-4 md:mt-0 md:w-1/2 lg:pt-6\">\n          <header className=\"flex-grow space-y-3 sm:space-y-4\">\n            <h1 className=\"mb-1 font-serif text-3xl font-bold leading-tight text-gray-900 lg:text-4xl dark:text-white\">\n              {product.name}\n            </h1>\n            {product.unit && (\n              <p className=\"text-sm italic text-muted-foreground lg:text-base\">{product.unit}</p>\n            )}\n            <p className=\"text-foreground/90 text-base leading-relaxed\">\n              {product.shortDescription}\n            </p>\n\n            {/* Price & Action Box */}\n            <section className=\"my-4 rounded-xl bg-background p-4 shadow-lg sm:my-6 sm:p-6\" aria-labelledby=\"product-purchase\">\n              <h2 id=\"product-purchase\" className=\"sr-only\">Achat du produit</h2>\n              <form action={formAction}>\n                <input type=\"hidden\" name=\"productId\" value={product.id} />\n                <input type=\"hidden\" name=\"quantity\" value={quantity} />\n                <div className=\"flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between\">\n                  <div>\n                    <Price\n                      value={product.price}\n                      locale={locale}\n                      className=\"text-olive-600 text-2xl font-bold\"\n                    />\n                    <p className=\"text-xs text-muted-foreground\">{t(\"Global.TTC\")}</p>\n                  </div>\n                  <div className=\"flex flex-col gap-3 sm:flex-row sm:items-center sm:gap-2\">\n                    <QuantityInput\n                      id=\"product-quantity\"\n                      value={quantity}\n                      onChange={setQuantity}\n                      min={1}\n                      max={10}\n                    />\n                    <SubmitButton />\n                  </div>\n                </div>\n              </form>\n            </section>\n          </header>\n\n          {/* Tabs Navigation (at the bottom of the column) */}\n          <nav className=\"mt-auto w-full border-b pt-6\" aria-label=\"Tabs\">\n            <div className=\"flex space-x-4 overflow-x-auto pb-2 scrollbar-hide sm:space-x-6 lg:space-x-8\">\n              {tabs.map((tab) => (\n                <a\n                  key={tab.id}\n                  href={`#${tab.id}`}\n                  className={clsx(\n                    \"flex-shrink-0 whitespace-nowrap border-b-2 px-1 pb-2 font-serif text-sm font-medium transition-colors duration-200 sm:text-base lg:text-lg\",\n                    {\n                      \"border-primary text-primary\": activeTab === tab.id,\n                      \"hover:border-primary/70 border-transparent text-muted-foreground hover:text-primary\":\n                        activeTab !== tab.id,\n                    }\n                  )}\n                >\n                  {tab.label}\n                </a>\n              ))}\n            </div>\n          </nav>\n        </div>\n      </div>\n\n      {/* Content Sections (full width below) */}\n      <div className=\"mt-12 space-y-16\">\n        <section\n          id=\"description\"\n          ref={sectionRefs.description}\n          className=\"mx-auto max-w-4xl scroll-mt-24\"\n        >\n          <h3 className=\"mb-4 font-serif text-2xl text-gray-900 dark:text-white\">\n            {t(\"ProductDetail.tabs.description\")}\n          </h3>\n          <div className=\"text-foreground/90 prose prose-lg max-w-none leading-relaxed dark:prose-invert\">\n            {product.description_long || t(\"ProductDetailModal.noDescription\")}\n          </div>\n        </section>\n\n        <section\n          id=\"properties\"\n          ref={sectionRefs.properties}\n          className=\"mx-auto max-w-4xl scroll-mt-24\"\n        >\n          <h3 className=\"mb-4 font-serif text-2xl text-gray-900 dark:text-white\">\n            {t(\"ProductDetail.tabs.properties\")}\n          </h3>\n          {product.properties ? (\n            <ul className=\"text-foreground/90 list-inside list-disc space-y-2 text-lg\">\n              {product.properties.split(/\\n|\\\\n/).map((line, index) => (\n                <li key={index}>{line.trim().replace(/^\\*\\s*/, \"\")}</li>\n              ))}\n            </ul>\n          ) : (\n            <p>{t(\"ProductDetailModal.noProperties\")}</p>\n          )}\n        </section>\n\n        <section\n          id=\"composition\"\n          ref={sectionRefs.composition}\n          className=\"mx-auto max-w-4xl scroll-mt-24\"\n        >\n          <h3 className=\"mb-4 font-serif text-2xl text-gray-900 dark:text-white\">\n            {t(\"ProductDetail.tabs.composition\")}\n          </h3>\n          <div className=\"text-foreground/90 prose prose-lg max-w-none leading-relaxed dark:prose-invert\">\n            {product.compositionText}\n          </div>\n          <h4 className=\"mb-2 mt-6 font-serif text-xl text-gray-800 dark:text-gray-300\">\n            {t(\"ProductDetailModal.inciList\")}\n          </h4>\n          {product.inciList && product.inciList.length > 0 ? (\n            <ul className=\"grid grid-cols-1 gap-x-4 gap-y-1 text-base text-muted-foreground md:grid-cols-2 lg:gap-x-6\">\n              {product.inciList.map((item, index) => (\n                <li key={index}>{item}</li>\n              ))}\n            </ul>\n          ) : (\n            <p className=\"italic\">{t(\"ProductDetailModal.noInci\")}</p>\n          )}\n        </section>\n\n        <section id=\"usage\" ref={sectionRefs.usage} className=\"mx-auto max-w-4xl scroll-mt-24\">\n          <h3 className=\"mb-4 font-serif text-2xl text-gray-900 dark:text-white\">\n            {t(\"ProductDetail.tabs.usage\")}\n          </h3>\n          {product.usageInstructions ? (\n            <div className=\"text-foreground/90 prose prose-lg max-w-none leading-relaxed dark:prose-invert\">\n              {product.usageInstructions.split(/\\n|\\\\n/).map((line, index) => (\n                <p key={index}>{line.trim().replace(/^\\*\\s*/, \"\")}</p>\n              ))}\n            </div>\n          ) : (\n            <p>{t(\"ProductDetailModal.noUsage\")}</p>\n          )}\n        </section>\n      </div>\n    </div>\n  );\n}\n\n// Submit button needs to be adapted for the new design\nfunction SubmitButton() {\n  const { pending } = useFormStatus();\n  const t = useTranslations(\"ProductDetailModal\");\n\n  return (\n    <Button\n      variant=\"default\"\n      size=\"lg\"\n      type=\"submit\"\n      disabled={pending}\n      aria-disabled={pending}\n      className=\"h-12 max-w-xs text-lg font-semibold\"\n    >\n      {pending ? t(\"addingToCart\") : t(\"addToCart\")}\n    </Button>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\components\\layout\\client-layout.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3352,3355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3352,3355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":105,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3760,3763],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3760,3763],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport { NextIntlClientProvider, AbstractIntlMessages } from \"next-intl\";\nimport { ReactNode, useEffect, useCallback, useRef } from \"react\";\nimport { useSearchParams } from \"next/navigation\";\n// import { Toaster } from \"@/components/ui/sonner\"; // Toaster est déjà dans LocaleLayout\nimport { ThemeProvider } from \"next-themes\";\nimport { createClient } from \"@/lib/supabase/client\";\nimport type { AuthChangeEvent, Session } from \"@supabase/supabase-js\";\nimport { useCartOperations } from \"@/lib/store-sync/cart-sync\";\n\ninterface ClientLayoutProps {\n  children: ReactNode;\n  locale: string;\n  messages: AbstractIntlMessages;\n  timeZone?: string;\n}\n\n// Initialiser le client Supabase une seule fois\nconst supabase = createClient();\n\nexport default function ClientLayout({ children, locale, messages, timeZone }: ClientLayoutProps) {\n  const searchParams = useSearchParams();\n  // Ref pour éviter les doubles clears\n  const hasCheckedInitialSession = useRef(false);\n  const lastSessionState = useRef<Session | null | undefined>(undefined);\n\n  // Hook pour les opérations panier\n  const { clearCart } = useCartOperations();\n  \n  // Fonction pour vider le panier de manière sécurisée\n  const clearCartSafely = useCallback((reason: string) => {\n    console.log(`ClientLayout: Clearing cart - ${reason}`);\n    clearCart();\n    console.log(\"ClientLayout: Cart cleared successfully\");\n  }, [clearCart]);\n\n  // Fonction helper pour les appels Supabase avec timeout et retry\n  const supabaseCallWithTimeout = useCallback(\n    async (promise: Promise<unknown>, timeoutMs = 3000, maxRetries = 2) => {\n      let lastError: Error;\n\n      for (let attempt = 0; attempt <= maxRetries; attempt++) {\n        try {\n          const timeoutPromise = new Promise<never>((_, reject) =>\n            setTimeout(() => reject(new Error(\"Supabase_Timeout\")), timeoutMs)\n          );\n\n          return await Promise.race([promise, timeoutPromise]);\n        } catch (error) {\n          lastError = error as Error;\n\n          // Si c'est un timeout ou erreur réseau et qu'on a encore des tentatives\n          if (\n            attempt < maxRetries &&\n            (lastError.message === \"Supabase_Timeout\" ||\n              lastError.message.includes(\"fetch\") ||\n              lastError.message.includes(\"network\") ||\n              lastError.message.includes(\"Failed to fetch\"))\n          ) {\n            console.warn(\n              `ClientLayout: Retry attempt ${attempt + 1}/${maxRetries + 1} after error:`,\n              lastError.message\n            );\n            // Délai exponentiel entre les tentatives (500ms, 1s)\n            await new Promise((resolve) => setTimeout(resolve, 500 * Math.pow(2, attempt)));\n            continue;\n          }\n\n          // Relancer l'erreur si pas de retry ou retry épuisé\n          throw lastError;\n        }\n      }\n\n      throw lastError!;\n    },\n    []\n  );\n\n  // Fonction pour valider la session de manière asynchrone avec timeout et retry\n  const validateSession = useCallback(async () => {\n    try {\n      // Utilise getUser() pour une validation côté serveur, plus sécurisée\n      const {\n        data: { user },\n        error: userError,\n      } = (await supabaseCallWithTimeout(\n        supabase.auth.getUser(),\n        2500, // Timeout de 2.5 secondes\n        1 // 1 retry seulement pour ne pas trop ralentir\n      )) as any;\n\n      if (userError || !user) {\n        // Pas d'utilisateur authentifié côté serveur\n        return null;\n      }\n\n      // Si l'utilisateur est validé, on peut récupérer la session locale en toute confiance\n      const {\n        data: { session },\n      } = (await supabaseCallWithTimeout(\n        supabase.auth.getSession(),\n        2000, // Timeout plus court pour getSession\n        1\n      )) as any;\n      return session;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        (error.message === \"Supabase_Timeout\" ||\n          error.message.includes(\"fetch\") ||\n          error.message.includes(\"network\") ||\n          error.message.includes(\"Failed to fetch\"))\n      ) {\n        console.warn(\n          \"ClientLayout: Network/timeout error during session validation. Continuing gracefully:\",\n          error.message\n        );\n      } else {\n        console.error(\"ClientLayout: Exception during session validation:\", error);\n      }\n      return null;\n    }\n  }, [supabaseCallWithTimeout]);\n\n  // useEffect to check for 'logged_out' URL parameter on mount or when searchParams change\n  useEffect(() => {\n    if (searchParams.get(\"logged_out\") === \"true\") {\n      console.log(\n        \"ClientLayout: Detected logged_out=true URL parameter via useSearchParams. Ensuring cart is cleared.\"\n      );\n      clearCartSafely(\"Detected logged_out=true URL parameter via useSearchParams\");\n      // Optionally, remove the parameter from URL to prevent re-clearing on subsequent refreshes of the same URL\n      // Consider if this is needed, as it might interfere with history or reloads if not handled carefully.\n      // window.history.replaceState(null, '', window.location.pathname);\n    }\n  }, [searchParams, clearCartSafely]); // Depends on searchParams and clearCartSafely\n\n  useEffect(() => {\n    console.log(\"ClientLayout: Setting up auth state management\");\n\n    // Vérification initiale de la session avec délai pour éviter les états transitoires\n    const checkInitialSession = async () => {\n      if (hasCheckedInitialSession.current) return;\n\n      // Délai court pour laisser le temps à Supabase de se synchroniser\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      const currentSession = await validateSession();\n      console.log(\"ClientLayout: Initial session check:\", currentSession ? \"Active\" : \"None\");\n\n      if (!currentSession) {\n        clearCartSafely(\"Initial session check - no active session\");\n      }\n\n      lastSessionState.current = currentSession;\n      hasCheckedInitialSession.current = true;\n    };\n\n    const {\n      data: { subscription },\n    } = supabase.auth.onAuthStateChange(async (event: AuthChangeEvent, session: Session | null) => {\n      console.log(`ClientLayout: Auth event [${event}]`, {\n        sessionExists: !!session,\n        userId: session?.user?.id,\n        timestamp: new Date().toISOString(),\n      });\n\n      // Gestion spécifique par événement\n      switch (event) {\n        case \"SIGNED_OUT\":\n          console.log(\"ClientLayout: Processing SIGNED_OUT\");\n          clearCartSafely(\"User signed out\");\n          lastSessionState.current = null;\n          break;\n\n        case \"SIGNED_IN\":\n          console.log(\"ClientLayout: Processing SIGNED_IN\");\n          lastSessionState.current = session;\n          // Ici vous pourriez implémenter la logique de fusion du panier si nécessaire\n          break;\n\n        case \"INITIAL_SESSION\":\n          if (!hasCheckedInitialSession.current) {\n            console.log(\"ClientLayout: Processing INITIAL_SESSION\");\n\n            if (!session) {\n              clearCartSafely(\"Initial session - no session found\");\n            } else {\n              // Double vérification pour éviter les sessions \"fantômes\" avec gestion d'erreur\n              setTimeout(async () => {\n                try {\n                  const validatedSession = await validateSession();\n                  if (!validatedSession && session) {\n                    console.log(\"ClientLayout: Session validation failed, clearing cart\");\n                    clearCartSafely(\"Session validation failed after initial session\");\n                  }\n                } catch (error) {\n                  console.warn(\n                    \"ClientLayout: Error during delayed session validation, ignoring:\",\n                    error\n                  );\n                  // Ne pas bloquer ou vider le panier sur erreur de validation différée\n                }\n              }, 200);\n            }\n\n            lastSessionState.current = session;\n            hasCheckedInitialSession.current = true;\n          }\n          break;\n\n        case \"TOKEN_REFRESHED\":\n          if (!session && lastSessionState.current) {\n            console.log(\"ClientLayout: Token refresh failed, session expired\");\n            clearCartSafely(\"Token refresh failed - session expired\");\n          }\n          lastSessionState.current = session;\n          break;\n\n        default:\n          console.log(`ClientLayout: Unhandled auth event: ${event}`);\n      }\n    });\n\n    // Déclencher la vérification initiale\n    checkInitialSession();\n\n    return () => {\n      console.log(\"ClientLayout: Cleaning up auth state listener\");\n      subscription?.unsubscribe();\n    };\n  }, [clearCartSafely, validateSession]); // Dependencies for the main auth listener effect\n\n  return (\n    <ThemeProvider attribute=\"class\" defaultTheme=\"system\" enableSystem disableTransitionOnChange>\n      <NextIntlClientProvider locale={locale} messages={messages} timeZone={timeZone}>\n        {children}\n      </NextIntlClientProvider>\n    </ThemeProvider>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\components\\shared\\address-form.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'z' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setError' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":93,"column":51,"nodeType":null,"messageId":"unusedVar","endLine":93,"endColumn":59}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport React, { useState, useEffect, useRef, useTransition, FC } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { toast } from \"sonner\";\nimport { Loader2 } from \"lucide-react\";\nimport { z } from \"zod\";\nimport { useRouter } from \"next/navigation\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Form,\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { Checkbox } from \"@/components/ui/checkbox\";\nimport { Label } from \"@/components/ui/label\";\nimport { addAddress, updateAddress } from \"@/actions/addressActions\";\nimport { useAddressAutocomplete, BanFeature } from \"@/hooks/useAddressAutocomplete\";\nimport { useLocale, useTranslations } from \"next-intl\";\nimport { countries } from \"@/lib/countries\";\nimport type { Address } from \"@/types\";\nimport { AddressFormData, addressSchema } from \"@/lib/validators/address.validator\";\n\ninterface AddressFormProps {\n  addressType: \"shipping\" | \"billing\";\n  existingAddress?: Address | Partial<AddressFormData & { id?: string }> | null; // ✅ Support des deux types\n  onCancel?: () => void;\n  onSuccess?: () => void; // For server action success\n  onSubmit?: (data: AddressFormData) => void; // For custom checkout submission\n  isSubmitting?: boolean; // To control loading state from parent\n  // ✅ Propriétés optionnelles pour la page de profil\n  translations?: ReturnType<typeof useTranslations>;\n  locale?: string;\n  countries?: Record<string, Array<{ code: string; name: string }>>;\n}\n\nconst AddressForm: FC<AddressFormProps> = ({\n  addressType,\n  existingAddress,\n  onCancel,\n  onSuccess,\n  onSubmit: customOnSubmit,\n  isSubmitting = false,\n  // ✅ Propriétés optionnelles pour la page de profil\n  translations: externalTranslations,\n  locale: externalLocale,\n  countries: _externalCountries,\n}) => {\n  // ✅ Utiliser les traductions externes si fournies, sinon les hooks par défaut\n  const defaultT = useTranslations(\"AddressForm\");\n  const defaultLocale = useLocale();\n  const t = externalTranslations || defaultT;\n  const locale = externalLocale || defaultLocale;\n  const [isPending, startTransition] = useTransition();\n  const router = useRouter();\n  const isLoading = isSubmitting || isPending;\n  const isEditing = !!existingAddress?.id;\n  const [showAddressLine2, setShowAddressLine2] = useState(!!existingAddress?.address_line2);\n  const [isSelectingAddress, setIsSelectingAddress] = useState(false);\n  const [hasUserInteracted, setHasUserInteracted] = useState(false);\n\n  const form = useForm<AddressFormData>({\n    resolver: zodResolver(addressSchema),\n    defaultValues: {\n      address_type: addressType,\n      first_name: existingAddress?.first_name || \"\",\n      last_name: existingAddress?.last_name || \"\",\n      email: existingAddress?.email || \"\",\n      company_name: existingAddress?.company_name || \"\",\n      street_number: existingAddress?.street_number || \"\",\n      address_line1: existingAddress?.address_line1 || \"\",\n      address_line2: existingAddress?.address_line2 || \"\",\n      postal_code: existingAddress?.postal_code || \"\",\n      city: existingAddress?.city || \"\",\n      country_code: existingAddress?.country_code || \"FR\",\n      state_province_region: existingAddress?.state_province_region || \"\",\n      phone_number: existingAddress?.phone_number || \"\",\n    },\n  });\n\n  const { control, handleSubmit, watch, setValue, setError } = form;\n\n  const countryList = countries[locale.toUpperCase() as keyof typeof countries] || countries.EN;\n  const addressLine1Value = watch(\"address_line1\");\n  const streetNumberValue = watch(\"street_number\"); // 👈 Surveiller le numéro de rue existant\n  const watchedCountry = watch(\"country_code\");\n  const {\n    suggestions: addressSuggestions,\n    isLoading: isAddressLoading,\n    setSuggestions: setAddressSuggestions,\n    error: addressError,\n  } = useAddressAutocomplete(\n    isSelectingAddress || !hasUserInteracted ? \"\" : addressLine1Value,\n    watchedCountry\n  );\n  const suggestionsRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (suggestionsRef.current && !suggestionsRef.current.contains(event.target as Node)) {\n        setAddressSuggestions([]);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, [setAddressSuggestions]);\n\n  const handleSelectAddress = (address: BanFeature[\"properties\"]) => {\n    setIsSelectingAddress(true);\n\n    // 🚀 LOGIQUE AMÉLIORÉE : Préserver le numéro existant si déjà saisi\n    const currentStreetNumber = streetNumberValue?.trim();\n    let apiStreetNumber = address.housenumber?.trim();\n\n    // 🔍 Si pas de housenumber, essayer d'extraire depuis le label ou name\n    if (!apiStreetNumber && (address.label || address.name)) {\n      const labelToCheck = address.label || address.name || \"\";\n      // Regex pour extraire le numéro au début du label (ex: \"123 Rue de la Paix\")\n      const numberMatch = labelToCheck.match(/^(\\d+(?:\\s*[a-zA-Z])?)\\s+/);\n      if (numberMatch) {\n        apiStreetNumber = numberMatch[1].trim();\n      }\n    }\n\n    // Utiliser le numéro existant S'IL EXISTE, sinon utiliser celui extrait de l'API\n    const finalStreetNumber =\n      currentStreetNumber && currentStreetNumber !== \"\"\n        ? currentStreetNumber\n        : apiStreetNumber || \"\";\n\n    // ✅ S'assurer que le numéro de rue est bien défini\n    setValue(\"street_number\", finalStreetNumber, {\n      shouldValidate: true,\n      shouldDirty: true,\n    });\n\n    // 🔍 Pour address_line1, utiliser street ou name, mais retirer le numéro s'il était au début\n    let streetName = address.street || address.name || \"\";\n    if (apiStreetNumber && streetName.startsWith(apiStreetNumber)) {\n      streetName = streetName.replace(new RegExp(`^${apiStreetNumber}\\\\s+`), \"\").trim();\n    }\n\n    setValue(\"address_line1\", streetName, {\n      shouldValidate: true,\n      shouldDirty: true,\n    });\n    setValue(\"postal_code\", address.postcode, {\n      shouldValidate: true,\n      shouldDirty: true,\n    });\n    setValue(\"city\", address.city, {\n      shouldValidate: true,\n      shouldDirty: true,\n    });\n\n    // Fermer immédiatement les suggestions\n    setAddressSuggestions([]);\n    // Réactiver l'autocomplétion après un délai\n    setTimeout(() => {\n      setIsSelectingAddress(false);\n    }, 500);\n  };\n\n  const processSubmit = (data: AddressFormData) => {\n    if (customOnSubmit) {\n      customOnSubmit(data);\n      return;\n    }\n\n    startTransition(async () => {\n      const result =\n        isEditing && existingAddress?.id\n          ? await updateAddress(existingAddress.id, data, locale)\n          : await addAddress(data, locale);\n\n      if (result.success) {\n        toast.success(t(isEditing ? \"updateSuccess\" : \"addSuccess\"));\n        // Force refresh des données pour synchroniser checkout et profile\n        router.refresh();\n        onSuccess?.();\n        form.reset();\n      } else {\n        toast.error(result.error || t(\"genericError\"));\n      }\n    });\n  };\n\n  return (\n    <Form {...form}>\n      <form onSubmit={handleSubmit(processSubmit)} className=\"space-y-6\">\n        <div className=\"grid grid-cols-1 gap-4 md:grid-cols-2\">\n          <FormField\n            control={control}\n            name=\"first_name\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>{t(\"fieldLabels.first_name\")}</FormLabel>\n                <FormControl>\n                  <Input {...field} placeholder={t(\"placeholders.first_name\")} />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n          <FormField\n            control={control}\n            name=\"last_name\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>{t(\"fieldLabels.last_name\")}</FormLabel>\n                <FormControl>\n                  <Input {...field} placeholder={t(\"placeholders.last_name\")} />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n        </div>\n\n        <div className=\"grid grid-cols-1 gap-4 md:grid-cols-4\">\n          <FormField\n            control={control}\n            name=\"street_number\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>{t(\"fieldLabels.street_number\")}</FormLabel>\n                <FormControl>\n                  <Input\n                    {...field}\n                    value={field.value ?? \"\"}\n                    placeholder={t(\"placeholders.street_number\")}\n                  />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n          <FormField\n            control={control}\n            name=\"address_line1\"\n            render={({ field }) => (\n              <FormItem className=\"md:col-span-3\">\n                <div ref={suggestionsRef} className=\"relative\">\n                  <FormLabel>{t(\"fieldLabels.address_line1\")}</FormLabel>\n                  <FormControl>\n                    <Input\n                      {...field}\n                      placeholder={t(\"placeholders.address_line1\")}\n                      autoComplete=\"off\"\n                      onFocus={() => setHasUserInteracted(true)}\n                      onChange={(e) => {\n                        setHasUserInteracted(true);\n                        field.onChange(e);\n                      }}\n                    />\n                  </FormControl>\n                  <FormMessage />\n                  {isAddressLoading && (\n                    <p className=\"text-sm text-muted-foreground\">{t(\"addressLoading\")}</p>\n                  )}\n                  {addressError && <p className=\"text-sm text-red-600\">{addressError}</p>}\n                  {addressSuggestions.length > 0 && (\n                    <div className=\"absolute z-10 mt-1 w-full rounded-md border border-border bg-background shadow-lg\">\n                      {addressSuggestions.map((feature: BanFeature) => (\n                        <button\n                          key={feature.properties.id}\n                          type=\"button\"\n                          className=\"w-full p-2 text-left hover:bg-accent\"\n                          onMouseDown={(e) => {\n                            e.preventDefault(); // Empêche le mousedown de déclencher handleClickOutside\n                          }}\n                          onClick={() => handleSelectAddress(feature.properties)}\n                        >\n                          {feature.properties.label}\n                        </button>\n                      ))}\n                    </div>\n                  )}\n                </div>\n              </FormItem>\n            )}\n          />\n        </div>\n\n        <div className=\"flex items-center space-x-2\">\n          <Checkbox\n            id=\"show_address_line2_checkbox\"\n            onCheckedChange={(checked) => {\n              const isChecked = checked as boolean;\n              setShowAddressLine2(isChecked);\n              if (!isChecked) setValue(\"address_line2\", \"\", { shouldValidate: true });\n            }}\n            checked={showAddressLine2}\n          />\n          <Label htmlFor=\"show_address_line2_checkbox\" className=\"cursor-pointer\">\n            {t(\"fieldLabels.address_line2\")}\n          </Label>\n        </div>\n\n        {showAddressLine2 && (\n          <FormField\n            control={control}\n            name=\"address_line2\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>{t(\"fieldLabels.address_line2\")}</FormLabel>\n                <FormControl>\n                  <Input\n                    {...field}\n                    value={field.value ?? \"\"}\n                    placeholder={t(\"placeholders.address_line2\")}\n                  />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n        )}\n\n        <div className=\"grid grid-cols-1 gap-4 md:grid-cols-3\">\n          <FormField\n            control={control}\n            name=\"postal_code\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>{t(\"fieldLabels.postal_code\")}</FormLabel>\n                <FormControl>\n                  <Input {...field} placeholder={t(\"placeholders.postal_code\")} />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n          <FormField\n            control={control}\n            name=\"city\"\n            render={({ field }) => (\n              <FormItem className=\"md:col-span-2\">\n                <FormLabel>{t(\"fieldLabels.city\")}</FormLabel>\n                <FormControl>\n                  <Input {...field} placeholder={t(\"placeholders.city\")} />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n        </div>\n\n        <FormField\n          control={control}\n          name=\"country_code\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>{t(\"fieldLabels.country_code\")}</FormLabel>\n              <Select onValueChange={field.onChange} defaultValue={field.value}>\n                <FormControl>\n                  <SelectTrigger>\n                    <SelectValue placeholder={t(\"placeholders.country_code\")} />\n                  </SelectTrigger>\n                </FormControl>\n                <SelectContent>\n                  {countryList.map((country) => (\n                    <SelectItem key={country.code} value={country.code}>\n                      {country.name}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        <div className=\"flex items-center justify-end space-x-4\">\n          {onCancel && (\n            <Button type=\"button\" variant=\"outline\" onClick={onCancel} disabled={isLoading}>\n              {t(\"buttons.cancel\")}\n            </Button>\n          )}\n          <Button type=\"submit\" disabled={isLoading || isAddressLoading}>\n            {(isLoading || isAddressLoading) && <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />}\n            {isEditing ? t(\"buttons.save\") : t(\"buttons.save\")}\n          </Button>\n        </div>\n      </form>\n    </Form>\n  );\n};\n\nexport default AddressForm;\n","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\components\\shared\\breadcrumb.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Link' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport React from \"react\";\nimport { Link } from \"@/components/primitives\";\nimport { ChevronRight } from \"lucide-react\";\nimport { cn } from \"@/utils/cn\";\n// Pourrait utiliser usePathname pour générer les items dynamiquement\n// import { usePathname } from '@/i18n/navigation';\n// import { useTranslations } from 'next-intl';\n\nexport interface BreadcrumbItem {\n  label: React.ReactNode; // Peut être une string ou un élément traduit\n  href: string;\n}\n\ninterface BreadcrumbProps extends React.HTMLAttributes<HTMLElement> {\n  items: BreadcrumbItem[];\n  separator?: React.ReactNode;\n}\n\nconst Breadcrumb = React.forwardRef<HTMLElement, BreadcrumbProps>(\n  ({ className, items, separator = <ChevronRight className=\"h-4 w-4\" />, ...props }, ref) => {\n    // const t = useTranslations('Breadcrumb'); // Pour traduire ex: 'Home'\n\n    if (!items || items.length === 0) {\n      return null;\n    }\n\n    return (\n      <nav\n        aria-label=\"Fil d'Ariane\"\n        ref={ref}\n        className={cn(\"text-sm text-muted-foreground\", className)}\n        {...props}\n      >\n        <ol className=\"flex flex-wrap items-center gap-1.5 break-words sm:gap-2.5\">\n          {items.map((item, index) => {\n            const isLast = index === items.length - 1;\n            return (\n              <li key={index} className=\"inline-flex items-center gap-1.5\">\n                {index > 0 && (\n                  <span aria-hidden=\"true\" className=\"opacity-50\">\n                    {separator}\n                  </span>\n                )}\n                <a\n                  href={item.href}\n                  // Les éléments non actifs (sauf le dernier) sont des liens\n                  // Le dernier élément est juste du texte (ou un lien non cliquable)\n                  className={cn(\n                    \"transition-colors hover:text-foreground\",\n                    isLast && \"pointer-events-none font-medium text-foreground\"\n                  )}\n                  aria-current={isLast ? \"page\" : undefined}\n                >\n                  {item.label}\n                </a>\n              </li>\n            );\n          })}\n        </ol>\n      </nav>\n    );\n  }\n);\n\nBreadcrumb.displayName = \"Breadcrumb\";\n\nexport { Breadcrumb };\n","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\components\\shared\\image-upload-field.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'t' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":34,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport { Control, FieldValues, Path } from \"react-hook-form\";\nimport { FormControl, FormField, FormItem, FormLabel, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { useState } from \"react\";\nimport { toast } from \"sonner\";\nimport { useTranslations } from \"next-intl\";\nimport { Upload, Link2, X, Loader2 } from \"lucide-react\";\nimport type { UploadImageResult } from \"@/lib/storage/image-upload\";\n\ninterface ImageUploadFieldProps<T extends FieldValues> {\n  control: Control<T>;\n  name: Path<T>;\n  label?: string;\n  description?: string;\n  placeholder?: string;\n  required?: boolean;\n  uploadFunction: (formData: FormData) => Promise<UploadImageResult>;\n  translationKey?: string;\n}\n\nexport function ImageUploadField<T extends FieldValues>({\n  control,\n  name,\n  label,\n  description,\n  placeholder = \"https://exemple.com/image.jpg\",\n  required = false,\n  uploadFunction,\n  translationKey = \"Common\",\n}: ImageUploadFieldProps<T>) {\n  const t = useTranslations(translationKey);\n  const [isUploading, setIsUploading] = useState(false);\n\n  const handleImageUpload = async (file: File, onChange: (url: string) => void) => {\n    setIsUploading(true);\n    try {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"fileName\", file.name.split(\".\")[0]);\n\n      const result = await uploadFunction(formData);\n\n      if (result.success) {\n        onChange(result.data.url);\n        toast.success(result.message);\n      } else {\n        toast.error(result.message);\n      }\n    } catch (error) {\n      console.error(\"Upload error:\", error);\n      toast.error(\"Erreur lors du téléversement de l'image\");\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  return (\n    <FormField\n      control={control}\n      name={name}\n      render={({ field }) => (\n        <FormItem>\n          <FormLabel className=\"flex items-center gap-2\">\n            <Link2 className=\"h-4 w-4\" />\n            {label || \"Image\"}\n            {required && <span className=\"text-red-500\">*</span>}\n          </FormLabel>\n          <FormControl>\n            <div className=\"space-y-4\">\n              {/* URL Input */}\n              <div className=\"flex gap-2\">\n                <Input\n                  type=\"url\"\n                  placeholder={placeholder}\n                  value={field.value || \"\"}\n                  onChange={(e) => field.onChange(e.target.value || \"\")}\n                  className=\"flex-1\"\n                />\n                {field.value && (\n                  <Button\n                    type=\"button\"\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => field.onChange(\"\")}\n                    className=\"px-3\"\n                  >\n                    <X className=\"h-4 w-4\" />\n                  </Button>\n                )}\n              </div>\n\n              {/* File Upload */}\n              <div className=\"flex items-center gap-2\">\n                <div className=\"flex-1\">\n                  <Input\n                    type=\"file\"\n                    accept=\"image/*\"\n                    onChange={(e) => {\n                      const file = e.target.files?.[0];\n                      if (file) {\n                        handleImageUpload(file, field.onChange);\n                      }\n                    }}\n                    disabled={isUploading}\n                    className=\"hover:file:bg-primary/90 file:mr-4 file:rounded-md file:border-0 file:bg-primary file:px-4 file:py-2 file:text-sm file:font-medium file:text-primary-foreground\"\n                  />\n                </div>\n                <Button\n                  type=\"button\"\n                  variant=\"outline\"\n                  size=\"sm\"\n                  disabled={isUploading}\n                  className=\"shrink-0\"\n                >\n                  {isUploading ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                      Téléversement...\n                    </>\n                  ) : (\n                    <>\n                      <Upload className=\"mr-2 h-4 w-4\" />\n                      Téléverser\n                    </>\n                  )}\n                </Button>\n              </div>\n\n              {/* Image Preview */}\n              {field.value && (\n                <div className=\"mt-4\">\n                  <div className=\"group relative inline-block\">\n                    <img\n                      src={field.value}\n                      alt=\"Aperçu de l'image\"\n                      className=\"h-48 w-auto rounded-lg border border-border object-cover shadow-sm\"\n                      onError={() => {\n                        console.error(\"Erreur de chargement de l'image:\", field.value);\n                        toast.error(\"Impossible de charger l'image\");\n                      }}\n                    />\n                    <div className=\"absolute inset-0 flex items-center justify-center rounded-lg bg-black/0 opacity-0 transition-colors group-hover:bg-black/20 group-hover:opacity-100\">\n                      <Button\n                        type=\"button\"\n                        variant=\"destructive\"\n                        size=\"sm\"\n                        onClick={() => field.onChange(\"\")}\n                        className=\"opacity-90\"\n                      >\n                        <X className=\"mr-1 h-4 w-4\" />\n                        Supprimer\n                      </Button>\n                    </div>\n                  </div>\n                  <p className=\"mt-2 text-xs text-muted-foreground\">\n                    Formats supportés: JPEG, PNG, WebP, GIF (max 4Mo)\n                  </p>\n                </div>\n              )}\n            </div>\n          </FormControl>\n          {description && <p className=\"text-sm text-muted-foreground\">{description}</p>}\n          <FormMessage />\n        </FormItem>\n      )}\n    />\n  );\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\core\\errors.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":234,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5272,5275],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5272,5275],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":249,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":249,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5600,5603],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5600,5603],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Application-specific error types and utilities\n */\n\nexport abstract class AppError extends Error {\n  abstract readonly code: string;\n  abstract readonly statusCode: number;\n  \n  constructor(\n    message: string,\n    public readonly context?: Record<string, unknown>\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n\n/**\n * Validation errors\n */\nexport class ValidationError extends AppError {\n  readonly code = 'VALIDATION_ERROR';\n  readonly statusCode = 400;\n\n  constructor(\n    message: string,\n    public readonly field?: string,\n    context?: Record<string, unknown>\n  ) {\n    super(message, context);\n  }\n}\n\n/**\n * Authorization errors\n */\nexport class AuthorizationError extends AppError {\n  readonly code = 'AUTHORIZATION_ERROR';\n  readonly statusCode = 403;\n\n  constructor(\n    message: string = 'Accès non autorisé',\n    context?: Record<string, unknown>\n  ) {\n    super(message, context);\n  }\n}\n\n/**\n * Authentication errors\n */\nexport class AuthenticationError extends AppError {\n  readonly code = 'AUTHENTICATION_ERROR';\n  readonly statusCode = 401;\n\n  constructor(\n    message: string = 'Authentification requise',\n    context?: Record<string, unknown>\n  ) {\n    super(message, context);\n  }\n}\n\n/**\n * Resource not found errors\n */\nexport class NotFoundError extends AppError {\n  readonly code = 'NOT_FOUND_ERROR';\n  readonly statusCode = 404;\n\n  constructor(\n    resource: string,\n    identifier?: string,\n    context?: Record<string, unknown>\n  ) {\n    const message = identifier \n      ? `${resource} avec l'identifiant \"${identifier}\" introuvable`\n      : `${resource} introuvable`;\n    super(message, context);\n  }\n}\n\n/**\n * Business logic errors\n */\nexport class BusinessError extends AppError {\n  readonly code = 'BUSINESS_ERROR';\n  readonly statusCode = 422;\n\n  constructor(\n    message: string,\n    context?: Record<string, unknown>\n  ) {\n    super(message, context);\n  }\n}\n\n/**\n * Database operation errors\n */\nexport class DatabaseError extends AppError {\n  readonly code = 'DATABASE_ERROR';\n  readonly statusCode = 500;\n\n  constructor(\n    message: string,\n    public readonly originalError?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(message, context);\n  }\n}\n\n/**\n * External service errors\n */\nexport class ExternalServiceError extends AppError {\n  readonly code = 'EXTERNAL_SERVICE_ERROR';\n  readonly statusCode = 502;\n\n  constructor(\n    service: string,\n    message: string,\n    public readonly originalError?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(`Erreur du service ${service}: ${message}`, context);\n  }\n}\n\n/**\n * Rate limiting errors\n */\nexport class RateLimitError extends AppError {\n  readonly code = 'RATE_LIMIT_ERROR';\n  readonly statusCode = 429;\n\n  constructor(\n    message: string = 'Trop de requêtes, veuillez réessayer plus tard',\n    context?: Record<string, unknown>\n  ) {\n    super(message, context);\n  }\n}\n\n/**\n * Error type guards\n */\nexport const ErrorGuards = {\n  isAppError: (error: unknown): error is AppError => {\n    return error instanceof AppError;\n  },\n  \n  isValidationError: (error: unknown): error is ValidationError => {\n    return error instanceof ValidationError;\n  },\n  \n  isAuthorizationError: (error: unknown): error is AuthorizationError => {\n    return error instanceof AuthorizationError;\n  },\n  \n  isAuthenticationError: (error: unknown): error is AuthenticationError => {\n    return error instanceof AuthenticationError;\n  },\n  \n  isNotFoundError: (error: unknown): error is NotFoundError => {\n    return error instanceof NotFoundError;\n  },\n  \n  isBusinessError: (error: unknown): error is BusinessError => {\n    return error instanceof BusinessError;\n  },\n  \n  isDatabaseError: (error: unknown): error is DatabaseError => {\n    return error instanceof DatabaseError;\n  },\n  \n  isExternalServiceError: (error: unknown): error is ExternalServiceError => {\n    return error instanceof ExternalServiceError;\n  }\n};\n\n/**\n * Error utilities\n */\nexport const ErrorUtils = {\n  /**\n   * Checks if error is an application error\n   */\n  isAppError: (error: unknown): error is AppError => {\n    return error instanceof AppError;\n  },\n\n  /**\n   * Converts unknown error to AppError\n   */\n  toAppError: (error: unknown): AppError => {\n    if (ErrorGuards.isAppError(error)) {\n      return error;\n    }\n    \n    if (error instanceof Error) {\n      return new DatabaseError(error.message, error);\n    }\n    \n    return new DatabaseError('Erreur inconnue', error);\n  },\n\n  /**\n   * Formats error for user display\n   */\n  formatForUser: (error: AppError): string => {\n    switch (error.code) {\n      case 'VALIDATION_ERROR':\n        return error.message;\n      case 'AUTHORIZATION_ERROR':\n        return 'Vous n\\'avez pas les permissions nécessaires pour cette action';\n      case 'AUTHENTICATION_ERROR':\n        return 'Veuillez vous connecter pour continuer';\n      case 'NOT_FOUND_ERROR':\n        return error.message;\n      case 'BUSINESS_ERROR':\n        return error.message;\n      case 'RATE_LIMIT_ERROR':\n        return error.message;\n      default:\n        return 'Une erreur technique s\\'est produite. Veuillez réessayer.';\n    }\n  },\n\n  /**\n   * Formats error for logging\n   */\n  formatForLogging: (error: AppError): Record<string, any> => {\n    return {\n      name: error.name,\n      code: error.code,\n      message: error.message,\n      statusCode: error.statusCode,\n      context: error.context,\n      stack: error.stack,\n      timestamp: new Date().toISOString()\n    };\n  },\n\n  /**\n   * Creates error from Supabase error\n   */\n  fromSupabaseError: (error: any): AppError => {\n    if (!error) {\n      return new DatabaseError('Erreur de base de données inconnue');\n    }\n\n    const code = error.code;\n    const message = error.message || 'Erreur de base de données';\n\n    switch (code) {\n      case '23505': // unique_violation\n        return new BusinessError('Cette ressource existe déjà');\n      case '23503': // foreign_key_violation\n        return new BusinessError('Référence invalide détectée');\n      case '42501': // insufficient_privilege\n        return new AuthorizationError('Permissions insuffisantes');\n      case 'PGRST116': // Row not found\n        return new NotFoundError('Ressource');\n      default:\n        return new DatabaseError(message, error);\n    }\n  }\n};","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\core\\events.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":326,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":326,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8854,8857],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8854,8857],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":327,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":327,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8930,8933],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8930,8933],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":328,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":328,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9010,9013],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9010,9013],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":329,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":329,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9094,9097],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9094,9097],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":330,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":330,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9170,9173],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9170,9173],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":331,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":331,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9250,9253],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9250,9253],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":342,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":342,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9646,9649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9646,9649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Core Event System\n * \n * Provides the foundation for Domain-Driven Design event architecture\n * with type-safe event handling and persistence.\n */\n\nimport { Result } from './result';\n\n/**\n * Base interface for all domain events\n */\nexport interface DomainEvent<T = unknown> {\n  readonly eventId: string;\n  readonly eventType: string;\n  readonly aggregateId: string;\n  readonly aggregateType: string;\n  readonly eventData: T;\n  readonly occurredAt: Date;\n  readonly version: number;\n  readonly userId?: string;\n  readonly correlationId?: string;\n  readonly causationId?: string;\n}\n\n/**\n * Event handler interface\n */\nexport interface EventHandler<T extends DomainEvent = DomainEvent> {\n  readonly eventType: string;\n  handle(event: T): Promise<Result<void, Error>>;\n}\n\n/**\n * Event publisher interface\n */\nexport interface EventPublisher {\n  publish<T extends DomainEvent>(event: T): Promise<Result<void, Error>>;\n  publishBatch<T extends DomainEvent>(events: T[]): Promise<Result<void, Error>>;\n}\n\n/**\n * Event store interface for persistence\n */\nexport interface EventStore {\n  append<T extends DomainEvent>(event: T): Promise<Result<void, Error>>;\n  appendBatch<T extends DomainEvent>(events: T[]): Promise<Result<void, Error>>;\n  getEvents(aggregateId: string, fromVersion?: number): Promise<Result<DomainEvent[], Error>>;\n  getEventsByType(eventType: string, options?: { fromDate?: Date; limit?: number }): Promise<Result<DomainEvent[], Error>>;\n  getAllEvents(fromDate?: Date, limit?: number): Promise<Result<DomainEvent[], Error>>;\n}\n\n/**\n * Event bus interface for coordinating publishers and handlers\n */\nexport interface EventBus {\n  subscribe(eventType: string, handler: (event: DomainEvent) => Promise<void>): Promise<void>;\n  unsubscribe(eventType: string, handler: (event: DomainEvent) => Promise<void>): Promise<void>;\n  publish<T extends DomainEvent>(event: T): Promise<Result<void, Error>>;\n  publishBatch<T extends DomainEvent>(events: T[]): Promise<Result<void, Error>>;\n  getSubscribedHandlers(eventType: string): ((event: DomainEvent) => Promise<void>)[];\n}\n\n/**\n * Abstract base class for domain events\n */\nexport abstract class BaseDomainEvent<T = unknown> implements DomainEvent<T> {\n  public readonly eventId: string;\n  public readonly occurredAt: Date;\n  public readonly version: number;\n  \n  constructor(\n    public readonly eventType: string,\n    public readonly aggregateId: string,\n    public readonly aggregateType: string,\n    public readonly eventData: T,\n    public readonly userId?: string,\n    public readonly correlationId?: string,\n    public readonly causationId?: string,\n    version: number = 1\n  ) {\n    this.eventId = `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    this.occurredAt = new Date();\n    this.version = version;\n  }\n}\n\n/**\n * Event metadata for enriching events\n */\nexport interface EventMetadata {\n  userId?: string;\n  correlationId?: string;\n  causationId?: string;\n  source?: string;\n  requestId?: string;\n  ipAddress?: string;\n  userAgent?: string;\n}\n\n/**\n * Event envelope for wrapping events with metadata\n */\nexport interface EventEnvelope<T extends DomainEvent = DomainEvent> {\n  event: T;\n  metadata: EventMetadata;\n  retryCount: number;\n  maxRetries: number;\n  createdAt: Date;\n  processedAt?: Date;\n  failedAt?: Date;\n  error?: string;\n}\n\n/**\n * Event processing result\n */\nexport interface EventProcessingResult {\n  success: boolean;\n  eventId: string;\n  eventType: string;\n  processedAt: Date;\n  error?: string;\n  retryCount: number;\n}\n\n/**\n * Event processor interface for handling event processing workflows\n */\nexport interface EventProcessor {\n  process<T extends DomainEvent>(envelope: EventEnvelope<T>): Promise<EventProcessingResult>;\n  processAsync<T extends DomainEvent>(envelope: EventEnvelope<T>): Promise<void>;\n  getProcessingStats(): Promise<{\n    totalEvents: number;\n    successfulEvents: number;\n    failedEvents: number;\n    retryingEvents: number;\n  }>;\n}\n\n/**\n * Event serialization interface\n */\nexport interface EventSerializer {\n  serialize<T extends DomainEvent>(event: T): string;\n  deserialize<T extends DomainEvent>(serializedEvent: string): T;\n}\n\n/**\n * JSON event serializer implementation\n */\nexport class JsonEventSerializer implements EventSerializer {\n  serialize<T extends DomainEvent>(event: T): string {\n    try {\n      return JSON.stringify({\n        eventId: event.eventId,\n        eventType: event.eventType,\n        aggregateId: event.aggregateId,\n        aggregateType: event.aggregateType,\n        eventData: event.eventData,\n        occurredAt: event.occurredAt.toISOString(),\n        version: event.version,\n        userId: event.userId,\n        correlationId: event.correlationId,\n        causationId: event.causationId,\n      });\n    } catch (error) {\n      throw new Error(`Failed to serialize event: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  deserialize<T extends DomainEvent>(serializedEvent: string): T {\n    try {\n      const parsed = JSON.parse(serializedEvent);\n      return {\n        ...parsed,\n        occurredAt: new Date(parsed.occurredAt),\n      } as T;\n    } catch (error) {\n      throw new Error(`Failed to deserialize event: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n}\n\n/**\n * Event factory for creating events with proper metadata\n */\nexport class EventFactory {\n  constructor(\n    private readonly serializer: EventSerializer = new JsonEventSerializer()\n  ) {}\n\n  static create<T>(\n    eventType: string,\n    aggregateId: string,\n    aggregateType: string,\n    eventData: T,\n    metadata?: EventMetadata\n  ): DomainEvent<T> {\n    return new (class extends BaseDomainEvent<T> {\n      constructor() {\n        super(\n          eventType,\n          aggregateId,\n          aggregateType,\n          eventData,\n          metadata?.userId,\n          metadata?.correlationId,\n          metadata?.causationId\n        );\n      }\n    })();\n  }\n\n  createEnvelope<T extends DomainEvent>(\n    event: T,\n    metadata: EventMetadata,\n    maxRetries: number = 3\n  ): EventEnvelope<T> {\n    return {\n      event,\n      metadata,\n      retryCount: 0,\n      maxRetries,\n      createdAt: new Date(),\n    };\n  }\n}\n\n/**\n * Event type definitions for the application\n */\nexport const EventTypes = {\n  // Cart Events\n  CART_ITEM_ADDED: 'cart.item.added',\n  CART_ITEM_REMOVED: 'cart.item.removed',\n  CART_ITEM_QUANTITY_UPDATED: 'cart.item.quantity.updated',\n  CART_CLEARED: 'cart.cleared',\n  CART_ABANDONED: 'cart.abandoned',\n\n  // Order Events\n  ORDER_CREATED: 'order.created',\n  ORDER_PAID: 'order.paid',\n  ORDER_CONFIRMED: 'order.confirmed',\n  ORDER_SHIPPED: 'order.shipped',\n  ORDER_DELIVERED: 'order.delivered',\n  ORDER_CANCELLED: 'order.cancelled',\n  ORDER_REFUNDED: 'order.refunded',\n\n  // Product Events\n  PRODUCT_CREATED: 'product.created',\n  PRODUCT_UPDATED: 'product.updated',\n  PRODUCT_STOCK_UPDATED: 'product.stock.updated',\n  PRODUCT_PRICE_CHANGED: 'product.price.changed',\n  PRODUCT_ACTIVATED: 'product.activated',\n  PRODUCT_DEACTIVATED: 'product.deactivated',\n\n  // User Events\n  USER_REGISTERED: 'user.registered',\n  USER_EMAIL_VERIFIED: 'user.email.verified',\n  USER_PROFILE_UPDATED: 'user.profile.updated',\n  USER_ROLE_CHANGED: 'user.role.changed',\n  USER_DEACTIVATED: 'user.deactivated',\n\n  // Address Events\n  ADDRESS_CREATED: 'address.created',\n  ADDRESS_UPDATED: 'address.updated',\n  ADDRESS_DELETED: 'address.deleted',\n\n  // Magazine Events\n  ARTICLE_PUBLISHED: 'article.published',\n  ARTICLE_UPDATED: 'article.updated',\n  ARTICLE_UNPUBLISHED: 'article.unpublished',\n\n  // Payment Events\n  PAYMENT_INITIATED: 'payment.initiated',\n  PAYMENT_COMPLETED: 'payment.completed',\n  PAYMENT_FAILED: 'payment.failed',\n  PAYMENT_REFUNDED: 'payment.refunded',\n\n  // System Events\n  SYSTEM_STARTUP: 'system.startup',\n  SYSTEM_SHUTDOWN: 'system.shutdown',\n  SYSTEM_ERROR: 'system.error',\n} as const;\n\nexport type EventType = typeof EventTypes[keyof typeof EventTypes];\n\n/**\n * Event correlation utilities\n */\nexport class EventCorrelation {\n  private static correlationIdCounter = 0;\n\n  static generateCorrelationId(): string {\n    return `corr_${Date.now()}_${++this.correlationIdCounter}`;\n  }\n\n  static generateCausationId(): string {\n    return `cause_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  static createMetadata(\n    userId?: string,\n    source?: string,\n    requestId?: string\n  ): EventMetadata {\n    return {\n      userId,\n      correlationId: this.generateCorrelationId(),\n      causationId: this.generateCausationId(),\n      source,\n      requestId,\n    };\n  }\n}\n\n/**\n * Event validation utilities\n */\nexport class EventValidation {\n  static isValidEvent(event: unknown): event is DomainEvent {\n    return (\n      typeof event === 'object' &&\n      event !== null &&\n      'eventId' in event && typeof (event as any).eventId === 'string' &&\n      'eventType' in event && typeof (event as any).eventType === 'string' &&\n      'aggregateId' in event && typeof (event as any).aggregateId === 'string' &&\n      'aggregateType' in event && typeof (event as any).aggregateType === 'string' &&\n      'occurredAt' in event && (event as any).occurredAt instanceof Date &&\n      'version' in event && typeof (event as any).version === 'number'\n    );\n  }\n\n  static validateEventType(eventType: string): boolean {\n    return Object.values(EventTypes).includes(eventType as EventType);\n  }\n\n  static sanitizeEventData(eventData: unknown): unknown {\n    // Remove sensitive data and perform basic sanitization\n    if (typeof eventData === 'object' && eventData !== null) {\n      const sanitized = { ...eventData } as any;\n      \n      // Remove common sensitive fields\n      delete sanitized.password;\n      delete sanitized.token;\n      delete sanitized.secret;\n      delete sanitized.creditCard;\n      delete sanitized.ssn;\n      \n      return sanitized;\n    }\n    \n    return eventData;\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\core\\logger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[203,206],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[203,206],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1365,1368],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1365,1368],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":154,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4177,4180],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4177,4180],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":219,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5690,5693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5690,5693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":232,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5931,5934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5931,5934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Structured logging system\n */\n\nexport interface LogContext {\n  userId?: string;\n  requestId?: string;\n  action?: string;\n  resource?: string;\n  ip?: string;\n  userAgent?: string;\n  [key: string]: any;\n}\n\nexport interface LogEntry {\n  level: 'debug' | 'info' | 'warn' | 'error';\n  message: string;\n  timestamp: string;\n  context?: LogContext;\n  error?: {\n    name: string;\n    message: string;\n    stack?: string;\n    code?: string;\n  };\n}\n\nexport interface Logger {\n  debug(message: string, context?: LogContext): void;\n  info(message: string, context?: LogContext): void;\n  warn(message: string, context?: LogContext): void;\n  error(message: string, error?: Error | unknown, context?: LogContext): void;\n}\n\nclass ConsoleLogger implements Logger {\n  private formatLogEntry(entry: LogEntry): string {\n    return JSON.stringify(entry, null, process.env.NODE_ENV === 'development' ? 2 : 0);\n  }\n\n  private createLogEntry(\n    level: LogEntry['level'],\n    message: string,\n    context?: LogContext,\n    error?: Error | unknown\n  ): LogEntry {\n    const entry: LogEntry = {\n      level,\n      message,\n      timestamp: new Date().toISOString(),\n      context\n    };\n\n    if (error) {\n      if (error instanceof Error) {\n        entry.error = {\n          name: error.name,\n          message: error.message,\n          stack: error.stack,\n          code: (error as any).code\n        };\n      } else {\n        entry.error = {\n          name: 'UnknownError',\n          message: String(error)\n        };\n      }\n    }\n\n    return entry;\n  }\n\n  debug(message: string, context?: LogContext): void {\n    if (process.env.NODE_ENV === 'development') {\n      const entry = this.createLogEntry('debug', message, context);\n      console.debug(this.formatLogEntry(entry));\n    }\n  }\n\n  info(message: string, context?: LogContext): void {\n    const entry = this.createLogEntry('info', message, context);\n    console.info(this.formatLogEntry(entry));\n  }\n\n  warn(message: string, context?: LogContext): void {\n    const entry = this.createLogEntry('warn', message, context);\n    console.warn(this.formatLogEntry(entry));\n  }\n\n  error(message: string, error?: Error | unknown, context?: LogContext): void {\n    const entry = this.createLogEntry('error', message, context, error);\n    console.error(this.formatLogEntry(entry));\n  }\n}\n\nclass DatabaseLogger implements Logger {\n  constructor(private fallbackLogger: Logger) {}\n\n  private async persistToDatabase(entry: LogEntry): Promise<void> {\n    try {\n      // Implementation will be added when we have the database service layer\n      // For now, we'll use the fallback logger\n      this.fallbackLogger.error('Database logging not implemented yet', undefined, {\n        originalEntry: entry\n      });\n    } catch (error) {\n      this.fallbackLogger.error('Failed to persist log to database', error);\n    }\n  }\n\n  debug(message: string, context?: LogContext): void {\n    this.fallbackLogger.debug(message, context);\n  }\n\n  info(message: string, context?: LogContext): void {\n    this.fallbackLogger.info(message, context);\n    // Don't persist info logs to database to avoid noise\n  }\n\n  warn(message: string, context?: LogContext): void {\n    this.fallbackLogger.warn(message, context);\n    const entry = this.createLogEntry('warn', message, context);\n    this.persistToDatabase(entry).catch(() => {\n      // Already handled in persistToDatabase\n    });\n  }\n\n  error(message: string, error?: Error | unknown, context?: LogContext): void {\n    this.fallbackLogger.error(message, error, context);\n    const entry = this.createLogEntry('error', message, context, error);\n    this.persistToDatabase(entry).catch(() => {\n      // Already handled in persistToDatabase\n    });\n  }\n\n  private createLogEntry(\n    level: LogEntry['level'],\n    message: string,\n    context?: LogContext,\n    error?: Error | unknown\n  ): LogEntry {\n    const entry: LogEntry = {\n      level,\n      message,\n      timestamp: new Date().toISOString(),\n      context\n    };\n\n    if (error) {\n      if (error instanceof Error) {\n        entry.error = {\n          name: error.name,\n          message: error.message,\n          stack: error.stack,\n          code: (error as any).code\n        };\n      } else {\n        entry.error = {\n          name: 'UnknownError',\n          message: String(error)\n        };\n      }\n    }\n\n    return entry;\n  }\n}\n\n// Singleton logger instance\nlet loggerInstance: Logger | null = null;\n\nexport function createLogger(): Logger {\n  if (!loggerInstance) {\n    const consoleLogger = new ConsoleLogger();\n    \n    if (process.env.NODE_ENV === 'production') {\n      loggerInstance = new DatabaseLogger(consoleLogger);\n    } else {\n      loggerInstance = consoleLogger;\n    }\n  }\n  \n  return loggerInstance;\n}\n\nexport const logger = createLogger();\n\n/**\n * Utility functions for common logging patterns\n */\nexport const LogUtils = {\n  /**\n   * Logs the start of an operation\n   */\n  logOperationStart: (operation: string, context?: LogContext) => {\n    logger.info(`Starting ${operation}`, { ...context, operation });\n  },\n\n  /**\n   * Logs the success of an operation\n   */\n  logOperationSuccess: (operation: string, context?: LogContext) => {\n    logger.info(`Successfully completed ${operation}`, { ...context, operation });\n  },\n\n  /**\n   * Logs the failure of an operation\n   */\n  logOperationError: (operation: string, error: Error | unknown, context?: LogContext) => {\n    logger.error(`Failed to complete ${operation}`, error, { ...context, operation });\n  },\n\n  /**\n   * Creates a context object for a user action\n   */\n  createUserActionContext: (\n    userId: string,\n    action: string,\n    resource?: string,\n    additionalContext?: Record<string, any>\n  ): LogContext => ({\n    userId,\n    action,\n    resource,\n    ...additionalContext\n  }),\n\n  /**\n   * Creates a context object from a request\n   */\n  createRequestContext: (\n    request: Request,\n    additionalContext?: Record<string, any>\n  ): LogContext => ({\n    requestId: crypto.randomUUID(),\n    ip: request.headers.get('x-forwarded-for') || 'unknown',\n    userAgent: request.headers.get('user-agent') || 'unknown',\n    method: request.method,\n    url: request.url,\n    ...additionalContext\n  })\n};","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\core\\result.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":313,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":313,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6470,6473],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6470,6473],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":324,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":324,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6784,6787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6784,6787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Result Pattern implementation for robust error handling\n * Provides type-safe error handling without exceptions\n */\n\nexport abstract class Result<T, E = Error> {\n  protected constructor(\n    protected readonly _value?: T,\n    protected readonly _error?: E\n  ) {}\n\n  /**\n   * Creates a successful result\n   */\n  static ok<T, E = Error>(value: T): Result<T, E> {\n    return new Success<T, E>(value);\n  }\n\n  /**\n   * Creates an error result\n   */\n  static error<T, E = Error>(error: E): Result<T, E> {\n    return new Failure<T, E>(error);\n  }\n\n  /**\n   * Creates a successful result (alias for ok)\n   */\n  static success<T, E = Error>(value: T): Result<T, E> {\n    return new Success<T, E>(value);\n  }\n\n  /**\n   * Creates a failure result (alias for error)\n   */\n  static failure<T, E = Error>(error: E): Result<T, E> {\n    return new Failure<T, E>(error);\n  }\n\n  /**\n   * Creates a result from a function that might throw\n   */\n  static from<T, E = Error>(fn: () => T): Result<T, E> {\n    try {\n      return Result.ok(fn());\n    } catch (error) {\n      return Result.error(error as E);\n    }\n  }\n\n  /**\n   * Creates a result from an async function that might throw\n   */\n  static async fromAsync<T, E = Error>(fn: () => Promise<T>): Promise<Result<T, E>> {\n    try {\n      const value = await fn();\n      return Result.ok(value);\n    } catch (error) {\n      return Result.error(error as E);\n    }\n  }\n\n  /**\n   * Checks if the result is successful\n   */\n  abstract isSuccess(): boolean;\n\n  /**\n   * Checks if the result is an error\n   */\n  abstract isError(): boolean;\n\n  /**\n   * Gets the value if successful, throws if error\n   */\n  abstract getValue(): T;\n\n  /**\n   * Gets the error if failed, throws if success\n   */\n  abstract getError(): E;\n\n  /**\n   * Gets the value if successful, returns undefined if error\n   */\n  abstract getValueOrUndefined(): T | undefined;\n\n  /**\n   * Gets the value if successful, returns the provided default if error\n   */\n  abstract getValueOr(defaultValue: T): T;\n\n  /**\n   * Pattern matching for result handling\n   */\n  abstract match<U>(\n    onSuccess: (value: T) => U,\n    onError: (error: E) => U\n  ): U;\n\n  /**\n   * Maps the success value to a new type\n   */\n  abstract map<U>(fn: (value: T) => U): Result<U, E>;\n\n  /**\n   * Maps the error to a new type\n   */\n  abstract mapError<F>(fn: (error: E) => F): Result<T, F>;\n\n  /**\n   * Chains operations that return Results\n   */\n  abstract flatMap<U>(fn: (value: T) => Result<U, E>): Result<U, E>;\n\n  /**\n   * Applies a side effect if successful\n   */\n  abstract tap(fn: (value: T) => void): Result<T, E>;\n\n  /**\n   * Applies a side effect if error\n   */\n  abstract tapError(fn: (error: E) => void): Result<T, E>;\n}\n\nclass Success<T, E> extends Result<T, E> {\n  constructor(value: T) {\n    super(value, undefined);\n  }\n\n  isSuccess(): boolean {\n    return true;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  getValue(): T {\n    return this._value!;\n  }\n\n  getError(): E {\n    throw new Error('Cannot get error from successful result');\n  }\n\n  getValueOrUndefined(): T {\n    return this._value!;\n  }\n\n  getValueOr(_defaultValue: T): T {\n    return this._value!;\n  }\n\n  match<U>(onSuccess: (value: T) => U, _onError: (error: E) => U): U {\n    return onSuccess(this._value!);\n  }\n\n  map<U>(fn: (value: T) => U): Result<U, E> {\n    return Result.ok(fn(this._value!));\n  }\n\n  mapError<F>(_fn: (error: E) => F): Result<T, F> {\n    return Result.ok(this._value!);\n  }\n\n  flatMap<U>(fn: (value: T) => Result<U, E>): Result<U, E> {\n    return fn(this._value!);\n  }\n\n  tap(fn: (value: T) => void): Result<T, E> {\n    fn(this._value!);\n    return this;\n  }\n\n  tapError(_fn: (error: E) => void): Result<T, E> {\n    return this;\n  }\n}\n\nclass Failure<T, E> extends Result<T, E> {\n  constructor(error: E) {\n    super(undefined, error);\n  }\n\n  isSuccess(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return true;\n  }\n\n  getValue(): T {\n    throw new Error('Cannot get value from error result');\n  }\n\n  getError(): E {\n    return this._error!;\n  }\n\n  getValueOrUndefined(): T | undefined {\n    return undefined;\n  }\n\n  getValueOr(defaultValue: T): T {\n    return defaultValue;\n  }\n\n  match<U>(_onSuccess: (value: T) => U, onError: (error: E) => U): U {\n    return onError(this._error!);\n  }\n\n  map<U>(_fn: (value: T) => U): Result<U, E> {\n    return Result.error(this._error!);\n  }\n\n  mapError<F>(fn: (error: E) => F): Result<T, F> {\n    return Result.error(fn(this._error!));\n  }\n\n  flatMap<U>(_fn: (value: T) => Result<U, E>): Result<U, E> {\n    return Result.error(this._error!);\n  }\n\n  tap(_fn: (value: T) => void): Result<T, E> {\n    return this;\n  }\n\n  tapError(fn: (error: E) => void): Result<T, E> {\n    fn(this._error!);\n    return this;\n  }\n}\n\n/**\n * Utility type for action results\n */\n/**\n * Server Action Result interface for consistent returns\n */\nexport interface ServerActionResult<T> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  message?: string;\n}\n\n/**\n * Form Action Result interface with field validation support\n */\nexport interface FormActionResult<T> extends ServerActionResult<T> {\n  fieldErrors?: Record<string, string[]>;\n}\n\nexport type ActionResult<T> = ServerActionResult<T>;\n\n/**\n * Helper functions for action results\n */\nexport const ActionResult = {\n  ok: <T>(value: T, message?: string): ActionResult<T> => ({\n    success: true,\n    data: value,\n    message\n  }),\n  \n  error: <T>(error: string): ActionResult<T> => ({\n    success: false,\n    error\n  }),\n  \n  fromResult: <T>(result: Result<T, unknown>, successMessage?: string): ActionResult<T> => {\n    return result.match(\n      (value) => ActionResult.ok(value, successMessage),\n      (error) => ActionResult.error(\n        error instanceof Error ? error.message : String(error)\n      )\n    );\n  }\n};\n\n/**\n * Helper functions for form action results\n */\nexport const FormActionResult = {\n  ok: <T>(value: T, message?: string): FormActionResult<T> => ({\n    success: true,\n    data: value,\n    message\n  }),\n  \n  error: <T>(error: string, fieldErrors?: Record<string, string[]>): FormActionResult<T> => ({\n    success: false,\n    error,\n    fieldErrors\n  }),\n  \n  fieldValidationError: <T>(fieldErrors: Record<string, string[]>): FormActionResult<T> => ({\n    success: false,\n    error: \"Validation errors occurred\",\n    fieldErrors\n  })\n};\n\n/**\n * Utility type for database operation results\n */\nexport interface DatabaseError {\n  code: string;\n  message: string;\n  details?: any;\n}\n\nexport type DatabaseResult<T> = Result<T, DatabaseError>;\n\n/**\n * Helper to create database results\n */\nexport const DatabaseResult = {\n  ok: <T>(value: T): DatabaseResult<T> => Result.ok(value),\n  error: <T>(error: DatabaseError): DatabaseResult<T> => Result.error(error),\n  fromSupabaseError: <T>(error: any): DatabaseResult<T> => {\n    return Result.error({\n      code: error.code || 'UNKNOWN',\n      message: error.message || 'Unknown database error',\n      details: error.details\n    });\n  }\n};","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\domain\\interfaces\\repository.interface.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2826,2829],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2826,2829],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":128,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2872,2875],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2872,2875],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":129,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2915,2918],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2915,2918],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":130,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2959,2962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2959,2962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Base repository interface with common CRUD operations\n */\n\nimport { Result } from \"@/lib/core/result\";\nimport { DatabaseError } from \"@/lib/core/errors\";\n\n/**\n * Generic repository interface\n */\nexport interface Repository<TEntity, TCreateInput = Partial<TEntity>, TUpdateInput = Partial<TEntity>> {\n  /**\n   * Find entity by ID\n   */\n  findById(id: string): Promise<Result<TEntity | null, DatabaseError>>;\n\n  /**\n   * Find multiple entities with optional filtering\n   */\n  findMany(options?: FindManyOptions<TEntity>): Promise<Result<TEntity[], DatabaseError>>;\n\n  /**\n   * Find first entity matching criteria\n   */\n  findFirst(criteria: Partial<TEntity>): Promise<Result<TEntity | null, DatabaseError>>;\n\n  /**\n   * Create new entity\n   */\n  create(data: TCreateInput): Promise<Result<TEntity, DatabaseError>>;\n\n  /**\n   * Update existing entity\n   */\n  update(id: string, data: TUpdateInput): Promise<Result<TEntity, DatabaseError>>;\n\n  /**\n   * Delete entity by ID\n   */\n  delete(id: string): Promise<Result<boolean, DatabaseError>>;\n\n  /**\n   * Count entities matching criteria\n   */\n  count(criteria?: Partial<TEntity>): Promise<Result<number, DatabaseError>>;\n\n  /**\n   * Check if entity exists\n   */\n  exists(criteria: Partial<TEntity>): Promise<Result<boolean, DatabaseError>>;\n}\n\n/**\n * Find many options\n */\nexport interface FindManyOptions<TEntity> {\n  where?: Partial<TEntity>;\n  select?: (keyof TEntity)[];\n  orderBy?: {\n    field: keyof TEntity;\n    direction: 'asc' | 'desc';\n  }[];\n  limit?: number;\n  offset?: number;\n  include?: string[];\n}\n\n/**\n * Pagination options\n */\nexport interface PaginationOptions {\n  page: number;\n  limit: number;\n}\n\n/**\n * Paginated result\n */\nexport interface PaginatedResult<T> {\n  data: T[];\n  pagination: {\n    page: number;\n    limit: number;\n    total: number;\n    totalPages: number;\n    hasNext: boolean;\n    hasPrev: boolean;\n  };\n}\n\n/**\n * Search options\n */\nexport interface SearchOptions<TEntity> extends FindManyOptions<TEntity> {\n  search?: {\n    fields: (keyof TEntity)[];\n    query: string;\n  };\n}\n\n/**\n * Transaction interface\n */\nexport interface Transaction {\n  commit(): Promise<Result<void, DatabaseError>>;\n  rollback(): Promise<Result<void, DatabaseError>>;\n}\n\n/**\n * Repository with transaction support\n */\nexport interface TransactionalRepository<TEntity, TCreateInput = Partial<TEntity>, TUpdateInput = Partial<TEntity>> \n  extends Repository<TEntity, TCreateInput, TUpdateInput> {\n  \n  /**\n   * Execute operations within a transaction\n   */\n  withTransaction<T>(\n    callback: (tx: Transaction, repo: Repository<TEntity, TCreateInput, TUpdateInput>) => Promise<Result<T, DatabaseError>>\n  ): Promise<Result<T, DatabaseError>>;\n}\n\n/**\n * Repository factory interface\n */\nexport interface RepositoryFactory {\n  createCartRepository(): Repository<any>;\n  createProductRepository(): Repository<any>;\n  createUserRepository(): Repository<any>;\n  createOrderRepository(): Repository<any>;\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\domain\\services\\__tests__\\cart.service.integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1291,1294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1291,1294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1360,1363],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1360,1363],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1394,1397],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1394,1397],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1425,1428],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1425,1428],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1456,1459],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1456,1459],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1474,1477],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1474,1477],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'itemToRemove' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":312,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":312,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Cart Domain Service Integration Tests\n * \n * Tests the entire service layer with real dependency injection\n * and validates all error scenarios properly.\n */\n\nimport { beforeEach, describe, expect, it, jest, afterEach } from '@jest/globals';\nimport { ContainerConfiguration } from '@/lib/infrastructure/container/container.config';\nimport { SERVICE_TOKENS } from '@/lib/infrastructure/container/container';\nimport { CartDomainService } from '../cart.service';\nimport { Cart } from '@/lib/domain/entities/cart.entity';\nimport { Money } from '@/lib/domain/value-objects/money';\nimport { Quantity } from '@/lib/domain/value-objects/quantity';\nimport { ProductReference } from '@/lib/domain/value-objects/product-reference';\nimport { BusinessError, ValidationError } from '@/lib/core/errors';\n\n// Mock Supabase\njest.mock('@/lib/supabase/server', () => ({\n  createSupabaseServerClient: jest.fn()\n}));\n\n// Mock logger\njest.mock('@/lib/core/logger', () => ({\n  logger: {\n    info: jest.fn(),\n    warn: jest.fn(),\n    error: jest.fn(),\n  },\n  LogUtils: {\n    createUserActionContext: jest.fn(() => ({})),\n    logOperationStart: jest.fn(),\n    logOperationSuccess: jest.fn(),\n    logOperationError: jest.fn(),\n  }\n}));\n\ndescribe('CartDomainService Integration Tests', () => {\n  let container: any;\n  let cartService: CartDomainService;\n  let mockCartRepository: any;\n  let mockProductRepository: any;\n  let mockUserRepository: any;\n  let mockEventPublisher: any;\n  let scope: any;\n\n  beforeEach(async () => {\n    // Create mock repositories\n    mockCartRepository = {\n      findByUserId: jest.fn(),\n      save: jest.fn(),\n      delete: jest.fn(),\n      findByUserIdWithItems: jest.fn(),\n    };\n\n    mockProductRepository = {\n      findById: jest.fn(),\n      existsAndActive: jest.fn(),\n      checkStock: jest.fn(),\n    };\n\n    mockUserRepository = {\n      exists: jest.fn(),\n      isActive: jest.fn(),\n    };\n\n    mockEventPublisher = {\n      publish: jest.fn(),\n    };\n\n    // Configure test container with mocks\n    const containerResult = ContainerConfiguration.configureTest({\n      [SERVICE_TOKENS.CART_REPOSITORY]: mockCartRepository,\n      [SERVICE_TOKENS.PRODUCT_REPOSITORY]: mockProductRepository,\n      [SERVICE_TOKENS.USER_REPOSITORY]: mockUserRepository,\n      [SERVICE_TOKENS.EVENT_PUBLISHER]: mockEventPublisher,\n    });\n\n    if (containerResult.isError()) {\n      throw new Error(`Failed to create test container: ${containerResult.getError().message}`);\n    }\n\n    container = containerResult.getValue();\n    scope = container.createScope();\n    cartService = scope.resolve<CartDomainService>(SERVICE_TOKENS.CART_DOMAIN_SERVICE);\n  });\n\n  afterEach(() => {\n    scope?.dispose();\n    jest.clearAllMocks();\n  });\n\n  describe('addItemToCart', () => {\n    const userId = 'user-123';\n    const productId = 'product-456';\n    const quantity = 2;\n\n    beforeEach(() => {\n      // Setup default successful responses\n      mockUserRepository.exists.mockResolvedValue({ isError: () => false, getValue: () => true });\n      mockUserRepository.isActive.mockResolvedValue({ isError: () => false, getValue: () => true });\n      mockProductRepository.existsAndActive.mockResolvedValue({ isError: () => false, getValue: () => true });\n      mockProductRepository.checkStock.mockResolvedValue({ isError: () => false, getValue: () => true });\n      mockProductRepository.findById.mockResolvedValue({\n        isError: () => false,\n        getValue: () => new ProductReference(\n          productId,\n          'Test Product',\n          new Money(10.99),\n          'test-slug',\n          'https://example.com/image.jpg'\n        )\n      });\n    });\n\n    it('should successfully add item to new cart', async () => {\n      // Arrange\n      mockCartRepository.findByUserId.mockResolvedValue({\n        isError: () => false,\n        getValue: () => null\n      });\n\n      const newCart = new Cart(userId);\n      newCart.addItem(\n        'cart-item-id',\n        new ProductReference(productId, 'Test Product', new Money(10.99), 'test-slug', 'https://example.com/image.jpg'),\n        new Quantity(quantity)\n      );\n\n      mockCartRepository.save.mockResolvedValue({\n        isError: () => false,\n        getValue: () => newCart\n      });\n\n      // Act\n      const result = await cartService.addItemToCart(userId, productId, quantity);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const cart = result.getValue();\n      expect(cart.userId).toBe(userId);\n      expect(cart.getTotalQuantity().value).toBe(quantity);\n      expect(cart.getSubtotal().amount).toBe(10.99 * quantity);\n\n      // Verify repository calls\n      expect(mockUserRepository.exists).toHaveBeenCalledWith(userId);\n      expect(mockUserRepository.isActive).toHaveBeenCalledWith(userId);\n      expect(mockProductRepository.existsAndActive).toHaveBeenCalledWith(productId);\n      expect(mockProductRepository.checkStock).toHaveBeenCalledWith(productId, quantity);\n      expect(mockCartRepository.findByUserId).toHaveBeenCalledWith(userId);\n      expect(mockCartRepository.save).toHaveBeenCalled();\n      expect(mockEventPublisher.publish).toHaveBeenCalled();\n    });\n\n    it('should successfully add item to existing cart', async () => {\n      // Arrange\n      const existingCart = new Cart(userId);\n      existingCart.addItem(\n        'existing-item',\n        new ProductReference('other-product', 'Other Product', new Money(5.99), 'other-slug'),\n        new Quantity(1)\n      );\n\n      mockCartRepository.findByUserId.mockResolvedValue({\n        isError: () => false,\n        getValue: () => existingCart\n      });\n\n      mockCartRepository.save.mockResolvedValue({\n        isError: () => false,\n        getValue: () => existingCart\n      });\n\n      // Act\n      const result = await cartService.addItemToCart(userId, productId, quantity);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const cart = result.getValue();\n      expect(cart.getItems()).toHaveLength(2);\n      expect(cart.getTotalQuantity().value).toBe(3); // 1 + 2\n    });\n\n    it('should fail when user does not exist', async () => {\n      // Arrange\n      mockUserRepository.exists.mockResolvedValue({\n        isError: () => false,\n        getValue: () => false\n      });\n\n      // Act\n      const result = await cartService.addItemToCart(userId, productId, quantity);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(BusinessError);\n      expect(result.getError().message).toContain('Utilisateur non trouvé');\n    });\n\n    it('should fail when user is not active', async () => {\n      // Arrange\n      mockUserRepository.isActive.mockResolvedValue({\n        isError: () => false,\n        getValue: () => false\n      });\n\n      // Act\n      const result = await cartService.addItemToCart(userId, productId, quantity);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(BusinessError);\n      expect(result.getError().message).toContain('Compte utilisateur inactif');\n    });\n\n    it('should fail when product does not exist or is inactive', async () => {\n      // Arrange\n      mockProductRepository.existsAndActive.mockResolvedValue({\n        isError: () => false,\n        getValue: () => false\n      });\n\n      // Act\n      const result = await cartService.addItemToCart(userId, productId, quantity);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(BusinessError);\n      expect(result.getError().message).toContain('Produit non disponible');\n    });\n\n    it('should fail when product is out of stock', async () => {\n      // Arrange\n      mockProductRepository.checkStock.mockResolvedValue({\n        isError: () => false,\n        getValue: () => false\n      });\n\n      // Act\n      const result = await cartService.addItemToCart(userId, productId, quantity);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(BusinessError);\n      expect(result.getError().message).toContain('Stock insuffisant');\n    });\n\n    it('should handle repository errors gracefully', async () => {\n      // Arrange\n      mockCartRepository.findByUserId.mockResolvedValue({\n        isError: () => true,\n        getError: () => new Error('Database connection failed')\n      });\n\n      // Act\n      const result = await cartService.addItemToCart(userId, productId, quantity);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(BusinessError);\n      expect(result.getError().message).toContain('Erreur lors de la récupération du panier');\n    });\n\n    it('should handle invalid quantity (business rule validation)', async () => {\n      // Act\n      const result = await cartService.addItemToCart(userId, productId, 0);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(ValidationError);\n      expect(result.getError().message).toContain('Quantité invalide');\n    });\n\n    it('should handle cart capacity limits', async () => {\n      // Arrange\n      const cart = new Cart(userId);\n      // Add items up to the limit (assuming CART_CONSTRAINTS.MAX_ITEMS = 50)\n      for (let i = 0; i < 50; i++) {\n        cart.addItem(\n          `item-${i}`,\n          new ProductReference(`product-${i}`, `Product ${i}`, new Money(1.0), `slug-${i}`),\n          new Quantity(1)\n        );\n      }\n\n      mockCartRepository.findByUserId.mockResolvedValue({\n        isError: () => false,\n        getValue: () => cart\n      });\n\n      // Act\n      const result = await cartService.addItemToCart(userId, productId, quantity);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(BusinessError);\n      expect(result.getError().message).toContain('Limite d\\'articles atteinte');\n    });\n  });\n\n  describe('removeItemFromCart', () => {\n    const userId = 'user-123';\n    const cartItemId = 'cart-item-456';\n\n    beforeEach(() => {\n      mockUserRepository.exists.mockResolvedValue({ isError: () => false, getValue: () => true });\n    });\n\n    it('should successfully remove item from cart', async () => {\n      // Arrange\n      const cart = new Cart(userId);\n      const itemToRemove = cart.addItem(\n        cartItemId,\n        new ProductReference('product-1', 'Product 1', new Money(10.99), 'product-1'),\n        new Quantity(2)\n      );\n\n      mockCartRepository.findByUserIdWithItems.mockResolvedValue({\n        isError: () => false,\n        getValue: () => cart\n      });\n\n      mockCartRepository.save.mockResolvedValue({\n        isError: () => false,\n        getValue: () => cart\n      });\n\n      // Act\n      const result = await cartService.removeItemFromCart(userId, cartItemId);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const updatedCart = result.getValue();\n      expect(updatedCart.getItems()).toHaveLength(0);\n      expect(mockCartRepository.save).toHaveBeenCalled();\n      expect(mockEventPublisher.publish).toHaveBeenCalled();\n    });\n\n    it('should fail when cart not found', async () => {\n      // Arrange\n      mockCartRepository.findByUserIdWithItems.mockResolvedValue({\n        isError: () => false,\n        getValue: () => null\n      });\n\n      // Act\n      const result = await cartService.removeItemFromCart(userId, cartItemId);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(BusinessError);\n      expect(result.getError().message).toContain('Panier non trouvé');\n    });\n\n    it('should fail when item not found in cart', async () => {\n      // Arrange\n      const cart = new Cart(userId);\n      cart.addItem(\n        'different-item',\n        new ProductReference('product-1', 'Product 1', new Money(10.99), 'product-1'),\n        new Quantity(1)\n      );\n\n      mockCartRepository.findByUserIdWithItems.mockResolvedValue({\n        isError: () => false,\n        getValue: () => cart\n      });\n\n      // Act\n      const result = await cartService.removeItemFromCart(userId, cartItemId);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(BusinessError);\n      expect(result.getError().message).toContain('Article non trouvé dans le panier');\n    });\n  });\n\n  describe('updateItemQuantity', () => {\n    const userId = 'user-123';\n    const cartItemId = 'cart-item-456';\n    const newQuantity = 5;\n\n    beforeEach(() => {\n      mockUserRepository.exists.mockResolvedValue({ isError: () => false, getValue: () => true });\n      mockProductRepository.checkStock.mockResolvedValue({ isError: () => false, getValue: () => true });\n    });\n\n    it('should successfully update item quantity', async () => {\n      // Arrange\n      const cart = new Cart(userId);\n      cart.addItem(\n        cartItemId,\n        new ProductReference('product-1', 'Product 1', new Money(10.99), 'product-1'),\n        new Quantity(2)\n      );\n\n      mockCartRepository.findByUserIdWithItems.mockResolvedValue({\n        isError: () => false,\n        getValue: () => cart\n      });\n\n      mockCartRepository.save.mockResolvedValue({\n        isError: () => false,\n        getValue: () => cart\n      });\n\n      // Act\n      const result = await cartService.updateItemQuantity(userId, cartItemId, newQuantity);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const updatedCart = result.getValue();\n      const item = updatedCart.getItems().find(i => i.id === cartItemId);\n      expect(item?.quantity.value).toBe(newQuantity);\n      expect(mockProductRepository.checkStock).toHaveBeenCalledWith('product-1', newQuantity);\n    });\n\n    it('should fail when stock is insufficient for new quantity', async () => {\n      // Arrange\n      const cart = new Cart(userId);\n      cart.addItem(\n        cartItemId,\n        new ProductReference('product-1', 'Product 1', new Money(10.99), 'product-1'),\n        new Quantity(2)\n      );\n\n      mockCartRepository.findByUserIdWithItems.mockResolvedValue({\n        isError: () => false,\n        getValue: () => cart\n      });\n\n      mockProductRepository.checkStock.mockResolvedValue({\n        isError: () => false,\n        getValue: () => false\n      });\n\n      // Act\n      const result = await cartService.updateItemQuantity(userId, cartItemId, newQuantity);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(BusinessError);\n      expect(result.getError().message).toContain('Stock insuffisant');\n    });\n  });\n\n  describe('mergeCarts', () => {\n    const fromUserId = 'guest-user';\n    const toUserId = 'auth-user';\n\n    beforeEach(() => {\n      mockUserRepository.exists.mockResolvedValue({ isError: () => false, getValue: () => true });\n    });\n\n    it('should successfully merge carts', async () => {\n      // Arrange\n      const guestCart = new Cart(fromUserId);\n      guestCart.addItem(\n        'guest-item',\n        new ProductReference('product-1', 'Product 1', new Money(5.99), 'product-1'),\n        new Quantity(1)\n      );\n\n      const userCart = new Cart(toUserId);\n      userCart.addItem(\n        'user-item',\n        new ProductReference('product-2', 'Product 2', new Money(10.99), 'product-2'),\n        new Quantity(2)\n      );\n\n      mockCartRepository.findByUserIdWithItems\n        .mockResolvedValueOnce({ isError: () => false, getValue: () => guestCart })\n        .mockResolvedValueOnce({ isError: () => false, getValue: () => userCart });\n\n      mockCartRepository.save.mockResolvedValue({\n        isError: () => false,\n        getValue: () => userCart\n      });\n\n      mockCartRepository.delete.mockResolvedValue({\n        isError: () => false,\n        getValue: () => undefined\n      });\n\n      // Act\n      const result = await cartService.mergeCarts(fromUserId, toUserId);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const mergedCart = result.getValue();\n      expect(mergedCart.getItems()).toHaveLength(2);\n      expect(mergedCart.userId).toBe(toUserId);\n      expect(mockCartRepository.delete).toHaveBeenCalledWith(fromUserId);\n      expect(mockEventPublisher.publish).toHaveBeenCalled();\n    });\n\n    it('should handle case when guest cart is empty', async () => {\n      // Arrange\n      mockCartRepository.findByUserIdWithItems\n        .mockResolvedValueOnce({ isError: () => false, getValue: () => null })\n        .mockResolvedValueOnce({ isError: () => false, getValue: () => new Cart(toUserId) });\n\n      // Act\n      const result = await cartService.mergeCarts(fromUserId, toUserId);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      expect(mockCartRepository.delete).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('clearCart', () => {\n    const userId = 'user-123';\n\n    beforeEach(() => {\n      mockUserRepository.exists.mockResolvedValue({ isError: () => false, getValue: () => true });\n    });\n\n    it('should successfully clear cart', async () => {\n      // Arrange\n      const cart = new Cart(userId);\n      cart.addItem(\n        'item-1',\n        new ProductReference('product-1', 'Product 1', new Money(10.99), 'product-1'),\n        new Quantity(2)\n      );\n\n      mockCartRepository.findByUserIdWithItems.mockResolvedValue({\n        isError: () => false,\n        getValue: () => cart\n      });\n\n      mockCartRepository.save.mockResolvedValue({\n        isError: () => false,\n        getValue: () => cart\n      });\n\n      // Act\n      const result = await cartService.clearCart(userId);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const clearedCart = result.getValue();\n      expect(clearedCart.getItems()).toHaveLength(0);\n      expect(mockEventPublisher.publish).toHaveBeenCalled();\n    });\n\n    it('should handle case when cart does not exist', async () => {\n      // Arrange\n      mockCartRepository.findByUserIdWithItems.mockResolvedValue({\n        isError: () => false,\n        getValue: () => null\n      });\n\n      // Act\n      const result = await cartService.clearCart(userId);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const cart = result.getValue();\n      expect(cart.isEmpty()).toBe(true);\n      expect(cart.userId).toBe(userId);\n    });\n  });\n\n  describe('getCartByUserId', () => {\n    const userId = 'user-123';\n\n    it('should successfully retrieve cart', async () => {\n      // Arrange\n      const cart = new Cart(userId);\n      cart.addItem(\n        'item-1',\n        new ProductReference('product-1', 'Product 1', new Money(10.99), 'product-1'),\n        new Quantity(2)\n      );\n\n      mockCartRepository.findByUserIdWithItems.mockResolvedValue({\n        isError: () => false,\n        getValue: () => cart\n      });\n\n      // Act\n      const result = await cartService.getCartByUserId(userId);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const retrievedCart = result.getValue();\n      expect(retrievedCart?.userId).toBe(userId);\n      expect(retrievedCart?.getItems()).toHaveLength(1);\n    });\n\n    it('should return null when cart does not exist', async () => {\n      // Arrange\n      mockCartRepository.findByUserIdWithItems.mockResolvedValue({\n        isError: () => false,\n        getValue: () => null\n      });\n\n      // Act\n      const result = await cartService.getCartByUserId(userId);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      expect(result.getValue()).toBeNull();\n    });\n\n    it('should handle repository errors', async () => {\n      // Arrange\n      mockCartRepository.findByUserIdWithItems.mockResolvedValue({\n        isError: () => true,\n        getError: () => new Error('Database error')\n      });\n\n      // Act\n      const result = await cartService.getCartByUserId(userId);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(BusinessError);\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\domain\\services\\cart.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CartItem' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Money' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":31},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1464,1467],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1464,1467],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Cart Domain Service\n * \n * Contains business logic and orchestrates cart operations\n * following Domain-Driven Design principles.\n */\n\nimport { Result } from \"@/lib/core/result\";\nimport { BusinessError, NotFoundError, ValidationError, DatabaseError } from \"@/lib/core/errors\";\nimport { logger, LogUtils } from \"@/lib/core/logger\";\nimport { Cart, CartItem, Money, Quantity, ProductReference } from \"../entities/cart.entity\";\n\n/**\n * Cart repository interface (will be implemented in infrastructure layer)\n */\nexport interface CartRepository {\n  findByUserId(userId: string): Promise<Result<Cart | null, DatabaseError>>;\n  findById(cartId: string): Promise<Result<Cart | null, DatabaseError>>;\n  save(cart: Cart): Promise<Result<Cart, DatabaseError>>;\n  delete(cartId: string): Promise<Result<boolean, DatabaseError>>;\n}\n\n/**\n * Product repository interface\n */\nexport interface ProductRepository {\n  findById(productId: string): Promise<Result<ProductReference | null, Error>>;\n  findByIds(productIds: string[]): Promise<Result<ProductReference[], Error>>;\n  updateStock(productId: string, newStock: number): Promise<Result<void, Error>>;\n}\n\n/**\n * User repository interface\n */\nexport interface UserRepository {\n  exists(userId: string): Promise<Result<boolean, Error>>;\n  isActive(userId: string): Promise<Result<boolean, Error>>;\n}\n\n/**\n * Cart domain events\n */\nexport interface CartDomainEvent {\n  aggregateId: string;\n  eventType: string;\n  eventData: any;\n  occurredAt: Date;\n}\n\nexport class CartItemAddedEvent implements CartDomainEvent {\n  constructor(\n    public readonly aggregateId: string,\n    public readonly productId: string,\n    public readonly quantity: number,\n    public readonly userId: string,\n    public readonly occurredAt: Date = new Date()\n  ) {}\n\n  eventType = 'CartItemAdded';\n  eventData = {\n    productId: this.productId,\n    quantity: this.quantity,\n    userId: this.userId,\n  };\n}\n\nexport class CartItemRemovedEvent implements CartDomainEvent {\n  constructor(\n    public readonly aggregateId: string,\n    public readonly itemId: string,\n    public readonly productId: string,\n    public readonly userId: string,\n    public readonly occurredAt: Date = new Date()\n  ) {}\n\n  eventType = 'CartItemRemoved';\n  eventData = {\n    itemId: this.itemId,\n    productId: this.productId,\n    userId: this.userId,\n  };\n}\n\nexport class CartItemQuantityUpdatedEvent implements CartDomainEvent {\n  constructor(\n    public readonly aggregateId: string,\n    public readonly itemId: string,\n    public readonly oldQuantity: number,\n    public readonly newQuantity: number,\n    public readonly userId: string,\n    public readonly occurredAt: Date = new Date()\n  ) {}\n\n  eventType = 'CartItemQuantityUpdated';\n  eventData = {\n    itemId: this.itemId,\n    oldQuantity: this.oldQuantity,\n    newQuantity: this.newQuantity,\n    userId: this.userId,\n  };\n}\n\n/**\n * Event publisher interface\n */\nexport interface EventPublisher {\n  publish(event: CartDomainEvent): Promise<void>;\n}\n\n/**\n * Cart domain service\n */\nexport class CartDomainService {\n  constructor(\n    private readonly cartRepository: CartRepository,\n    private readonly productRepository: ProductRepository,\n    private readonly userRepository: UserRepository,\n    private readonly eventPublisher: EventPublisher\n  ) {}\n\n  /**\n   * Add item to cart with full business logic\n   */\n  async addItemToCart(\n    userId: string,\n    productId: string,\n    quantity: number\n  ): Promise<Result<Cart, BusinessError | NotFoundError | ValidationError>> {\n    const context = LogUtils.createUserActionContext(userId, 'add_item_to_cart', 'cart', { productId, quantity });\n    LogUtils.logOperationStart('CartDomainService.addItemToCart', context);\n\n    try {\n      // Validate user exists and is active\n      const userValidation = await this.validateUser(userId);\n      if (userValidation.isError()) {\n        return Result.error(userValidation.getError());\n      }\n\n      // Get product details with stock validation\n      const productResult = await this.productRepository.findById(productId);\n      if (productResult.isError()) {\n        return Result.error(new BusinessError('Erreur lors de la récupération du produit'));\n      }\n\n      const product = productResult.getValue();\n      if (!product) {\n        return Result.error(new NotFoundError('Produit', productId));\n      }\n\n      // Validate quantity\n      let quantityVO: Quantity;\n      try {\n        quantityVO = new Quantity(quantity);\n      } catch (error) {\n        return Result.error(new ValidationError(error instanceof Error ? error.message : 'Quantité invalide'));\n      }\n\n      // Get or create cart\n      const cartResult = await this.getOrCreateCart(userId);\n      if (cartResult.isError()) {\n        return Result.error(cartResult.getError());\n      }\n\n      let cart = cartResult.getValue();\n\n      // Generate unique item ID\n      const itemId = `item_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      // Add item to cart (business rules validated in entity)\n      const addResult = cart.addItem(itemId, product, quantityVO);\n      if (addResult.isError()) {\n        LogUtils.logOperationError('CartDomainService.addItemToCart', addResult.getError(), context);\n        return Result.error(addResult.getError());\n      }\n\n      cart = addResult.getValue();\n\n      // Persist cart\n      const saveResult = await this.cartRepository.save(cart);\n      if (saveResult.isError()) {\n        return Result.error(new BusinessError('Erreur lors de la sauvegarde du panier'));\n      }\n\n      // Publish domain event\n      const event = new CartItemAddedEvent(cart.id, productId, quantity, userId);\n      await this.eventPublisher.publish(event);\n\n      LogUtils.logOperationSuccess('CartDomainService.addItemToCart', context);\n      return Result.ok(saveResult.getValue());\n\n    } catch (error) {\n      LogUtils.logOperationError('CartDomainService.addItemToCart', error, context);\n      return Result.error(new BusinessError('Erreur interne lors de l\\'ajout au panier'));\n    }\n  }\n\n  /**\n   * Remove item from cart\n   */\n  async removeItemFromCart(\n    userId: string,\n    itemId: string\n  ): Promise<Result<Cart, BusinessError | NotFoundError>> {\n    const context = LogUtils.createUserActionContext(userId, 'remove_item_from_cart', 'cart', { itemId });\n    LogUtils.logOperationStart('CartDomainService.removeItemFromCart', context);\n\n    try {\n      // Validate user\n      const userValidation = await this.validateUser(userId);\n      if (userValidation.isError()) {\n        return Result.error(userValidation.getError());\n      }\n\n      // Get cart\n      const cartResult = await this.cartRepository.findByUserId(userId);\n      if (cartResult.isError()) {\n        return Result.error(new BusinessError('Erreur lors de la récupération du panier'));\n      }\n\n      const cart = cartResult.getValue();\n      if (!cart) {\n        return Result.error(new NotFoundError('Panier', userId));\n      }\n\n      // Get item before removal for event\n      const item = cart.getItemById(itemId);\n      if (!item) {\n        return Result.error(new NotFoundError('Article', itemId));\n      }\n\n      // Remove item\n      const removeResult = cart.removeItem(itemId);\n      if (removeResult.isError()) {\n        return Result.error(removeResult.getError());\n      }\n\n      const updatedCart = removeResult.getValue();\n\n      // Persist cart\n      const saveResult = await this.cartRepository.save(updatedCart);\n      if (saveResult.isError()) {\n        return Result.error(new BusinessError('Erreur lors de la sauvegarde du panier'));\n      }\n\n      // Publish domain event\n      const event = new CartItemRemovedEvent(cart.id, itemId, item.productReference.id, userId);\n      await this.eventPublisher.publish(event);\n\n      LogUtils.logOperationSuccess('CartDomainService.removeItemFromCart', context);\n      return Result.ok(saveResult.getValue());\n\n    } catch (error) {\n      LogUtils.logOperationError('CartDomainService.removeItemFromCart', error, context);\n      return Result.error(new BusinessError('Erreur interne lors de la suppression'));\n    }\n  }\n\n  /**\n   * Update item quantity\n   */\n  async updateItemQuantity(\n    userId: string,\n    itemId: string,\n    newQuantity: number\n  ): Promise<Result<Cart, BusinessError | NotFoundError | ValidationError>> {\n    const context = LogUtils.createUserActionContext(userId, 'update_item_quantity', 'cart', { itemId, newQuantity });\n    LogUtils.logOperationStart('CartDomainService.updateItemQuantity', context);\n\n    try {\n      // Validate user\n      const userValidation = await this.validateUser(userId);\n      if (userValidation.isError()) {\n        return Result.error(userValidation.getError());\n      }\n\n      // Validate quantity\n      let quantityVO: Quantity;\n      try {\n        quantityVO = new Quantity(newQuantity);\n      } catch (error) {\n        return Result.error(new ValidationError(error instanceof Error ? error.message : 'Quantité invalide'));\n      }\n\n      // Get cart\n      const cartResult = await this.cartRepository.findByUserId(userId);\n      if (cartResult.isError()) {\n        return Result.error(new BusinessError('Erreur lors de la récupération du panier'));\n      }\n\n      const cart = cartResult.getValue();\n      if (!cart) {\n        return Result.error(new NotFoundError('Panier', userId));\n      }\n\n      // Get current item for event data\n      const currentItem = cart.getItemById(itemId);\n      if (!currentItem) {\n        return Result.error(new NotFoundError('Article', itemId));\n      }\n\n      const oldQuantity = currentItem.quantity.value;\n\n      // Update quantity (handles removal if quantity is 0)\n      const updateResult = cart.updateItemQuantity(itemId, quantityVO);\n      if (updateResult.isError()) {\n        return Result.error(updateResult.getError());\n      }\n\n      const updatedCart = updateResult.getValue();\n\n      // Persist cart\n      const saveResult = await this.cartRepository.save(updatedCart);\n      if (saveResult.isError()) {\n        return Result.error(new BusinessError('Erreur lors de la sauvegarde du panier'));\n      }\n\n      // Publish domain event\n      const event = new CartItemQuantityUpdatedEvent(cart.id, itemId, oldQuantity, newQuantity, userId);\n      await this.eventPublisher.publish(event);\n\n      LogUtils.logOperationSuccess('CartDomainService.updateItemQuantity', context);\n      return Result.ok(saveResult.getValue());\n\n    } catch (error) {\n      LogUtils.logOperationError('CartDomainService.updateItemQuantity', error, context);\n      return Result.error(new BusinessError('Erreur interne lors de la mise à jour'));\n    }\n  }\n\n  /**\n   * Clear entire cart\n   */\n  async clearCart(userId: string): Promise<Result<Cart, BusinessError | NotFoundError>> {\n    const context = LogUtils.createUserActionContext(userId, 'clear_cart', 'cart');\n    LogUtils.logOperationStart('CartDomainService.clearCart', context);\n\n    try {\n      // Validate user\n      const userValidation = await this.validateUser(userId);\n      if (userValidation.isError()) {\n        return Result.error(userValidation.getError());\n      }\n\n      // Get cart\n      const cartResult = await this.cartRepository.findByUserId(userId);\n      if (cartResult.isError()) {\n        return Result.error(new BusinessError('Erreur lors de la récupération du panier'));\n      }\n\n      const cart = cartResult.getValue();\n      if (!cart) {\n        return Result.error(new NotFoundError('Panier', userId));\n      }\n\n      // Clear cart\n      const clearedCart = cart.clear();\n\n      // Persist cart\n      const saveResult = await this.cartRepository.save(clearedCart);\n      if (saveResult.isError()) {\n        return Result.error(new BusinessError('Erreur lors de la sauvegarde du panier'));\n      }\n\n      LogUtils.logOperationSuccess('CartDomainService.clearCart', context);\n      return Result.ok(saveResult.getValue());\n\n    } catch (error) {\n      LogUtils.logOperationError('CartDomainService.clearCart', error, context);\n      return Result.error(new BusinessError('Erreur interne lors de la vidange du panier'));\n    }\n  }\n\n  /**\n   * Get cart by user ID\n   */\n  async getCartByUserId(userId: string): Promise<Result<Cart | null, BusinessError>> {\n    const context = LogUtils.createUserActionContext(userId, 'get_cart', 'cart');\n    \n    try {\n      // Validate user\n      const userValidation = await this.validateUser(userId);\n      if (userValidation.isError()) {\n        return Result.error(userValidation.getError());\n      }\n\n      const cartResult = await this.cartRepository.findByUserId(userId);\n      if (cartResult.isError()) {\n        return Result.error(new BusinessError('Erreur lors de la récupération du panier'));\n      }\n\n      const cart = cartResult.getValue();\n      \n      // Validate cart items against current product data\n      if (cart) {\n        const validationResult = await this.validateCartItems(cart);\n        if (validationResult.isError()) {\n          logger.warn('Cart validation failed', { error: validationResult.getError(), context });\n          // Return cart anyway but log the validation issues\n        }\n      }\n\n      return Result.ok(cart);\n\n    } catch (error) {\n      LogUtils.logOperationError('CartDomainService.getCartByUserId', error, context);\n      return Result.error(new BusinessError('Erreur interne lors de la récupération du panier'));\n    }\n  }\n\n  /**\n   * Merge two carts (for guest to authenticated user transition)\n   */\n  async mergeCarts(\n    fromUserId: string,\n    toUserId: string\n  ): Promise<Result<Cart, BusinessError | NotFoundError>> {\n    const context = LogUtils.createUserActionContext(toUserId, 'merge_carts', 'cart', { fromUserId });\n    LogUtils.logOperationStart('CartDomainService.mergeCarts', context);\n\n    try {\n      // Validate both users\n      const toUserValidation = await this.validateUser(toUserId);\n      if (toUserValidation.isError()) {\n        return Result.error(toUserValidation.getError());\n      }\n\n      // Get both carts\n      const [fromCartResult, toCartResult] = await Promise.all([\n        this.cartRepository.findByUserId(fromUserId),\n        this.cartRepository.findByUserId(toUserId),\n      ]);\n\n      if (fromCartResult.isError() || toCartResult.isError()) {\n        return Result.error(new BusinessError('Erreur lors de la récupération des paniers'));\n      }\n\n      const fromCart = fromCartResult.getValue();\n      const toCart = toCartResult.getValue();\n\n      // If source cart is empty, return target cart\n      if (!fromCart || fromCart.isEmpty()) {\n        return Result.ok(toCart || await this.createEmptyCart(toUserId));\n      }\n\n      // If target cart doesn't exist, transfer ownership of source cart\n      if (!toCart) {\n        const transferredCart = new Cart(\n          fromCart.id,\n          toUserId, // New user ID\n          new Map(fromCart.getItems().map(item => [item.id, item])),\n          fromCart.createdAt,\n          new Date()\n        );\n\n        const saveResult = await this.cartRepository.save(transferredCart);\n        if (saveResult.isError()) {\n          return Result.error(new BusinessError('Erreur lors du transfert du panier'));\n        }\n\n        // Delete old cart\n        await this.cartRepository.delete(fromCart.id);\n\n        LogUtils.logOperationSuccess('CartDomainService.mergeCarts', context);\n        return Result.ok(saveResult.getValue());\n      }\n\n      // Merge carts: add items from source to target\n      let mergedCart = toCart;\n      const fromItems = fromCart.getItems();\n\n      for (const fromItem of fromItems) {\n        const existingItem = mergedCart.getItemByProductId(fromItem.productReference.id);\n        \n        if (existingItem) {\n          // Combine quantities\n          const combinedQuantity = new Quantity(\n            existingItem.quantity.value + fromItem.quantity.value\n          );\n          \n          const updateResult = mergedCart.updateItemQuantity(existingItem.id, combinedQuantity);\n          if (updateResult.isError()) {\n            // If update fails (e.g., exceeds stock), keep existing quantity\n            logger.warn('Failed to merge item quantities', { error: updateResult.getError(), context });\n            continue;\n          }\n          mergedCart = updateResult.getValue();\n        } else {\n          // Add new item\n          const addResult = mergedCart.addItem(\n            fromItem.id,\n            fromItem.productReference,\n            fromItem.quantity\n          );\n          if (addResult.isError()) {\n            // If add fails (e.g., cart full), skip this item\n            logger.warn('Failed to add item during merge', { error: addResult.getError(), context });\n            continue;\n          }\n          mergedCart = addResult.getValue();\n        }\n      }\n\n      // Save merged cart and delete source cart\n      const saveResult = await this.cartRepository.save(mergedCart);\n      if (saveResult.isError()) {\n        return Result.error(new BusinessError('Erreur lors de la sauvegarde du panier fusionné'));\n      }\n\n      await this.cartRepository.delete(fromCart.id);\n\n      LogUtils.logOperationSuccess('CartDomainService.mergeCarts', context);\n      return Result.ok(saveResult.getValue());\n\n    } catch (error) {\n      LogUtils.logOperationError('CartDomainService.mergeCarts', error, context);\n      return Result.error(new BusinessError('Erreur interne lors de la fusion des paniers'));\n    }\n  }\n\n  /**\n   * Get or create cart for user\n   */\n  private async getOrCreateCart(userId: string): Promise<Result<Cart, BusinessError>> {\n    const cartResult = await this.cartRepository.findByUserId(userId);\n    if (cartResult.isError()) {\n      return Result.error(new BusinessError('Erreur lors de la récupération du panier'));\n    }\n\n    let cart = cartResult.getValue();\n    if (!cart) {\n      cart = await this.createEmptyCart(userId);\n    }\n\n    return Result.ok(cart);\n  }\n\n  /**\n   * Create empty cart for user\n   */\n  private async createEmptyCart(userId: string): Promise<Cart> {\n    const cartId = `cart_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const cart = new Cart(cartId, userId);\n    \n    const saveResult = await this.cartRepository.save(cart);\n    if (saveResult.isError()) {\n      throw new BusinessError('Erreur lors de la création du panier');\n    }\n\n    return saveResult.getValue();\n  }\n\n  /**\n   * Validate user exists and is active\n   */\n  private async validateUser(userId: string): Promise<Result<void, BusinessError>> {\n    const [existsResult, isActiveResult] = await Promise.all([\n      this.userRepository.exists(userId),\n      this.userRepository.isActive(userId),\n    ]);\n\n    if (existsResult.isError() || isActiveResult.isError()) {\n      return Result.error(new BusinessError('Erreur lors de la validation de l\\'utilisateur'));\n    }\n\n    if (!existsResult.getValue()) {\n      return Result.error(new BusinessError('Utilisateur non trouvé'));\n    }\n\n    if (!isActiveResult.getValue()) {\n      return Result.error(new BusinessError('Compte utilisateur désactivé'));\n    }\n\n    return Result.ok(undefined);\n  }\n\n  /**\n   * Validate cart items against current product data\n   */\n  private async validateCartItems(cart: Cart): Promise<Result<void, BusinessError>> {\n    const items = cart.getItems();\n    if (items.length === 0) {\n      return Result.ok(undefined);\n    }\n\n    const productIds = items.map(item => item.productReference.id);\n    const productsResult = await this.productRepository.findByIds(productIds);\n    \n    if (productsResult.isError()) {\n      return Result.error(new BusinessError('Erreur lors de la validation des produits'));\n    }\n\n    const currentProducts = productsResult.getValue();\n    const issues: string[] = [];\n\n    for (const item of items) {\n      const currentProduct = currentProducts.find(p => p.id === item.productReference.id);\n      \n      if (!currentProduct) {\n        issues.push(`Produit ${item.productReference.name} non trouvé`);\n        continue;\n      }\n\n      if (!currentProduct.isActive) {\n        issues.push(`Produit ${item.productReference.name} non disponible`);\n      }\n\n      if (item.quantity.value > currentProduct.stock.value) {\n        issues.push(`Stock insuffisant pour ${item.productReference.name}`);\n      }\n\n      // Check for price changes (warning only)\n      if (!item.productReference.price.equals(currentProduct.price)) {\n        issues.push(`Prix modifié pour ${item.productReference.name}`);\n      }\n    }\n\n    if (issues.length > 0) {\n      return Result.error(new BusinessError(`Problèmes détectés: ${issues.join(', ')}`));\n    }\n\n    return Result.ok(undefined);\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\container\\__tests__\\container.integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ServiceLifetime' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2348,2351],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2348,2351],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2410,2413],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2410,2413],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2679,2682],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2679,2682],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2746,2749],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2746,2749],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3017,3020],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3017,3020],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":122,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3563,3566],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3563,3566],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":123,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3625,3628],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3625,3628],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":124,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3687,3690],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3687,3690],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":336,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":336,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11094,11097],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11094,11097],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":394,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":394,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12736,12739],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12736,12739],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":399,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":399,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12882,12885],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12882,12885],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":427,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":427,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13721,13724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13721,13724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":451,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":451,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14588,14591],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14588,14591],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":494,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":494,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16033,16036],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16033,16036],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":504,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":504,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16334,16337],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16334,16337],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":557,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":557,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17983,17986],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17983,17986],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Container Integration Tests\n * \n * Tests the dependency injection container with real service configurations\n * to ensure proper service resolution and lifecycle management.\n */\n\nimport { beforeEach, describe, expect, it, jest, afterEach } from '@jest/globals';\nimport { \n  Container, \n  ContainerBuilder, \n  ServiceLifetime, \n  SERVICE_TOKENS \n} from '../container';\nimport { \n  ContainerConfiguration,\n  getServerContainer,\n  getAdminContainer,\n  createRequestScopedContainer,\n  resolveService,\n  resetContainers,\n  checkContainerHealth\n} from '../container.config';\nimport { CartDomainService } from '@/lib/domain/services/cart.service';\nimport { BusinessError } from '@/lib/core/errors';\n\n// Mock external dependencies\njest.mock('@/lib/supabase/server', () => ({\n  createSupabaseServerClient: jest.fn(() => ({\n    from: jest.fn().mockReturnThis(),\n    select: jest.fn().mockReturnThis(),\n    eq: jest.fn().mockReturnThis(),\n    single: jest.fn().mockResolvedValue({ data: null, error: null })\n  }))\n}));\n\njest.mock('@/lib/supabase/server-admin', () => ({\n  createSupabaseAdminClient: jest.fn(() => ({\n    from: jest.fn().mockReturnThis(),\n    select: jest.fn().mockReturnThis(),\n    eq: jest.fn().mockReturnThis(),\n    single: jest.fn().mockResolvedValue({ data: null, error: null })\n  }))\n}));\n\njest.mock('@/lib/core/logger', () => ({\n  logger: {\n    info: jest.fn(),\n    warn: jest.fn(),\n    error: jest.fn(),\n  }\n}));\n\ndescribe('Container Integration Tests', () => {\n  beforeEach(() => {\n    resetContainers();\n    jest.clearAllMocks();\n  });\n\n  afterEach(() => {\n    resetContainers();\n  });\n\n  describe('Container Basic Functionality', () => {\n    let container: Container;\n\n    beforeEach(() => {\n      const builder = new ContainerBuilder();\n      \n      // Register test services\n      builder.addSingleton('TestService', () => ({ value: 'test' }));\n      builder.addTransient('TransientService', () => ({ id: Math.random() }));\n      builder.addInstance('InstanceService', { configured: true });\n      \n      const result = builder.build();\n      if (result.isError()) {\n        throw new Error(`Failed to build container: ${result.getError().message}`);\n      }\n      container = result.getValue();\n    });\n\n    it('should resolve singleton services consistently', () => {\n      // Act\n      const service1 = container.resolve<any>('TestService');\n      const service2 = container.resolve<any>('TestService');\n\n      // Assert\n      expect(service1).toBe(service2); // Same instance\n      expect(service1.value).toBe('test');\n    });\n\n    it('should resolve transient services as new instances', () => {\n      // Act\n      const service1 = container.resolve<any>('TransientService');\n      const service2 = container.resolve<any>('TransientService');\n\n      // Assert\n      expect(service1).not.toBe(service2); // Different instances\n      expect(service1.id).not.toBe(service2.id);\n    });\n\n    it('should resolve instance services', () => {\n      // Act\n      const service = container.resolve<any>('InstanceService');\n\n      // Assert\n      expect(service.configured).toBe(true);\n    });\n\n    it('should handle scoped services correctly', () => {\n      // Arrange\n      container.registerScoped('ScopedService', () => ({ scopeId: Math.random() }));\n      const buildResult = container.build();\n      if (buildResult.isError()) {\n        throw new Error('Failed to rebuild container');\n      }\n\n      const scope1 = container.createScope();\n      const scope2 = container.createScope();\n\n      // Act\n      const service1a = scope1.resolve<any>('ScopedService');\n      const service1b = scope1.resolve<any>('ScopedService');\n      const service2a = scope2.resolve<any>('ScopedService');\n\n      // Assert\n      expect(service1a).toBe(service1b); // Same within scope\n      expect(service1a).not.toBe(service2a); // Different across scopes\n      expect(service1a.scopeId).toBe(service1b.scopeId);\n      expect(service1a.scopeId).not.toBe(service2a.scopeId);\n\n      // Cleanup\n      scope1.dispose();\n      scope2.dispose();\n    });\n\n    it('should throw error for unregistered services', () => {\n      // Act & Assert\n      expect(() => container.resolve('UnknownService')).toThrow(BusinessError);\n    });\n\n    it('should detect circular dependencies', () => {\n      // Arrange\n      const builder = new ContainerBuilder();\n      builder.addSingleton('ServiceA', (container) => {\n        return { serviceB: container.resolve('ServiceB') };\n      }, ['ServiceB']);\n      \n      builder.addSingleton('ServiceB', (container) => {\n        return { serviceA: container.resolve('ServiceA') };\n      }, ['ServiceA']);\n\n      // Act & Assert\n      const result = builder.build();\n      expect(result.isError()).toBe(true);\n      expect(result.getError().message).toContain('Circular dependency');\n    });\n\n    it('should validate missing dependencies', () => {\n      // Arrange\n      const builder = new ContainerBuilder();\n      builder.addSingleton('ServiceWithDeps', () => ({}), ['MissingDependency']);\n\n      // Act & Assert\n      const result = builder.build();\n      expect(result.isError()).toBe(true);\n      expect(result.getError().message).toContain('depends on');\n    });\n\n    it('should provide container statistics', () => {\n      // Act\n      const stats = container.getStatistics();\n\n      // Assert\n      expect(stats.totalServices).toBe(3);\n      expect(stats.singletonServices).toBe(1);\n      expect(stats.transientServices).toBe(1);\n      expect(stats.singletonInstances).toBe(0); // Not yet resolved\n    });\n\n    it('should handle tryResolve gracefully', () => {\n      // Act\n      const existingService = container.tryResolve('TestService');\n      const nonExistentService = container.tryResolve('NonExistent');\n\n      // Assert\n      expect(existingService).toBeDefined();\n      expect(existingService.value).toBe('test');\n      expect(nonExistentService).toBeNull();\n    });\n  });\n\n  describe('Server Container Configuration', () => {\n    it('should successfully configure server container', async () => {\n      // Act\n      const container = await getServerContainer();\n\n      // Assert\n      expect(container).toBeInstanceOf(Container);\n      expect(container.isRegistered(SERVICE_TOKENS.CART_DOMAIN_SERVICE)).toBe(true);\n      expect(container.isRegistered(SERVICE_TOKENS.CART_REPOSITORY)).toBe(true);\n      expect(container.isRegistered(SERVICE_TOKENS.PRODUCT_REPOSITORY)).toBe(true);\n    });\n\n    it('should resolve cart domain service from server container', async () => {\n      // Act\n      const cartService = await resolveService<CartDomainService>(SERVICE_TOKENS.CART_DOMAIN_SERVICE);\n\n      // Assert\n      expect(cartService).toBeInstanceOf(CartDomainService);\n    });\n\n    it('should reuse server container instance', async () => {\n      // Act\n      const container1 = await getServerContainer();\n      const container2 = await getServerContainer();\n\n      // Assert\n      expect(container1).toBe(container2); // Same instance\n    });\n\n    it('should create independent request-scoped containers', async () => {\n      // Act\n      const { container: container1, scope: scope1 } = await createRequestScopedContainer();\n      const { container: container2, scope: scope2 } = await createRequestScopedContainer();\n\n      // Assert\n      expect(container1).toBe(container2); // Same base container\n      expect(scope1).not.toBe(scope2); // Different scopes\n\n      // Services from different scopes should be independent\n      const service1 = scope1.resolve<CartDomainService>(SERVICE_TOKENS.CART_DOMAIN_SERVICE);\n      const service2 = scope2.resolve<CartDomainService>(SERVICE_TOKENS.CART_DOMAIN_SERVICE);\n      \n      expect(service1).not.toBe(service2); // Different instances (transient)\n\n      // Cleanup\n      scope1.dispose();\n      scope2.dispose();\n    });\n  });\n\n  describe('Admin Container Configuration', () => {\n    it('should successfully configure admin container', async () => {\n      // Act\n      const container = await getAdminContainer();\n\n      // Assert\n      expect(container).toBeInstanceOf(Container);\n      expect(container.isRegistered(SERVICE_TOKENS.CART_DOMAIN_SERVICE)).toBe(true);\n      expect(container.isRegistered(SERVICE_TOKENS.CART_REPOSITORY)).toBe(true);\n    });\n\n    it('should use different Supabase client for admin container', async () => {\n      // Arrange\n      const serverContainer = await getServerContainer();\n      const adminContainer = await getAdminContainer();\n\n      // Act\n      const serverClient = serverContainer.resolve(SERVICE_TOKENS.SUPABASE_CLIENT);\n      const adminClient = adminContainer.resolve(SERVICE_TOKENS.SUPABASE_CLIENT);\n\n      // Assert\n      expect(serverClient).toBeDefined();\n      expect(adminClient).toBeDefined();\n      // They should be different instances (different configurations)\n      // This is implied by different factory functions in configuration\n    });\n  });\n\n  describe('Test Container Configuration', () => {\n    it('should configure test container with mocks', () => {\n      // Arrange\n      const mockCartService = { test: true };\n      const mockRepository = { mock: true };\n\n      // Act\n      const result = ContainerConfiguration.configureTest({\n        [SERVICE_TOKENS.CART_DOMAIN_SERVICE]: mockCartService,\n        [SERVICE_TOKENS.CART_REPOSITORY]: mockRepository\n      });\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const container = result.getValue();\n      \n      const resolvedCartService = container.resolve(SERVICE_TOKENS.CART_DOMAIN_SERVICE);\n      const resolvedRepository = container.resolve(SERVICE_TOKENS.CART_REPOSITORY);\n      \n      expect(resolvedCartService).toBe(mockCartService);\n      expect(resolvedRepository).toBe(mockRepository);\n    });\n\n    it('should use real services when not mocked', () => {\n      // Arrange & Act\n      const result = ContainerConfiguration.configureTest({\n        [SERVICE_TOKENS.CART_REPOSITORY]: { mocked: true }\n      });\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const container = result.getValue();\n      \n      // Should have mock\n      const repository = container.resolve(SERVICE_TOKENS.CART_REPOSITORY);\n      expect(repository.mocked).toBe(true);\n      \n      // Should have real service\n      expect(container.isRegistered(SERVICE_TOKENS.EVENT_PUBLISHER)).toBe(true);\n    });\n  });\n\n  describe('Container Health Check', () => {\n    it('should report healthy containers', async () => {\n      // Arrange\n      await getServerContainer();\n      await getAdminContainer();\n\n      // Act\n      const health = await checkContainerHealth();\n\n      // Assert\n      expect(health.server).toBe(true);\n      expect(health.admin).toBe(true);\n      expect(health.errors).toHaveLength(0);\n    });\n\n    it('should handle container errors in health check', async () => {\n      // Arrange\n      resetContainers();\n      \n      // Mock a container configuration failure\n      jest.spyOn(ContainerConfiguration, 'configureServer').mockReturnValue({\n        isError: () => true,\n        getError: () => new BusinessError('Configuration failed')\n      } as any);\n\n      // Act\n      const health = await checkContainerHealth();\n\n      // Assert\n      expect(health.server).toBe(false);\n      expect(health.errors.length).toBeGreaterThan(0);\n      expect(health.errors[0]).toContain('Server container error');\n    });\n  });\n\n  describe('Container Lifecycle Management', () => {\n    it('should properly reset containers', async () => {\n      // Arrange\n      const container1 = await getServerContainer();\n      \n      // Act\n      resetContainers();\n      const container2 = await getServerContainer();\n\n      // Assert\n      expect(container1).not.toBe(container2); // Different instances after reset\n    });\n\n    it('should dispose scoped services on scope disposal', () => {\n      // Arrange\n      const builder = new ContainerBuilder();\n      const mockDispose = jest.fn();\n      \n      builder.addScoped('DisposableService', () => ({\n        dispose: mockDispose,\n        value: 'test'\n      }));\n      \n      const result = builder.build();\n      const container = result.getValue();\n      const scope = container.createScope();\n\n      // Act\n      const service = scope.resolve('DisposableService');\n      expect(service.value).toBe('test');\n      \n      scope.dispose();\n\n      // Assert\n      expect(mockDispose).toHaveBeenCalled();\n    });\n\n    it('should clear singleton instances when requested', () => {\n      // Arrange\n      const builder = new ContainerBuilder();\n      builder.addSingleton('TestSingleton', () => ({ id: Math.random() }));\n      \n      const result = builder.build();\n      const container = result.getValue();\n\n      // Act\n      const instance1 = container.resolve<any>('TestSingleton');\n      const id1 = instance1.id;\n      \n      container.clearSingletons();\n      \n      const instance2 = container.resolve<any>('TestSingleton');\n      const id2 = instance2.id;\n\n      // Assert\n      expect(instance1).not.toBe(instance2);\n      expect(id1).not.toBe(id2);\n    });\n  });\n\n  describe('Complex Dependency Scenarios', () => {\n    it('should handle deep dependency chains', () => {\n      // Arrange\n      const builder = new ContainerBuilder();\n      \n      builder.addSingleton('ServiceA', () => ({ name: 'A' }));\n      builder.addSingleton('ServiceB', (container) => ({\n        name: 'B',\n        serviceA: container.resolve('ServiceA')\n      }), ['ServiceA']);\n      builder.addSingleton('ServiceC', (container) => ({\n        name: 'C',\n        serviceB: container.resolve('ServiceB')\n      }), ['ServiceB']);\n\n      const result = builder.build();\n      const container = result.getValue();\n\n      // Act\n      const serviceC = container.resolve<any>('ServiceC');\n\n      // Assert\n      expect(serviceC.name).toBe('C');\n      expect(serviceC.serviceB.name).toBe('B');\n      expect(serviceC.serviceB.serviceA.name).toBe('A');\n    });\n\n    it('should handle services with multiple dependencies', () => {\n      // Arrange\n      const builder = new ContainerBuilder();\n      \n      builder.addSingleton('LogService', () => ({ log: jest.fn() }));\n      builder.addSingleton('CacheService', () => ({ get: jest.fn(), set: jest.fn() }));\n      builder.addSingleton('ComplexService', (container) => ({\n        logger: container.resolve('LogService'),\n        cache: container.resolve('CacheService'),\n        process: () => 'processed'\n      }), ['LogService', 'CacheService']);\n\n      const result = builder.build();\n      const container = result.getValue();\n\n      // Act\n      const complexService = container.resolve<any>('ComplexService');\n\n      // Assert\n      expect(complexService.logger).toBeDefined();\n      expect(complexService.cache).toBeDefined();\n      expect(complexService.process()).toBe('processed');\n    });\n\n    it('should handle conditional service registration', () => {\n      // Arrange\n      const builder = new ContainerBuilder();\n      const isDevelopment = process.env.NODE_ENV === 'development';\n      \n      if (isDevelopment) {\n        builder.addSingleton('DevService', () => ({ mode: 'development' }));\n      } else {\n        builder.addSingleton('ProdService', () => ({ mode: 'production' }));\n      }\n\n      const result = builder.build();\n      const container = result.getValue();\n\n      // Act & Assert\n      if (isDevelopment) {\n        expect(container.isRegistered('DevService')).toBe(true);\n        expect(container.isRegistered('ProdService')).toBe(false);\n      } else {\n        expect(container.isRegistered('ProdService')).toBe(true);\n        expect(container.isRegistered('DevService')).toBe(false);\n      }\n    });\n\n    it('should handle service decorators', () => {\n      // Arrange\n      const builder = new ContainerBuilder();\n      \n      // Base service\n      builder.addSingleton('BaseService', () => ({\n        process: (input: string) => `base:${input}`\n      }));\n      \n      // Decorated service\n      builder.addSingleton('DecoratedService', (container) => {\n        const baseService = container.resolve<any>('BaseService');\n        return {\n          process: (input: string) => `decorated:${baseService.process(input)}`\n        };\n      }, ['BaseService']);\n\n      const result = builder.build();\n      const container = result.getValue();\n\n      // Act\n      const decoratedService = container.resolve<any>('DecoratedService');\n      const output = decoratedService.process('test');\n\n      // Assert\n      expect(output).toBe('decorated:base:test');\n    });\n  });\n\n  describe('Performance and Stress Tests', () => {\n    it('should handle many service registrations efficiently', () => {\n      // Arrange\n      const builder = new ContainerBuilder();\n      const serviceCount = 1000;\n      \n      for (let i = 0; i < serviceCount; i++) {\n        builder.addSingleton(`Service${i}`, () => ({ id: i }));\n      }\n\n      // Act\n      const startTime = Date.now();\n      const result = builder.build();\n      const buildTime = Date.now() - startTime;\n      \n      expect(result.isError()).toBe(false);\n      const container = result.getValue();\n\n      const resolveStartTime = Date.now();\n      for (let i = 0; i < 100; i++) {\n        container.resolve(`Service${i}`);\n      }\n      const resolveTime = Date.now() - resolveStartTime;\n\n      // Assert\n      expect(buildTime).toBeLessThan(1000); // 1 second\n      expect(resolveTime).toBeLessThan(100); // 100ms for 100 resolutions\n      \n      const stats = container.getStatistics();\n      expect(stats.totalServices).toBe(serviceCount);\n    });\n\n    it('should handle concurrent service resolution', async () => {\n      // Arrange\n      const builder = new ContainerBuilder();\n      builder.addSingleton('ConcurrentService', () => ({ \n        id: Math.random(),\n        timestamp: Date.now()\n      }));\n      \n      const result = builder.build();\n      const container = result.getValue();\n\n      // Act\n      const promises = Array.from({ length: 100 }, () => \n        Promise.resolve(container.resolve<any>('ConcurrentService'))\n      );\n      \n      const services = await Promise.all(promises);\n\n      // Assert\n      // All should be the same instance (singleton)\n      const firstService = services[0];\n      services.forEach(service => {\n        expect(service).toBe(firstService);\n        expect(service.id).toBe(firstService.id);\n      });\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\container\\container.config.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SupabaseClient' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ServiceLifetime' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":55,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":70},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'initializeEventSystem' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":53},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1435,1438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1435,1438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":227,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6844,6847],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6844,6847],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Container Configuration\n * \n * Configures the dependency injection container with all application services.\n */\n\nimport { SupabaseClient } from \"@supabase/supabase-js\";\nimport { Container, ContainerBuilder, SERVICE_TOKENS, ServiceLifetime } from \"./container\";\nimport { Result } from \"@/lib/core/result\";\nimport { BusinessError } from \"@/lib/core/errors\";\nimport { logger } from \"@/lib/core/logger\";\n\n// Domain Services\nimport { CartDomainService, EventPublisher } from \"@/lib/domain/services/cart.service\";\n\n// Event System\nimport { configureEventSystem, initializeEventSystem } from '../events/event-container-config';\n\n// Repositories\nimport { SupabaseCartRepository } from \"../repositories/cart.repository\";\nimport { SupabaseProductRepository } from \"../repositories/product.repository\";\nimport { UserSupabaseRepository } from \"../repositories/user.supabase.repository\";\nimport { AddressSupabaseRepository } from \"../repositories/address.supabase.repository\";\nimport { OrderSupabaseRepository } from \"../repositories/order.supabase.repository\";\nimport { ArticleSupabaseRepository } from \"../repositories/article.supabase.repository\";\n\n// Supabase clients\nimport { createSupabaseServerClient } from \"@/lib/supabase/server\";\nimport { createSupabaseAdminClient } from \"@/lib/supabase/server-admin\";\n\n/**\n * Simple event publisher implementation\n */\nclass SimpleEventPublisher implements EventPublisher {\n  async publish(event: any): Promise<void> {\n    // Log the event for now - in production this would publish to a message queue\n    logger.info('Domain event published', { \n      eventType: event.eventType,\n      aggregateId: event.aggregateId,\n      eventData: event.eventData \n    });\n    \n    // Here you could integrate with:\n    // - Redis pub/sub\n    // - Message queues (RabbitMQ, AWS SQS)\n    // - Event streaming (Kafka)\n    // - Webhooks\n  }\n}\n\n\n/**\n * Container configuration for different environments\n */\nexport class ContainerConfiguration {\n  /**\n   * Configure container for server-side operations\n   */\n  static configureServer(): Result<Container, BusinessError> {\n    try {\n      const builder = new ContainerBuilder();\n\n      // Infrastructure - Supabase Clients\n      builder.addSingleton(\n        SERVICE_TOKENS.SUPABASE_CLIENT,\n        () => createSupabaseServerClient(),\n        []\n      );\n\n      // Repositories\n      builder.addSingleton(\n        SERVICE_TOKENS.CART_REPOSITORY,\n        (container) => new SupabaseCartRepository(\n          container.resolve(SERVICE_TOKENS.SUPABASE_CLIENT)\n        ),\n        [SERVICE_TOKENS.SUPABASE_CLIENT]\n      );\n\n      builder.addSingleton(\n        SERVICE_TOKENS.PRODUCT_REPOSITORY,\n        (container) => new SupabaseProductRepository(\n          container.resolve(SERVICE_TOKENS.SUPABASE_CLIENT)\n        ),\n        [SERVICE_TOKENS.SUPABASE_CLIENT]\n      );\n\n      builder.addSingleton(\n        SERVICE_TOKENS.USER_REPOSITORY,\n        () => new UserSupabaseRepository(),\n        []\n      );\n\n      builder.addSingleton(\n        SERVICE_TOKENS.ADDRESS_REPOSITORY,\n        () => new AddressSupabaseRepository(),\n        []\n      );\n\n      builder.addSingleton(\n        SERVICE_TOKENS.ORDER_REPOSITORY,\n        () => new OrderSupabaseRepository(),\n        []\n      );\n\n      builder.addSingleton(\n        SERVICE_TOKENS.ARTICLE_REPOSITORY,\n        () => new ArticleSupabaseRepository(),\n        []\n      );\n\n      builder.addInstance(SERVICE_TOKENS.LOGGER, logger);\n\n      // Configure Event System\n      configureEventSystem(builder);\n\n      // Domain Services\n      builder.addTransient(\n        SERVICE_TOKENS.CART_DOMAIN_SERVICE,\n        (container) => new CartDomainService(\n          container.resolve(SERVICE_TOKENS.CART_REPOSITORY),\n          container.resolve(SERVICE_TOKENS.PRODUCT_REPOSITORY),\n          container.resolve(SERVICE_TOKENS.USER_REPOSITORY),\n          container.resolve(SERVICE_TOKENS.EVENT_PUBLISHER)\n        ),\n        [\n          SERVICE_TOKENS.CART_REPOSITORY,\n          SERVICE_TOKENS.PRODUCT_REPOSITORY,\n          SERVICE_TOKENS.USER_REPOSITORY,\n          SERVICE_TOKENS.EVENT_PUBLISHER,\n        ]\n      );\n\n      return builder.build();\n    } catch (error) {\n      logger.error('Failed to configure server container', error);\n      return Result.error(new BusinessError('Container configuration failed', { error }));\n    }\n  }\n\n  /**\n   * Configure container for admin operations\n   */\n  static configureAdmin(): Result<Container, BusinessError> {\n    try {\n      const builder = new ContainerBuilder();\n\n      // Infrastructure - Admin Supabase Client\n      builder.addSingleton(\n        SERVICE_TOKENS.SUPABASE_CLIENT,\n        () => createSupabaseAdminClient(),\n        []\n      );\n\n      // Repositories (same as server but with admin client)\n      builder.addSingleton(\n        SERVICE_TOKENS.CART_REPOSITORY,\n        (container) => new SupabaseCartRepository(\n          container.resolve(SERVICE_TOKENS.SUPABASE_CLIENT)\n        ),\n        [SERVICE_TOKENS.SUPABASE_CLIENT]\n      );\n\n      builder.addSingleton(\n        SERVICE_TOKENS.PRODUCT_REPOSITORY,\n        (container) => new SupabaseProductRepository(\n          container.resolve(SERVICE_TOKENS.SUPABASE_CLIENT)\n        ),\n        [SERVICE_TOKENS.SUPABASE_CLIENT]\n      );\n\n      builder.addSingleton(\n        SERVICE_TOKENS.USER_REPOSITORY,\n        () => new UserSupabaseRepository(),\n        []\n      );\n\n      builder.addSingleton(\n        SERVICE_TOKENS.ADDRESS_REPOSITORY,\n        () => new AddressSupabaseRepository(),\n        []\n      );\n\n      builder.addSingleton(\n        SERVICE_TOKENS.ORDER_REPOSITORY,\n        () => new OrderSupabaseRepository(),\n        []\n      );\n\n      builder.addSingleton(\n        SERVICE_TOKENS.ARTICLE_REPOSITORY,\n        () => new ArticleSupabaseRepository(),\n        []\n      );\n\n      builder.addInstance(SERVICE_TOKENS.LOGGER, logger);\n\n      // Configure Event System\n      configureEventSystem(builder);\n\n      // Domain Services\n      builder.addTransient(\n        SERVICE_TOKENS.CART_DOMAIN_SERVICE,\n        (container) => new CartDomainService(\n          container.resolve(SERVICE_TOKENS.CART_REPOSITORY),\n          container.resolve(SERVICE_TOKENS.PRODUCT_REPOSITORY),\n          container.resolve(SERVICE_TOKENS.USER_REPOSITORY),\n          container.resolve(SERVICE_TOKENS.EVENT_PUBLISHER)\n        ),\n        [\n          SERVICE_TOKENS.CART_REPOSITORY,\n          SERVICE_TOKENS.PRODUCT_REPOSITORY,\n          SERVICE_TOKENS.USER_REPOSITORY,\n          SERVICE_TOKENS.EVENT_PUBLISHER,\n        ]\n      );\n\n      return builder.build();\n    } catch (error) {\n      logger.error('Failed to configure admin container', error);\n      return Result.error(new BusinessError('Admin container configuration failed', { error }));\n    }\n  }\n\n  /**\n   * Configure container for testing\n   */\n  static configureTest(mockServices: Record<string, any> = {}): Result<Container, BusinessError> {\n    try {\n      const builder = new ContainerBuilder();\n\n      // Add mock services\n      for (const [token, mockService] of Object.entries(mockServices)) {\n        builder.addInstance(token, mockService);\n      }\n\n      // Add real services that aren't mocked\n      if (!mockServices[SERVICE_TOKENS.LOGGER]) {\n        builder.addInstance(SERVICE_TOKENS.LOGGER, logger);\n      }\n\n      if (!mockServices[SERVICE_TOKENS.EVENT_PUBLISHER]) {\n        builder.addSingleton(\n          SERVICE_TOKENS.EVENT_PUBLISHER,\n          () => new SimpleEventPublisher(),\n          []\n        );\n      }\n\n      // Domain Services (use real implementation with mocked dependencies)\n      if (!mockServices[SERVICE_TOKENS.CART_DOMAIN_SERVICE]) {\n        builder.addTransient(\n          SERVICE_TOKENS.CART_DOMAIN_SERVICE,\n          (container) => new CartDomainService(\n            container.resolve(SERVICE_TOKENS.CART_REPOSITORY),\n            container.resolve(SERVICE_TOKENS.PRODUCT_REPOSITORY),\n            container.resolve(SERVICE_TOKENS.USER_REPOSITORY),\n            container.resolve(SERVICE_TOKENS.EVENT_PUBLISHER)\n          ),\n          [\n            SERVICE_TOKENS.CART_REPOSITORY,\n            SERVICE_TOKENS.PRODUCT_REPOSITORY,\n            SERVICE_TOKENS.USER_REPOSITORY,\n            SERVICE_TOKENS.EVENT_PUBLISHER,\n          ]\n        );\n      }\n\n      return builder.build();\n    } catch (error) {\n      logger.error('Failed to configure test container', error);\n      return Result.error(new BusinessError('Test container configuration failed', { error }));\n    }\n  }\n}\n\n/**\n * Global container instances\n */\nlet serverContainer: Container | null = null;\nlet adminContainer: Container | null = null;\n\n/**\n * Get or create the server container\n */\nexport async function getServerContainer(): Promise<Container> {\n  if (!serverContainer) {\n    const result = ContainerConfiguration.configureServer();\n    if (result.isError()) {\n      throw new Error(`Failed to create server container: ${result.getError().message}`);\n    }\n    serverContainer = result.getValue();\n  }\n  return serverContainer;\n}\n\n/**\n * Get or create the admin container\n */\nexport async function getAdminContainer(): Promise<Container> {\n  if (!adminContainer) {\n    const result = ContainerConfiguration.configureAdmin();\n    if (result.isError()) {\n      throw new Error(`Failed to create admin container: ${result.getError().message}`);\n    }\n    adminContainer = result.getValue();\n  }\n  return adminContainer;\n}\n\n/**\n * Create a request-scoped container (useful for Next.js server actions)\n */\nexport async function createRequestScopedContainer(): Promise<{\n  container: Container;\n  scope: ReturnType<Container['createScope']>;\n}> {\n  const container = await getServerContainer();\n  const scope = container.createScope();\n  \n  return { container, scope };\n}\n\n/**\n * Utility function to resolve a service from the server container\n */\nexport async function resolveService<T>(token: string): Promise<T> {\n  const container = await getServerContainer();\n  return container.resolve<T>(token);\n}\n\n/**\n * Utility function to resolve a service from the admin container\n */\nexport async function resolveAdminService<T>(token: string): Promise<T> {\n  const container = await getAdminContainer();\n  return container.resolve<T>(token);\n}\n\n/**\n * Reset containers (useful for testing or hot reload)\n */\nexport function resetContainers(): void {\n  serverContainer = null;\n  adminContainer = null;\n  logger.info('Containers reset');\n}\n\n/**\n * Container health check\n */\nexport async function checkContainerHealth(): Promise<{\n  server: boolean;\n  admin: boolean;\n  errors: string[];\n}> {\n  const errors: string[] = [];\n  let serverHealthy = false;\n  let adminHealthy = false;\n\n  try {\n    const container = await getServerContainer();\n    const stats = container.getStatistics();\n    if (stats.totalServices > 0) {\n      serverHealthy = true;\n    }\n  } catch (error) {\n    errors.push(`Server container error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  try {\n    const container = await getAdminContainer();\n    const stats = container.getStatistics();\n    if (stats.totalServices > 0) {\n      adminHealthy = true;\n    }\n  } catch (error) {\n    errors.push(`Admin container error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  return {\n    server: serverHealthy,\n    admin: adminHealthy,\n    errors,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\container\\container.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[518,521],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[518,521],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[621,624],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[621,624],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[873,876],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[873,876],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1647,1650],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1647,1650],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3335,3338],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3335,3338],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":210,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4703,4706],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4703,4706],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":308,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":308,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6812,6815],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6812,6815],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resolutionStack' is defined but never used. Allowed unused args must match /^_/u.","line":351,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":351,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":375,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":375,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8754,8757],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8754,8757],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resolutionStack' is defined but never used. Allowed unused args must match /^_/u.","line":393,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":393,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'scopedInstances' is defined but never used. Allowed unused args must match /^_/u.","line":394,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":394,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":394,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":394,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9175,9178],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9175,9178],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Simple Dependency Injection Container\n * \n * Provides a lightweight IoC container for managing dependencies\n * without the complexity of full DI frameworks.\n */\n\nimport { Result } from \"@/lib/core/result\";\nimport { BusinessError } from \"@/lib/core/errors\";\nimport { logger } from \"@/lib/core/logger\";\n\n/**\n * Service lifetime types\n */\nexport enum ServiceLifetime {\n  SINGLETON = 'singleton',\n  TRANSIENT = 'transient',\n  SCOPED = 'scoped',\n}\n\n/**\n * Service factory function\n */\nexport type ServiceFactory<T = any> = (container: Container) => T;\n\n/**\n * Service registration\n */\ninterface ServiceRegistration<T = any> {\n  factory: ServiceFactory<T>;\n  lifetime: ServiceLifetime;\n  instance?: T;\n  dependencies?: string[];\n  tags?: string[];\n}\n\n/**\n * Container scope for scoped services\n */\nexport class ContainerScope {\n  private scopedInstances = new Map<string, any>();\n\n  constructor(private readonly container: Container) {}\n\n  resolve<T>(token: string): T {\n    return this.container.resolveInScope<T>(token, this.scopedInstances);\n  }\n\n  dispose(): void {\n    // Dispose all scoped instances that have a dispose method\n    for (const [token, instance] of this.scopedInstances) {\n      if (instance && typeof instance.dispose === 'function') {\n        try {\n          instance.dispose();\n        } catch (error) {\n          logger.warn(`Failed to dispose scoped service ${token}`, { error });\n        }\n      }\n    }\n    this.scopedInstances.clear();\n  }\n}\n\n/**\n * Dependency injection container\n */\nexport class Container {\n  private services = new Map<string, ServiceRegistration>();\n  private singletonInstances = new Map<string, any>();\n  private isBuilt = false;\n\n  /**\n   * Register a service with singleton lifetime\n   */\n  registerSingleton<T>(\n    token: string,\n    factory: ServiceFactory<T>,\n    dependencies: string[] = [],\n    tags: string[] = []\n  ): Container {\n    this.ensureNotBuilt();\n    \n    this.services.set(token, {\n      factory,\n      lifetime: ServiceLifetime.SINGLETON,\n      dependencies,\n      tags,\n    });\n\n    return this;\n  }\n\n  /**\n   * Register a service with transient lifetime\n   */\n  registerTransient<T>(\n    token: string,\n    factory: ServiceFactory<T>,\n    dependencies: string[] = [],\n    tags: string[] = []\n  ): Container {\n    this.ensureNotBuilt();\n    \n    this.services.set(token, {\n      factory,\n      lifetime: ServiceLifetime.TRANSIENT,\n      dependencies,\n      tags,\n    });\n\n    return this;\n  }\n\n  /**\n   * Register a service with scoped lifetime\n   */\n  registerScoped<T>(\n    token: string,\n    factory: ServiceFactory<T>,\n    dependencies: string[] = [],\n    tags: string[] = []\n  ): Container {\n    this.ensureNotBuilt();\n    \n    this.services.set(token, {\n      factory,\n      lifetime: ServiceLifetime.SCOPED,\n      dependencies,\n      tags,\n    });\n\n    return this;\n  }\n\n  /**\n   * Register a concrete instance\n   */\n  registerInstance<T>(token: string, instance: T, tags: string[] = []): Container {\n    this.ensureNotBuilt();\n    \n    this.services.set(token, {\n      factory: () => instance,\n      lifetime: ServiceLifetime.SINGLETON,\n      instance,\n      dependencies: [],\n      tags,\n    });\n\n    return this;\n  }\n\n  /**\n   * Register a service using a class constructor\n   */\n  registerClass<T>(\n    token: string,\n    constructor: new (...args: any[]) => T,\n    lifetime: ServiceLifetime = ServiceLifetime.TRANSIENT,\n    dependencies: string[] = [],\n    tags: string[] = []\n  ): Container {\n    this.ensureNotBuilt();\n    \n    const factory: ServiceFactory<T> = (container) => {\n      const deps = dependencies.map(dep => container.resolve(dep));\n      return new constructor(...deps);\n    };\n\n    this.services.set(token, {\n      factory,\n      lifetime,\n      dependencies,\n      tags,\n    });\n\n    return this;\n  }\n\n  /**\n   * Build the container (validates dependencies and prepares for resolution)\n   */\n  build(): Result<Container, BusinessError> {\n    try {\n      // Validate all dependencies\n      const validationResult = this.validateDependencies();\n      if (validationResult.isError()) {\n        return Result.error(validationResult.getError());\n      }\n\n      this.isBuilt = true;\n      logger.info('Container built successfully', { serviceCount: this.services.size });\n      \n      return Result.ok(this);\n    } catch (error) {\n      return Result.error(new BusinessError('Failed to build container', { error }));\n    }\n  }\n\n  /**\n   * Resolve a service by token\n   */\n  resolve<T>(token: string): T {\n    this.ensureBuilt();\n    return this.resolveInternal<T>(token, new Set());\n  }\n\n  /**\n   * Resolve a service within a scope\n   */\n  resolveInScope<T>(token: string, scopedInstances: Map<string, any>): T {\n    this.ensureBuilt();\n    return this.resolveInternal<T>(token, new Set(), scopedInstances);\n  }\n\n  /**\n   * Try to resolve a service (returns null if not found)\n   */\n  tryResolve<T>(token: string): T | null {\n    this.ensureBuilt();\n    \n    try {\n      return this.resolveInternal<T>(token, new Set());\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Check if a service is registered\n   */\n  isRegistered(token: string): boolean {\n    return this.services.has(token);\n  }\n\n  /**\n   * Get all services with a specific tag\n   */\n  getServicesByTag<T>(tag: string): T[] {\n    this.ensureBuilt();\n    \n    const services: T[] = [];\n    \n    for (const [token, registration] of this.services) {\n      if (registration.tags?.includes(tag)) {\n        services.push(this.resolve<T>(token));\n      }\n    }\n\n    return services;\n  }\n\n  /**\n   * Create a new scope\n   */\n  createScope(): ContainerScope {\n    this.ensureBuilt();\n    return new ContainerScope(this);\n  }\n\n  /**\n   * Get container statistics\n   */\n  getStatistics(): {\n    totalServices: number;\n    singletonServices: number;\n    transientServices: number;\n    scopedServices: number;\n    singletonInstances: number;\n  } {\n    const stats = {\n      totalServices: this.services.size,\n      singletonServices: 0,\n      transientServices: 0,\n      scopedServices: 0,\n      singletonInstances: this.singletonInstances.size,\n    };\n\n    for (const registration of this.services.values()) {\n      switch (registration.lifetime) {\n        case ServiceLifetime.SINGLETON:\n          stats.singletonServices++;\n          break;\n        case ServiceLifetime.TRANSIENT:\n          stats.transientServices++;\n          break;\n        case ServiceLifetime.SCOPED:\n          stats.scopedServices++;\n          break;\n      }\n    }\n\n    return stats;\n  }\n\n  /**\n   * Clear all singleton instances (for testing)\n   */\n  clearSingletons(): void {\n    this.singletonInstances.clear();\n  }\n\n  /**\n   * Internal resolution method\n   */\n  private resolveInternal<T>(\n    token: string,\n    resolutionStack: Set<string>,\n    scopedInstances?: Map<string, any>\n  ): T {\n    // Check for circular dependencies\n    if (resolutionStack.has(token)) {\n      const cycle = Array.from(resolutionStack).join(' -> ') + ' -> ' + token;\n      throw new BusinessError(`Circular dependency detected: ${cycle}`);\n    }\n\n    const registration = this.services.get(token);\n    if (!registration) {\n      throw new BusinessError(`Service '${token}' is not registered`);\n    }\n\n    resolutionStack.add(token);\n\n    try {\n      switch (registration.lifetime) {\n        case ServiceLifetime.SINGLETON:\n          return this.resolveSingleton<T>(token, registration, resolutionStack);\n          \n        case ServiceLifetime.SCOPED:\n          if (!scopedInstances) {\n            throw new BusinessError(`Scoped service '${token}' requested outside of scope`);\n          }\n          return this.resolveScoped<T>(token, registration, resolutionStack, scopedInstances);\n          \n        case ServiceLifetime.TRANSIENT:\n          return this.resolveTransient<T>(token, registration, resolutionStack, scopedInstances);\n          \n        default:\n          throw new BusinessError(`Unknown service lifetime: ${registration.lifetime}`);\n      }\n    } finally {\n      resolutionStack.delete(token);\n    }\n  }\n\n  /**\n   * Resolve singleton service\n   */\n  private resolveSingleton<T>(\n    token: string,\n    registration: ServiceRegistration<T>,\n    resolutionStack: Set<string>\n  ): T {\n    if (registration.instance) {\n      return registration.instance;\n    }\n\n    if (this.singletonInstances.has(token)) {\n      return this.singletonInstances.get(token);\n    }\n\n    const instance = registration.factory(this);\n    this.singletonInstances.set(token, instance);\n    registration.instance = instance;\n\n    return instance;\n  }\n\n  /**\n   * Resolve scoped service\n   */\n  private resolveScoped<T>(\n    token: string,\n    registration: ServiceRegistration<T>,\n    resolutionStack: Set<string>,\n    scopedInstances: Map<string, any>\n  ): T {\n    if (scopedInstances.has(token)) {\n      return scopedInstances.get(token);\n    }\n\n    const instance = registration.factory(this);\n    scopedInstances.set(token, instance);\n\n    return instance;\n  }\n\n  /**\n   * Resolve transient service\n   */\n  private resolveTransient<T>(\n    token: string,\n    registration: ServiceRegistration<T>,\n    resolutionStack: Set<string>,\n    scopedInstances?: Map<string, any>\n  ): T {\n    return registration.factory(this);\n  }\n\n  /**\n   * Validate all dependencies\n   */\n  private validateDependencies(): Result<void, BusinessError> {\n    for (const [token, registration] of this.services) {\n      if (registration.dependencies) {\n        for (const dependency of registration.dependencies) {\n          if (!this.services.has(dependency)) {\n            return Result.error(new BusinessError(\n              `Service '${token}' depends on '${dependency}' which is not registered`\n            ));\n          }\n        }\n      }\n\n      // Check for circular dependencies\n      const visited = new Set<string>();\n      const recursionStack = new Set<string>();\n      \n      if (this.hasCircularDependency(token, visited, recursionStack)) {\n        return Result.error(new BusinessError(\n          `Circular dependency detected for service '${token}'`\n        ));\n      }\n    }\n\n    return Result.ok(undefined);\n  }\n\n  /**\n   * Check for circular dependencies using DFS\n   */\n  private hasCircularDependency(\n    token: string,\n    visited: Set<string>,\n    recursionStack: Set<string>\n  ): boolean {\n    if (recursionStack.has(token)) {\n      return true;\n    }\n\n    if (visited.has(token)) {\n      return false;\n    }\n\n    visited.add(token);\n    recursionStack.add(token);\n\n    const registration = this.services.get(token);\n    if (registration?.dependencies) {\n      for (const dependency of registration.dependencies) {\n        if (this.hasCircularDependency(dependency, visited, recursionStack)) {\n          return true;\n        }\n      }\n    }\n\n    recursionStack.delete(token);\n    return false;\n  }\n\n  /**\n   * Ensure container is not built (for registration methods)\n   */\n  private ensureNotBuilt(): void {\n    if (this.isBuilt) {\n      throw new BusinessError('Cannot register services after container is built');\n    }\n  }\n\n  /**\n   * Ensure container is built (for resolution methods)\n   */\n  private ensureBuilt(): void {\n    if (!this.isBuilt) {\n      throw new BusinessError('Container must be built before resolving services');\n    }\n  }\n}\n\n/**\n * Service tokens (string constants for type safety)\n */\nexport const SERVICE_TOKENS = {\n  // Infrastructure\n  SUPABASE_CLIENT: 'SupabaseClient',\n  \n  // Repositories\n  CART_REPOSITORY: 'CartRepository',\n  PRODUCT_REPOSITORY: 'ProductRepository',\n  USER_REPOSITORY: 'UserRepository',\n  ADDRESS_REPOSITORY: 'AddressRepository',\n  ORDER_REPOSITORY: 'OrderRepository',\n  ARTICLE_REPOSITORY: 'ArticleRepository',\n  \n  // Domain Services\n  CART_DOMAIN_SERVICE: 'CartDomainService',\n  \n  // Event System\n  EVENT_PUBLISHER: 'EventPublisher',\n  EVENT_BUS: 'EventBus',\n  EVENT_STORE: 'EventStore',\n  EVENT_PROCESSOR: 'EventProcessor',\n  \n  // Event Handlers\n  CART_EVENT_HANDLER: 'CartEventHandler',\n  ORDER_EVENT_HANDLER: 'OrderEventHandler',\n  USER_EVENT_HANDLER: 'UserEventHandler',\n  INVENTORY_EVENT_HANDLER: 'InventoryEventHandler',\n  NOTIFICATION_EVENT_HANDLER: 'NotificationEventHandler',\n  AUDIT_EVENT_HANDLER: 'AuditEventHandler',\n  \n  // Event Listeners (Aggregate Handlers)\n  CART_EVENT_LISTENER: 'CartEventListener',\n  ORDER_WORKFLOW_EVENT_LISTENER: 'OrderWorkflowEventListener',\n  NOTIFICATION_EVENT_LISTENER: 'NotificationEventListener',\n  AUDIT_EVENT_LISTENER: 'AuditEventListener',\n  \n  // Event System\n  EVENT_SYSTEM_INITIALIZER: 'EventSystemInitializer',\n  \n  // Infrastructure Services\n  LOGGER: 'Logger',\n  \n  // External Services\n  EMAIL_SERVICE: 'EmailService',\n  PAYMENT_SERVICE: 'PaymentService',\n} as const;\n\n/**\n * Container builder for easier configuration\n */\nexport class ContainerBuilder {\n  private container = new Container();\n\n  /**\n   * Add singleton service\n   */\n  addSingleton<T>(\n    token: string,\n    factory: ServiceFactory<T>,\n    dependencies: string[] = []\n  ): ContainerBuilder {\n    this.container.registerSingleton(token, factory, dependencies);\n    return this;\n  }\n\n  /**\n   * Add transient service\n   */\n  addTransient<T>(\n    token: string,\n    factory: ServiceFactory<T>,\n    dependencies: string[] = []\n  ): ContainerBuilder {\n    this.container.registerTransient(token, factory, dependencies);\n    return this;\n  }\n\n  /**\n   * Add scoped service\n   */\n  addScoped<T>(\n    token: string,\n    factory: ServiceFactory<T>,\n    dependencies: string[] = []\n  ): ContainerBuilder {\n    this.container.registerScoped(token, factory, dependencies);\n    return this;\n  }\n\n  /**\n   * Add instance\n   */\n  addInstance<T>(token: string, instance: T): ContainerBuilder {\n    this.container.registerInstance(token, instance);\n    return this;\n  }\n\n  /**\n   * Build the container\n   */\n  build(): Result<Container, BusinessError> {\n    return this.container.build();\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\__tests__\\event-container-integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":55,"column":33,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":55,"endColumn":76},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":67,"column":15,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":67,"endColumn":47},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":111,"column":15,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":111,"endColumn":47},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":266,"column":15,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":266,"endColumn":47}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Event Container Integration Tests\n * \n * Tests spécifiques pour l'intégration de l'architecture Event-Driven\n * avec le Container DI et l'initialisation du système.\n */\n\nimport { ContainerConfiguration } from '../../container/container.config';\nimport { SERVICE_TOKENS } from '../../container/container';\nimport { configureEventSystem, initializeEventSystem, checkEventSystemHealth } from '../event-container-config';\nimport { ContainerBuilder } from '../../container/container';\nimport type { EventBus, EventStore } from '@/lib/core/events';\n\n// Mock environment variables\nprocess.env.STRIPE_SECRET_KEY = 'sk_test_mock';\n\n// Mock des clients Supabase\njest.mock('@/lib/supabase/server', () => ({\n  createSupabaseServerClient: jest.fn().mockReturnValue({\n    from: jest.fn(() => ({\n      select: jest.fn(),\n      insert: jest.fn().mockResolvedValue({ error: null }),\n      update: jest.fn(),\n      delete: jest.fn(),\n      eq: jest.fn(),\n      order: jest.fn(),\n      limit: jest.fn(),\n      single: jest.fn(),\n    })),\n    rpc: jest.fn().mockResolvedValue({ error: null }),\n    auth: {\n      getUser: jest.fn(),\n    },\n  }),\n}));\n\njest.mock('@/lib/supabase/server-admin', () => ({\n  createSupabaseAdminClient: jest.fn().mockReturnValue({\n    from: jest.fn(() => ({\n      select: jest.fn(),\n      insert: jest.fn().mockResolvedValue({ error: null }),\n      update: jest.fn(),\n      delete: jest.fn(),\n      eq: jest.fn(),\n      order: jest.fn(),\n      limit: jest.fn(),\n      single: jest.fn(),\n    })),\n    rpc: jest.fn().mockResolvedValue({ error: null }),\n  }),\n}));\n\ndescribe('Event Container Integration Tests', () => {\n  beforeEach(() => {\n    const { resetContainers } = require('../../container/container.config');\n    resetContainers();\n    jest.clearAllMocks();\n  });\n\n  describe('Event System Container Configuration', () => {\n    it('should configure all event system components', () => {\n      const builder = new ContainerBuilder();\n      \n      // Ajouter les services de base nécessaires\n      builder.addSingleton(\n        SERVICE_TOKENS.SUPABASE_CLIENT,\n        () => require('@/lib/supabase/server').createSupabaseServerClient(),\n        []\n      );\n      \n      builder.addInstance(SERVICE_TOKENS.LOGGER, console);\n\n      // Configurer le système d'événements\n      configureEventSystem(builder);\n\n      const containerResult = builder.build();\n      expect(containerResult.isSuccess()).toBe(true);\n\n      if (containerResult.isSuccess()) {\n        const container = containerResult.getValue();\n\n        // Vérifier l'infrastructure événementielle\n        expect(() => container.resolve(SERVICE_TOKENS.EVENT_BUS)).not.toThrow();\n        expect(() => container.resolve(SERVICE_TOKENS.EVENT_STORE)).not.toThrow();\n        expect(() => container.resolve(SERVICE_TOKENS.EVENT_PUBLISHER)).not.toThrow();\n\n        // Vérifier les handlers\n        expect(() => container.resolve(SERVICE_TOKENS.CART_EVENT_HANDLER)).not.toThrow();\n        expect(() => container.resolve(SERVICE_TOKENS.ORDER_EVENT_HANDLER)).not.toThrow();\n        expect(() => container.resolve(SERVICE_TOKENS.USER_EVENT_HANDLER)).not.toThrow();\n        expect(() => container.resolve(SERVICE_TOKENS.INVENTORY_EVENT_HANDLER)).not.toThrow();\n        expect(() => container.resolve(SERVICE_TOKENS.NOTIFICATION_EVENT_HANDLER)).not.toThrow();\n        expect(() => container.resolve(SERVICE_TOKENS.AUDIT_EVENT_HANDLER)).not.toThrow();\n\n        // Vérifier les listeners\n        expect(() => container.resolve(SERVICE_TOKENS.CART_EVENT_LISTENER)).not.toThrow();\n        expect(() => container.resolve(SERVICE_TOKENS.ORDER_WORKFLOW_EVENT_LISTENER)).not.toThrow();\n        expect(() => container.resolve(SERVICE_TOKENS.NOTIFICATION_EVENT_LISTENER)).not.toThrow();\n        expect(() => container.resolve(SERVICE_TOKENS.AUDIT_EVENT_LISTENER)).not.toThrow();\n\n        // Vérifier l'initializer\n        expect(() => container.resolve(SERVICE_TOKENS.EVENT_SYSTEM_INITIALIZER)).not.toThrow();\n      }\n    });\n\n    it('should have correct dependency graph', () => {\n      const builder = new ContainerBuilder();\n      \n      builder.addSingleton(\n        SERVICE_TOKENS.SUPABASE_CLIENT,\n        () => require('@/lib/supabase/server').createSupabaseServerClient(),\n        []\n      );\n      \n      builder.addInstance(SERVICE_TOKENS.LOGGER, console);\n\n      configureEventSystem(builder);\n\n      const containerResult = builder.build();\n      expect(containerResult.isSuccess()).toBe(true);\n\n      if (containerResult.isSuccess()) {\n        const container = containerResult.getValue();\n\n        // Vérifier que les dépendances sont correctement résolues\n        const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n        const eventStore = container.resolve<EventStore>(SERVICE_TOKENS.EVENT_STORE);\n        const eventPublisher = container.resolve(SERVICE_TOKENS.EVENT_PUBLISHER);\n\n        expect(eventBus).toBeDefined();\n        expect(eventStore).toBeDefined();\n        expect(eventPublisher).toBeDefined();\n\n        // Vérifier que l'EventPublisher utilise bien l'EventBus\n        expect(eventPublisher).toBe(eventBus);\n      }\n    });\n  });\n\n  describe('Event System Initialization', () => {\n    it('should initialize event system successfully', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n\n      if (result.isSuccess()) {\n        const container = result.getValue();\n\n        // Initialiser le système d'événements\n        await expect(initializeEventSystem(container)).resolves.not.toThrow();\n\n        // Vérifier que l'EventBus a des souscriptions\n        const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n        const stats = eventBus.getStatistics();\n\n        expect(stats.subscribedHandlers).toBeGreaterThan(0);\n        expect(stats.eventTypes.length).toBeGreaterThan(0);\n\n        // Vérifier des souscriptions spécifiques\n        expect(stats.handlersByType['CART_ITEM_ADDED']).toBeGreaterThan(0);\n        expect(stats.handlersByType['ORDER_CREATED']).toBeGreaterThan(0);\n        expect(stats.handlersByType['USER_REGISTERED']).toBeGreaterThan(0);\n      }\n    });\n\n    it('should register all expected event subscriptions', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n\n      if (result.isSuccess()) {\n        const container = result.getValue();\n        await initializeEventSystem(container);\n\n        const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n        const stats = eventBus.getStatistics();\n\n        // Vérifier que tous les événements métier principaux sont souscrits\n        const expectedEvents = [\n          'CART_ITEM_ADDED',\n          'CART_ITEM_REMOVED', \n          'CART_ITEM_QUANTITY_UPDATED',\n          'CART_CLEARED',\n          'ORDER_CREATED',\n          'ORDER_CONFIRMED',\n          'ORDER_SHIPPED',\n          'ORDER_DELIVERED',\n          'ORDER_CANCELLED',\n          'USER_REGISTERED',\n          'USER_PROFILE_UPDATED',\n          'PRODUCT_STOCK_UPDATED',\n          'PRODUCT_PRICE_CHANGED'\n        ];\n\n        for (const eventType of expectedEvents) {\n          expect(stats.handlersByType[eventType]).toBeGreaterThan(0);\n        }\n\n        // Vérifier le nombre total d'événements\n        expect(stats.eventTypes.length).toBeGreaterThanOrEqual(expectedEvents.length);\n      }\n    });\n\n    it('should handle initialization errors gracefully', async () => {\n      // Créer un container avec un service manquant pour provoquer une erreur\n      const builder = new ContainerBuilder();\n      \n      // Ne pas ajouter SUPABASE_CLIENT intentionnellement\n      builder.addInstance(SERVICE_TOKENS.LOGGER, console);\n      \n      // Essayer de configurer le système sans toutes les dépendances\n      configureEventSystem(builder);\n      \n      const containerResult = builder.build();\n      \n      // Le build devrait échouer à cause des dépendances manquantes\n      expect(containerResult.isError()).toBe(true);\n    });\n  });\n\n  describe('Event System Health Check', () => {\n    it('should provide comprehensive health check', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n\n      if (result.isSuccess()) {\n        const container = result.getValue();\n        await initializeEventSystem(container);\n\n        const health = await checkEventSystemHealth(container);\n\n        // Vérifier la structure du health check\n        expect(health).toHaveProperty('eventBus');\n        expect(health).toHaveProperty('eventStore');\n        expect(health).toHaveProperty('handlers');\n        expect(health).toHaveProperty('listeners');\n        expect(health).toHaveProperty('errors');\n\n        // Vérifier que les composants principaux sont sains\n        expect(health.eventBus).toBe(true);\n        expect(health.eventStore).toBe(true);\n\n        // Vérifier les handlers\n        expect(health.handlers['CART_EVENT_HANDLER']).toBe(true);\n        expect(health.handlers['ORDER_EVENT_HANDLER']).toBe(true);\n        expect(health.handlers['USER_EVENT_HANDLER']).toBe(true);\n        expect(health.handlers['INVENTORY_EVENT_HANDLER']).toBe(true);\n        expect(health.handlers['NOTIFICATION_EVENT_HANDLER']).toBe(true);\n        expect(health.handlers['AUDIT_EVENT_HANDLER']).toBe(true);\n\n        // Vérifier les listeners\n        expect(health.listeners['CART_EVENT_LISTENER']).toBe(true);\n        expect(health.listeners['ORDER_WORKFLOW_EVENT_LISTENER']).toBe(true);\n        expect(health.listeners['NOTIFICATION_EVENT_LISTENER']).toBe(true);\n        expect(health.listeners['AUDIT_EVENT_LISTENER']).toBe(true);\n\n        // Pas d'erreurs\n        expect(health.errors).toHaveLength(0);\n      }\n    });\n\n    it('should detect and report unhealthy components', async () => {\n      // Créer un container avec certains services défaillants\n      const builder = new ContainerBuilder();\n      \n      builder.addSingleton(\n        SERVICE_TOKENS.SUPABASE_CLIENT,\n        () => require('@/lib/supabase/server').createSupabaseServerClient(),\n        []\n      );\n      \n      builder.addInstance(SERVICE_TOKENS.LOGGER, console);\n\n      // Ajouter un handler défaillant pour tester la détection d'erreur\n      builder.addSingleton(\n        SERVICE_TOKENS.CART_EVENT_HANDLER,\n        () => { throw new Error('Simulated handler failure'); },\n        []\n      );\n\n      const containerResult = builder.build();\n      \n      if (containerResult.isSuccess()) {\n        const container = containerResult.getValue();\n        \n        // Le health check devrait détecter le problème\n        const health = await checkEventSystemHealth(container);\n        \n        expect(health.handlers['CART_EVENT_HANDLER']).toBe(false);\n        expect(health.errors.length).toBeGreaterThan(0);\n        \n        const cartHandlerError = health.errors.find(e => e.includes('CART_EVENT_HANDLER'));\n        expect(cartHandlerError).toBeDefined();\n      }\n    });\n  });\n\n  describe('Container Scoped Services', () => {\n    it('should support scoped event processing', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n\n      if (result.isSuccess()) {\n        const container = result.getValue();\n        \n        // Créer un scope pour simuler une requête\n        const scope = container.createScope();\n        \n        // Résoudre les services dans le scope\n        const eventBus = scope.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n        const cartListener = scope.resolve(SERVICE_TOKENS.CART_EVENT_LISTENER);\n        \n        expect(eventBus).toBeDefined();\n        expect(cartListener).toBeDefined();\n        \n        // Nettoyer le scope\n        scope.dispose();\n      }\n    });\n  });\n\n  describe('Event System Integration with Existing Services', () => {\n    it('should integrate with cart domain service', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n\n      if (result.isSuccess()) {\n        const container = result.getValue();\n        \n        // Vérifier que le CartDomainService utilise l'EventPublisher\n        const cartDomainService = container.resolve(SERVICE_TOKENS.CART_DOMAIN_SERVICE);\n        const eventPublisher = container.resolve(SERVICE_TOKENS.EVENT_PUBLISHER);\n        \n        expect(cartDomainService).toBeDefined();\n        expect(eventPublisher).toBeDefined();\n        \n        // Le service devrait avoir accès à l'event publisher\n        // (vérification indirecte via l'absence d'erreur lors de la résolution)\n      }\n    });\n\n    it('should work with repository pattern', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n\n      if (result.isSuccess()) {\n        const container = result.getValue();\n        \n        // Vérifier que les repositories et les event handlers coexistent\n        const cartRepository = container.resolve(SERVICE_TOKENS.CART_REPOSITORY);\n        const productRepository = container.resolve(SERVICE_TOKENS.PRODUCT_REPOSITORY);\n        const cartEventHandler = container.resolve(SERVICE_TOKENS.CART_EVENT_HANDLER);\n        const inventoryEventHandler = container.resolve(SERVICE_TOKENS.INVENTORY_EVENT_HANDLER);\n        \n        expect(cartRepository).toBeDefined();\n        expect(productRepository).toBeDefined();\n        expect(cartEventHandler).toBeDefined();\n        expect(inventoryEventHandler).toBeDefined();\n      }\n    });\n  });\n\n  describe('Event System Statistics and Monitoring', () => {\n    it('should provide detailed statistics', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n\n      if (result.isSuccess()) {\n        const container = result.getValue();\n        await initializeEventSystem(container);\n\n        const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n        const containerStats = container.getStatistics();\n        const busStats = eventBus.getStatistics();\n\n        // Vérifier les statistiques du container\n        expect(containerStats.totalServices).toBeGreaterThan(20);\n        expect(containerStats.singletonServices).toBeGreaterThan(15);\n\n        // Vérifier les statistiques de l'event bus\n        expect(busStats.subscribedHandlers).toBeGreaterThan(10);\n        expect(busStats.eventTypes.length).toBeGreaterThan(10);\n        expect(Object.keys(busStats.handlersByType).length).toBeGreaterThan(10);\n\n        console.log('Container Stats:', containerStats);\n        console.log('Event Bus Stats:', busStats);\n      }\n    });\n  });\n});\n\n/**\n * Ces tests valident que :\n * \n * 1. ✅ Le système d'événements s'intègre correctement avec le Container DI\n * 2. ✅ Tous les composants événementiels sont enregistrés et résolus\n * 3. ✅ L'initialisation du système configure toutes les souscriptions\n * 4. ✅ Le health check détecte les composants défaillants\n * 5. ✅ Les services scopés fonctionnent avec les événements\n * 6. ✅ L'intégration avec les services métier existants est fonctionnelle\n * 7. ✅ Les statistiques et le monitoring sont opérationnels\n * 8. ✅ La gestion d'erreur lors de l'initialisation fonctionne\n */","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\__tests__\\event-listeners-integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EventCorrelation' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DomainEvent' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1154,1157],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1154,1157],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":42,"column":33,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":42,"endColumn":76},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cartListener' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":95,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":95,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Event Listeners Integration Tests\n * \n * Tests spécifiques pour l'orchestration des Event Listeners\n * et leur coordination avec les Event Handlers.\n */\n\nimport { ContainerConfiguration } from '../../container/container.config';\nimport { SERVICE_TOKENS } from '../../container/container';\nimport { initializeEventSystem } from '../event-container-config';\nimport { EventFactory, EventCorrelation } from '@/lib/core/events';\nimport type { DomainEvent, EventBus } from '@/lib/core/events';\n\n// Mock environment variables\nprocess.env.STRIPE_SECRET_KEY = 'sk_test_mock';\n\n// Mock des clients Supabase\njest.mock('@/lib/supabase/server', () => ({\n  createSupabaseServerClient: jest.fn().mockReturnValue({\n    from: jest.fn(() => ({\n      select: jest.fn(),\n      insert: jest.fn().mockResolvedValue({ error: null }),\n      update: jest.fn(),\n      delete: jest.fn(),\n      eq: jest.fn(),\n      order: jest.fn(),\n      limit: jest.fn(),\n      single: jest.fn(),\n    })),\n    rpc: jest.fn().mockResolvedValue({ error: null }),\n    auth: {\n      getUser: jest.fn(),\n    },\n  }),\n}));\n\ndescribe('Event Listeners Integration Tests', () => {\n  let container: any;\n  let eventBus: EventBus;\n\n  beforeEach(async () => {\n    const { resetContainers } = require('../../container/container.config');\n    resetContainers();\n    jest.clearAllMocks();\n\n    const result = ContainerConfiguration.configureServer();\n    expect(result.isSuccess()).toBe(true);\n    \n    container = result.getValue();\n    await initializeEventSystem(container);\n    \n    eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n  });\n\n  describe('Cart Event Listener Orchestration', () => {\n    it('should coordinate cart item added event across multiple handlers', async () => {\n      const cartListener = container.resolve(SERVICE_TOKENS.CART_EVENT_LISTENER);\n\n      // Vérifier que le listener est bien configuré\n      expect(cartListener).toBeDefined();\n      expect(typeof cartListener.handleCartItemAdded).toBe('function');\n\n      // Créer un événement d'ajout au panier\n      const cartEvent = EventFactory.create(\n        'CART_ITEM_ADDED',\n        'cart_123',\n        'cart',\n        {\n          productId: 'product_456',\n          quantity: 2,\n          userId: 'user_789',\n          cartId: 'cart_123', \n          productName: 'Test Product',\n          productPrice: 25.99,\n        }\n      );\n\n      // Publier l'événement\n      const result_publish = await eventBus.publish(cartEvent);\n      expect(result_publish.isSuccess()).toBe(true);\n\n      // Le listener devrait orchestrer :\n      // - CartEventHandler pour persister l'action\n      // - InventoryEventHandler pour réserver le stock\n      // - NotificationEventHandler pour notifier l'utilisateur\n      // - AuditEventHandler pour traçabilité\n    });\n\n    it('should handle cart item removal orchestration', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n      const cartListener = container.resolve(SERVICE_TOKENS.CART_EVENT_LISTENER);\n\n      const cartRemovalEvent = EventFactory.create(\n        'CART_ITEM_REMOVED',\n        'cart_123',\n        'cart',\n        {\n          productId: 'product_456',\n          quantity: 1,\n          userId: 'user_789',\n          cartId: 'cart_123',\n          itemId: 'item_789',\n          reason: 'user_action'\n        }\n      );\n\n      const publishResult = await eventBus.publish(cartRemovalEvent);\n      expect(publishResult.isSuccess()).toBe(true);\n    });\n\n    it('should handle cart quantity updates', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n\n      const quantityUpdateEvent = EventFactory.create(\n        'CART_ITEM_QUANTITY_UPDATED',\n        'cart_123',\n        'cart',\n        {\n          productId: 'product_456',\n          oldQuantity: 2,\n          newQuantity: 3,\n          userId: 'user_789',\n          cartId: 'cart_123',\n          itemId: 'item_789'\n        }\n      );\n\n      const publishResult = await eventBus.publish(quantityUpdateEvent);\n      expect(publishResult.isSuccess()).toBe(true);\n    });\n  });\n\n  describe('Order Workflow Listener Orchestration', () => {\n    it('should orchestrate complete order creation workflow', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n      const orderWorkflowListener = container.resolve(SERVICE_TOKENS.ORDER_WORKFLOW_EVENT_LISTENER);\n\n      expect(orderWorkflowListener).toBeDefined();\n      expect(typeof orderWorkflowListener.handleOrderCreated).toBe('function');\n\n      const orderCreatedEvent = EventFactory.create(\n        'ORDER_CREATED',\n        'order_456',\n        'order',\n        {\n          orderId: 'order_456',\n          userId: 'user_789',\n          items: [\n            {\n              productId: 'product_123',\n              quantity: 2,\n              price: 29.99,\n              productName: 'Premium Product'\n            }\n          ],\n          totalAmount: 59.98,\n          currency: 'EUR',\n          shippingAddress: {\n            street: '123 Test Street',\n            city: 'Paris',\n            postalCode: '75001',\n            country: 'France'\n          },\n          paymentMethod: 'stripe'\n        }\n      );\n\n      const publishResult = await eventBus.publish(orderCreatedEvent);\n      expect(publishResult.isSuccess()).toBe(true);\n\n      // Le OrderWorkflowListener devrait orchestrer :\n      // - OrderEventHandler pour persister la commande\n      // - InventoryEventHandler pour confirmer/réserver le stock\n      // - NotificationEventHandler pour email de confirmation\n      // - AuditEventHandler pour traçabilité complète\n    });\n\n    it('should handle order status updates', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n\n      const orderConfirmedEvent = EventFactory.create(\n        'ORDER_CONFIRMED',\n        'order_456',\n        'order',\n        {\n          orderId: 'order_456',\n          userId: 'user_789',\n          confirmationNumber: 'CONF_123456',\n          estimatedDelivery: '2025-08-05',\n          trackingNumber: 'TRACK_789456'\n        }\n      );\n\n      const publishResult = await eventBus.publish(orderConfirmedEvent);\n      expect(publishResult.isSuccess()).toBe(true);\n    });\n\n    it('should handle order cancellation workflow', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n\n      const orderCancelledEvent = EventFactory.create(\n        'ORDER_CANCELLED',\n        'order_456',\n        'order',\n        {\n          orderId: 'order_456',\n          userId: 'user_789',\n          reason: 'customer_request',\n          refundAmount: 59.98,\n          refundMethod: 'stripe_refund'\n        }\n      );\n\n      const publishResult = await eventBus.publish(orderCancelledEvent);\n      expect(publishResult.isSuccess()).toBe(true);\n    });\n  });\n\n  describe('Notification Event Listener Orchestration', () => {\n    it('should coordinate user registration notifications', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n      const notificationListener = container.resolve(SERVICE_TOKENS.NOTIFICATION_EVENT_LISTENER);\n\n      expect(notificationListener).toBeDefined();\n      expect(typeof notificationListener.handleUserRegistered).toBe('function');\n\n      const userRegisteredEvent = EventFactory.create(\n        'USER_REGISTERED',\n        'user_789',\n        'user',\n        {\n          userId: 'user_789',\n          email: 'test@example.com',\n          firstName: 'Jean',\n          lastName: 'Dupont',\n          registrationSource: 'website',\n          locale: 'fr',\n          marketingOptIn: true\n        }\n      );\n\n      const publishResult = await eventBus.publish(userRegisteredEvent);\n      expect(publishResult.isSuccess()).toBe(true);\n\n      // Le NotificationListener devrait orchestrer :\n      // - NotificationEventHandler pour email de bienvenue\n      // - UserEventHandler pour finaliser le profil\n      // - AuditEventHandler pour traçabilité\n    });\n\n    it('should handle user profile updates', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n\n      const profileUpdateEvent = EventFactory.create(\n        'USER_PROFILE_UPDATED',\n        'user_789',\n        'user',\n        {\n          userId: 'user_789',\n          updatedFields: ['firstName', 'phone'],\n          oldValues: { firstName: 'Jean', phone: null },\n          newValues: { firstName: 'Jean-Pierre', phone: '+33123456789' },\n          updateSource: 'profile_page'\n        }\n      );\n\n      const publishResult = await eventBus.publish(profileUpdateEvent);\n      expect(publishResult.isSuccess()).toBe(true);\n    });\n  });\n\n  describe('Audit Event Listener', () => {\n    it('should ensure comprehensive audit trail for all events', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n      const auditListener = container.resolve(SERVICE_TOKENS.AUDIT_EVENT_LISTENER);\n\n      expect(auditListener).toBeDefined();\n      expect(typeof auditListener.handleAuditEvent).toBe('function');\n\n      // Publier plusieurs types d'événements pour vérifier l'audit\n      const events = [\n        EventFactory.create('CART_ITEM_ADDED', 'cart_1', 'cart', { productId: 'p1', userId: 'u1' }),\n        EventFactory.create('ORDER_CREATED', 'order_1', 'order', { orderId: 'order_1', userId: 'u1' }),\n        EventFactory.create('USER_REGISTERED', 'user_1', 'user', { userId: 'user_1', email: 'test@example.com' }),\n        EventFactory.create('PRODUCT_STOCK_UPDATED', 'product_1', 'product', { productId: 'product_1', oldStock: 10, newStock: 8 })\n      ];\n\n      for (const event of events) {\n        const publishResult = await eventBus.publish(event);\n        expect(publishResult.isSuccess()).toBe(true);\n      }\n\n      // Tous les événements devraient être audités par l'AuditListener\n    });\n  });\n\n  describe('Inventory Event Integration', () => {\n    it('should handle product stock updates', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n\n      const stockUpdateEvent = EventFactory.create(\n        'PRODUCT_STOCK_UPDATED',\n        'product_123',\n        'product',\n        {\n          productId: 'product_123',\n          oldStock: 10,\n          newStock: 8,\n          reason: 'sale',\n          orderId: 'order_456',\n          userId: 'user_789'\n        }\n      );\n\n      const publishResult = await eventBus.publish(stockUpdateEvent);\n      expect(publishResult.isSuccess()).toBe(true);\n    });\n\n    it('should handle product price changes', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n\n      const priceChangeEvent = EventFactory.create(\n        'PRODUCT_PRICE_CHANGED',\n        'product_123',\n        'product',\n        {\n          productId: 'product_123',\n          oldPrice: 29.99,\n          newPrice: 24.99,\n          reason: 'promotion',\n          effectiveDate: '2025-07-30T00:00:00Z',\n          promotionId: 'PROMO_SUMMER2025'\n        }\n      );\n\n      const publishResult = await eventBus.publish(priceChangeEvent);\n      expect(publishResult.isSuccess()).toBe(true);\n    });\n  });\n\n  describe('Error Handling and Resilience', () => {\n    it('should handle partial listener failures gracefully', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n\n      // Créer un événement qui pourrait causer des erreurs dans certains handlers\n      const problematicEvent = EventFactory.create(\n        'CART_ITEM_ADDED',\n        'cart_error',\n        'cart',\n        {\n          // Données partiellement invalides\n          productId: 'nonexistent_product',\n          quantity: 999999, // Stock insuffisant potentiel\n          userId: 'user_789',\n          cartId: 'cart_error'\n        }\n      );\n\n      // L'événement devrait être publié même si certains handlers échouent\n      const publishResult = await eventBus.publish(problematicEvent);\n      \n      // Le système devrait être résilient\n      expect(publishResult.isSuccess() || publishResult.isError()).toBe(true);\n    });\n\n    it('should maintain event ordering for same aggregate', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n\n      const cartId = 'cart_sequence_test';\n\n      // Séquence d'événements pour le même panier\n      const sequentialEvents = [\n        EventFactory.create('CART_ITEM_ADDED', cartId, 'cart', { productId: 'p1', quantity: 1, userId: 'u1', cartId }),\n        EventFactory.create('CART_ITEM_ADDED', cartId, 'cart', { productId: 'p2', quantity: 2, userId: 'u1', cartId }),\n        EventFactory.create('CART_ITEM_QUANTITY_UPDATED', cartId, 'cart', { productId: 'p1', oldQuantity: 1, newQuantity: 3, userId: 'u1', cartId }),\n        EventFactory.create('CART_ITEM_REMOVED', cartId, 'cart', { productId: 'p2', quantity: 2, userId: 'u1', cartId }),\n      ];\n\n      // Publier les événements en séquence\n      for (const event of sequentialEvents) {\n        const publishResult = await eventBus.publish(event);\n        expect(publishResult.isSuccess()).toBe(true);\n      }\n    });\n  });\n\n  describe('Performance and Scalability', () => {\n    it('should handle high event throughput', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n\n      // Créer un grand nombre d'événements\n      const highVolumeEvents = Array.from({ length: 50 }, (_, i) => \n        EventFactory.create(\n          'CART_ITEM_ADDED',\n          `cart_${i}`,\n          'cart',\n          {\n            productId: `product_${i % 10}`, // 10 produits différents\n            quantity: Math.floor(Math.random() * 5) + 1,\n            userId: `user_${i % 5}`, // 5 utilisateurs différents\n            cartId: `cart_${i}`\n          }\n        )\n      );\n\n      // Publier tous les événements\n      const startTime = Date.now();\n      const results = await Promise.allSettled(\n        highVolumeEvents.map(event => eventBus.publish(event))\n      );\n      const endTime = Date.now();\n\n      const successful = results.filter(r => r.status === 'fulfilled').length;\n      const processingTime = endTime - startTime;\n\n      expect(successful).toBeGreaterThan(40); // Au moins 80% de réussite\n      expect(processingTime).toBeLessThan(5000); // Moins de 5 secondes\n\n      console.log(`Processed ${successful}/${highVolumeEvents.length} events in ${processingTime}ms`);\n    });\n  });\n});\n\n/**\n * Ces tests valident que :\n * \n * 1. ✅ Les Event Listeners orchestrent correctement les Event Handlers\n * 2. ✅ Le CartEventListener coordonne panier + inventory + notifications + audit\n * 3. ✅ L'OrderWorkflowListener gère le cycle de vie complet des commandes\n * 4. ✅ Le NotificationEventListener coordonne toutes les notifications\n * 5. ✅ L'AuditEventListener assure la traçabilité de tous les événements\n * 6. ✅ La gestion d'erreur est resiliente aux pannes partielles\n * 7. ✅ Le système maintient les performances avec un haut débit d'événements\n * 8. ✅ L'ordre des événements est respecté pour un même agrégat\n */","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\__tests__\\event-performance.test.ts","messages":[{"ruleId":"no-async-promise-executor","severity":1,"message":"Promise executor functions should not be async.","line":36,"column":22,"nodeType":"Identifier","messageId":"async","endLine":36,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2309,2312],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2309,2312],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'i' is defined but never used. Allowed unused args must match /^_/u.","line":158,"column":75,"nodeType":null,"messageId":"unusedVar","endLine":158,"endColumn":76},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":293,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":293,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11305,11308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11305,11308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Event System Performance Tests\n * \n * Tests de performance, charge et endurance pour l'architecture Event-Driven.\n * Ces tests valident la scalabilité et la résilience du système sous charge.\n */\n\nimport { ContainerConfiguration } from '../../container/container.config';\nimport { SERVICE_TOKENS } from '../../container/container';\nimport { initializeEventSystem } from '../event-container-config';\nimport { EventFactory } from '@/lib/core/events';\nimport type { EventBus, EventStore } from '@/lib/core/events';\n\n// Mock optimisé pour les tests de performance\njest.mock('@/lib/supabase/server', () => ({\n  createSupabaseServerClient: jest.fn().mockReturnValue({\n    from: jest.fn(() => ({\n      select: jest.fn().mockResolvedValue({ data: [], error: null }),\n      insert: jest.fn().mockResolvedValue({ error: null }),\n      update: jest.fn().mockResolvedValue({ error: null }),\n      delete: jest.fn().mockResolvedValue({ error: null }),\n      eq: jest.fn().mockReturnThis(),\n      order: jest.fn().mockReturnThis(),\n      limit: jest.fn().mockReturnThis(),\n      single: jest.fn().mockResolvedValue({ data: null, error: null }),\n    })),\n    rpc: jest.fn().mockResolvedValue({ error: null }),\n    auth: {\n      getUser: jest.fn().mockResolvedValue({ data: { user: null }, error: null }),\n    },\n  }),\n}));\n\n// Helper pour mesurer les performances\nfunction measurePerformance<T>(operation: () => Promise<T>): Promise<{ result: T; duration: number }> {\n  return new Promise(async (resolve) => {\n    const startTime = performance.now();\n    const result = await operation();\n    const endTime = performance.now();\n    resolve({ result, duration: endTime - startTime });\n  });\n}\n\n// Helper pour générer des événements de test\nfunction generateTestEvents(count: number, eventType: string = 'CART_ITEM_ADDED') {\n  return Array.from({ length: count }, (_, i) => \n    EventFactory.create(\n      eventType,\n      `aggregate_${i}`,\n      'test',\n      {\n        id: i,\n        productId: `product_${i % 100}`, // 100 produits différents\n        userId: `user_${i % 20}`, // 20 utilisateurs différents\n        quantity: Math.floor(Math.random() * 5) + 1,\n        timestamp: Date.now(),\n        testData: `test_data_${i}`\n      }\n    )\n  );\n}\n\ndescribe('Event System Performance Tests', () => {\n  let container: any;\n  let eventBus: EventBus;\n  let eventStore: EventStore;\n\n  beforeAll(async () => {\n    const result = ContainerConfiguration.configureServer();\n    expect(result.isSuccess()).toBe(true);\n    \n    container = result.getValue();\n    await initializeEventSystem(container);\n    \n    eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n    eventStore = container.resolve<EventStore>(SERVICE_TOKENS.EVENT_STORE);\n  });\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('Single Event Performance', () => {\n    it('should publish single event quickly', async () => {\n      const event = EventFactory.create('CART_ITEM_ADDED', 'cart_1', 'cart', {\n        productId: 'product_1',\n        quantity: 1,\n        userId: 'user_1'\n      });\n\n      const { result, duration } = await measurePerformance(async () => {\n        return await eventBus.publish(event);\n      });\n\n      expect(result.isSuccess()).toBe(true);\n      expect(duration).toBeLessThan(50); // Moins de 50ms pour un événement\n      \n      console.log(`Single event processing time: ${duration.toFixed(2)}ms`);\n    });\n\n    it('should handle event persistence efficiently', async () => {\n      const event = EventFactory.create('ORDER_CREATED', 'order_1', 'order', {\n        orderId: 'order_1',\n        userId: 'user_1',\n        totalAmount: 99.99\n      });\n\n      const { result, duration } = await measurePerformance(async () => {\n        return await eventStore.append(event);\n      });\n\n      expect(result.isSuccess()).toBe(true);\n      expect(duration).toBeLessThan(100); // Moins de 100ms pour la persistance\n      \n      console.log(`Event persistence time: ${duration.toFixed(2)}ms`);\n    });\n  });\n\n  describe('Batch Event Performance', () => {\n    it('should handle medium batch (100 events) efficiently', async () => {\n      const events = generateTestEvents(100, 'CART_ITEM_ADDED');\n\n      const { result, duration } = await measurePerformance(async () => {\n        return await eventBus.publishBatch(events);\n      });\n\n      expect(result.isSuccess()).toBe(true);\n      expect(duration).toBeLessThan(2000); // Moins de 2 secondes pour 100 événements\n      \n      const eventsPerSecond = (events.length / duration) * 1000;\n      console.log(`Batch processing: ${events.length} events in ${duration.toFixed(2)}ms (${eventsPerSecond.toFixed(0)} events/sec)`);\n      \n      expect(eventsPerSecond).toBeGreaterThan(50); // Au moins 50 événements/seconde\n    });\n\n    it('should handle large batch (500 events) with acceptable performance', async () => {\n      const events = generateTestEvents(500, 'PRODUCT_STOCK_UPDATED');\n\n      const { result, duration } = await measurePerformance(async () => {\n        return await eventBus.publishBatch(events);\n      });\n\n      expect(result.isSuccess()).toBe(true);\n      expect(duration).toBeLessThan(10000); // Moins de 10 secondes pour 500 événements\n      \n      const eventsPerSecond = (events.length / duration) * 1000;\n      console.log(`Large batch processing: ${events.length} events in ${duration.toFixed(2)}ms (${eventsPerSecond.toFixed(0)} events/sec)`);\n      \n      expect(eventsPerSecond).toBeGreaterThan(30); // Au moins 30 événements/seconde\n    });\n  });\n\n  describe('Concurrent Event Processing', () => {\n    it('should handle concurrent event publishing', async () => {\n      const concurrentOperations = 20;\n      const eventsPerOperation = 10;\n\n      const operations = Array.from({ length: concurrentOperations }, (_, i) => {\n        const events = generateTestEvents(eventsPerOperation, 'USER_REGISTERED');\n        return () => eventBus.publishBatch(events);\n      });\n\n      const { result, duration } = await measurePerformance(async () => {\n        const promises = operations.map(op => op());\n        return await Promise.allSettled(promises);\n      });\n\n      const successful = result.filter(r => r.status === 'fulfilled').length;\n      const totalEvents = concurrentOperations * eventsPerOperation;\n      const eventsPerSecond = (totalEvents / duration) * 1000;\n\n      expect(successful).toBeGreaterThan(concurrentOperations * 0.8); // Au moins 80% de réussite\n      expect(eventsPerSecond).toBeGreaterThan(20); // Performance acceptable sous charge\n      \n      console.log(`Concurrent processing: ${totalEvents} events across ${concurrentOperations} operations in ${duration.toFixed(2)}ms`);\n      console.log(`Success rate: ${((successful / concurrentOperations) * 100).toFixed(1)}%`);\n      console.log(`Throughput: ${eventsPerSecond.toFixed(0)} events/sec`);\n    });\n\n    it('should maintain performance with mixed event types', async () => {\n      const eventTypes = [\n        'CART_ITEM_ADDED',\n        'ORDER_CREATED', \n        'USER_REGISTERED',\n        'PRODUCT_STOCK_UPDATED',\n        'ORDER_SHIPPED'\n      ];\n\n      const mixedEvents = eventTypes.flatMap(eventType => \n        generateTestEvents(50, eventType) // 50 événements de chaque type\n      );\n\n      // Mélanger les événements pour simuler un traffic réel\n      for (let i = mixedEvents.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [mixedEvents[i], mixedEvents[j]] = [mixedEvents[j], mixedEvents[i]];\n      }\n\n      const { result, duration } = await measurePerformance(async () => {\n        return await eventBus.publishBatch(mixedEvents);\n      });\n\n      expect(result.isSuccess()).toBe(true);\n      \n      const eventsPerSecond = (mixedEvents.length / duration) * 1000;\n      console.log(`Mixed event types: ${mixedEvents.length} events in ${duration.toFixed(2)}ms (${eventsPerSecond.toFixed(0)} events/sec)`);\n      \n      expect(eventsPerSecond).toBeGreaterThan(25); // Performance avec types mélangés\n    });\n  });\n\n  describe('Memory and Resource Usage', () => {\n    it('should not leak memory with repeated operations', async () => {\n      const initialMemory = process.memoryUsage();\n      \n      // Exécuter plusieurs cycles d'événements\n      for (let cycle = 0; cycle < 10; cycle++) {\n        const events = generateTestEvents(100, 'CART_ITEM_ADDED');\n        const result = await eventBus.publishBatch(events);\n        expect(result.isSuccess()).toBe(true);\n        \n        // Forcer le garbage collection si disponible\n        if (global.gc) {\n          global.gc();\n        }\n      }\n\n      const finalMemory = process.memoryUsage();\n      const memoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed;\n      const memoryIncreaseMB = memoryIncrease / (1024 * 1024);\n\n      console.log(`Memory usage - Initial: ${(initialMemory.heapUsed / 1024 / 1024).toFixed(2)}MB`);\n      console.log(`Memory usage - Final: ${(finalMemory.heapUsed / 1024 / 1024).toFixed(2)}MB`);\n      console.log(`Memory increase: ${memoryIncreaseMB.toFixed(2)}MB`);\n\n      // L'augmentation de mémoire devrait être raisonnable (moins de 50MB)\n      expect(memoryIncreaseMB).toBeLessThan(50);\n    });\n\n    it('should handle event bus statistics efficiently', async () => {\n      // Publier plusieurs événements\n      const events = generateTestEvents(200, 'ORDER_CREATED');\n      await eventBus.publishBatch(events);\n\n      const { result: stats, duration } = await measurePerformance(async () => {\n        return eventBus.getStatistics();\n      });\n\n      expect(duration).toBeLessThan(10); // Les statistiques doivent être rapides\n      expect(stats.subscribedHandlers).toBeGreaterThan(0);\n      expect(stats.eventTypes.length).toBeGreaterThan(0);\n      \n      console.log(`Statistics generation time: ${duration.toFixed(2)}ms`);\n    });\n  });\n\n  describe('Error Handling Performance', () => {\n    it('should handle errors without significant performance impact', async () => {\n      // Créer un mélange d'événements valides et invalides\n      const validEvents = generateTestEvents(100, 'CART_ITEM_ADDED');\n      const invalidEvents = Array.from({ length: 20 }, (_, i) =>\n        EventFactory.create(\n          'INVALID_EVENT_TYPE',\n          `invalid_${i}`,\n          'invalid',\n          { invalid: true }\n        )\n      );\n\n      const mixedEvents = [...validEvents, ...invalidEvents];\n\n      const { result, duration } = await measurePerformance(async () => {\n        const promises = mixedEvents.map(event => eventBus.publish(event));\n        return await Promise.allSettled(promises);\n      });\n\n      const successful = result.filter(r => r.status === 'fulfilled').length;\n      const failed = result.filter(r => r.status === 'rejected').length;\n\n      expect(successful).toBeGreaterThan(80); // La plupart des événements valides réussissent\n      expect(duration).toBeLessThan(5000); // Performance acceptable même avec erreurs\n      \n      console.log(`Error handling: ${successful} successful, ${failed} failed in ${duration.toFixed(2)}ms`);\n    });\n  });\n\n  describe('Scalability Stress Tests', () => {\n    it('should handle high-frequency bursts', async () => {\n      const burstSize = 50;\n      const burstCount = 10;\n      const burstInterval = 100; // 100ms entre les bursts\n\n      const results: any[] = [];\n\n      for (let burst = 0; burst < burstCount; burst++) {\n        const events = generateTestEvents(burstSize, 'CART_ITEM_ADDED');\n        \n        const { result, duration } = await measurePerformance(async () => {\n          return await eventBus.publishBatch(events);\n        });\n\n        results.push({ burst, success: result.isSuccess(), duration });\n\n        // Attendre avant le prochain burst\n        await new Promise(resolve => setTimeout(resolve, burstInterval));\n      }\n\n      const successfulBursts = results.filter(r => r.success).length;\n      const averageDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;\n      const totalEvents = burstSize * burstCount;\n\n      expect(successfulBursts).toBeGreaterThan(burstCount * 0.8); // 80% de réussite minimum\n      expect(averageDuration).toBeLessThan(2000); // Moins de 2s par burst en moyenne\n      \n      console.log(`Burst test: ${totalEvents} events in ${burstCount} bursts`);\n      console.log(`Success rate: ${((successfulBursts / burstCount) * 100).toFixed(1)}%`);\n      console.log(`Average burst duration: ${averageDuration.toFixed(2)}ms`);\n    });\n\n    // Test de charge extrême (désactivé par défaut pour éviter les timeouts)\n    it.skip('should survive extreme load test', async () => {\n      const extremeEventCount = 2000;\n      const events = generateTestEvents(extremeEventCount, 'PRODUCT_PRICE_CHANGED');\n\n      const { result, duration } = await measurePerformance(async () => {\n        // Publier par batches pour éviter la surcharge\n        const batchSize = 100;\n        const batches = [];\n        \n        for (let i = 0; i < events.length; i += batchSize) {\n          const batch = events.slice(i, i + batchSize);\n          batches.push(eventBus.publishBatch(batch));\n        }\n\n        return await Promise.allSettled(batches);\n      });\n\n      const successful = result.filter(r => r.status === 'fulfilled').length;\n      const successRate = (successful / result.length) * 100;\n      const eventsPerSecond = (extremeEventCount / duration) * 1000;\n\n      console.log(`Extreme load test: ${extremeEventCount} events in ${duration.toFixed(2)}ms`);\n      console.log(`Success rate: ${successRate.toFixed(1)}%`);\n      console.log(`Throughput: ${eventsPerSecond.toFixed(0)} events/sec`);\n\n      expect(successRate).toBeGreaterThan(70); // Au moins 70% sous charge extrême\n    });\n  });\n\n  describe('Performance Regression Detection', () => {\n    it('should maintain baseline performance metrics', async () => {\n      // Baseline attendu pour 100 événements\n      const baselineEventsPerSecond = 25;\n      const baselineMaxDuration = 4000; // 4 secondes max\n\n      const events = generateTestEvents(100, 'ORDER_CONFIRMED');\n\n      const { result, duration } = await measurePerformance(async () => {\n        return await eventBus.publishBatch(events);\n      });\n\n      const eventsPerSecond = (events.length / duration) * 1000;\n\n      expect(result.isSuccess()).toBe(true);\n      expect(duration).toBeLessThan(baselineMaxDuration);\n      expect(eventsPerSecond).toBeGreaterThan(baselineEventsPerSecond);\n\n      // Log des métriques pour surveillance continue\n      console.log('=== Performance Baseline Check ===');\n      console.log(`Events processed: ${events.length}`);\n      console.log(`Duration: ${duration.toFixed(2)}ms`);\n      console.log(`Throughput: ${eventsPerSecond.toFixed(0)} events/sec`);\n      console.log(`Baseline met: ${eventsPerSecond > baselineEventsPerSecond ? '✅' : '❌'}`);\n    });\n  });\n});\n\n/**\n * Ces tests de performance valident que :\n * \n * 1. ✅ Le traitement d'un événement unique est rapide (< 50ms)\n * 2. ✅ Les batches d'événements sont traités efficacement\n * 3. ✅ Le système supporte le traitement concurrent\n * 4. ✅ Les performances restent stables avec des types d'événements mélangés\n * 5. ✅ Il n'y a pas de fuites mémoire avec utilisation répétée\n * 6. ✅ La génération de statistiques est rapide\n * 7. ✅ La gestion d'erreur n'impacte pas significativement les performances\n * 8. ✅ Le système peut gérer des pics de charge (bursts)\n * 9. ✅ Les métriques de performance restent dans les limites acceptables\n * \n * Métriques de performance cibles :\n * - Événement unique : < 50ms\n * - Batch de 100 événements : < 2s (> 50 events/sec)\n * - Batch de 500 événements : < 10s (> 30 events/sec)\n * - Traitement concurrent : > 80% de réussite\n * - Augmentation mémoire : < 50MB après 1000 événements\n */","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\__tests__\\event-system-integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DomainEvent' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":26},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":68,"column":33,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":68,"endColumn":76},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":261,"column":28,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":261,"endColumn":60},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":303,"column":28,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":303,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'container' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":409,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":409,"endColumn":22},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":410,"column":40,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":410,"endColumn":83}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Event System Integration Tests\n * \n * Tests d'intégration complets pour l'architecture Event-Driven :\n * - Event Bus functionality\n * - Event Store persistence\n * - Event Handlers execution\n * - Container DI integration\n * - End-to-end event processing\n */\n\nimport { ContainerConfiguration } from '../../container/container.config';\nimport { SERVICE_TOKENS } from '../../container/container';\nimport { EventTypes, EventFactory, EventCorrelation } from '@/lib/core/events';\nimport type { DomainEvent, EventBus, EventStore } from '@/lib/core/events';\n\n// Mock des clients Supabase pour les tests\njest.mock('@/lib/supabase/server', () => ({\n  createSupabaseServerClient: jest.fn().mockReturnValue({\n    from: jest.fn(() => ({\n      select: jest.fn(),\n      insert: jest.fn(),\n      update: jest.fn(),\n      delete: jest.fn(),\n      eq: jest.fn(),\n      order: jest.fn(),\n      limit: jest.fn(),\n      single: jest.fn(),\n    })),\n    rpc: jest.fn().mockResolvedValue({ error: null }),\n    auth: {\n      getUser: jest.fn(),\n    },\n  }),\n}));\n\njest.mock('@/lib/supabase/server-admin', () => ({\n  createSupabaseAdminClient: jest.fn().mockReturnValue({\n    from: jest.fn(() => ({\n      select: jest.fn(),\n      insert: jest.fn(),\n      update: jest.fn(),\n      delete: jest.fn(),\n      eq: jest.fn(),\n      order: jest.fn(),\n      limit: jest.fn(),\n      single: jest.fn(),\n    })),\n    rpc: jest.fn().mockResolvedValue({ error: null }),\n    auth: {\n      admin: {\n        listUsers: jest.fn(),\n      },\n    },\n  }),\n}));\n\n// Mock environment variables\nprocess.env.STRIPE_SECRET_KEY = 'sk_test_mock';\nglobal.fetch = jest.fn().mockResolvedValue({\n  ok: true,\n  json: async () => ({}),\n} as Response);\n\ndescribe('Event System Integration Tests', () => {\n  beforeEach(() => {\n    // Reset containers avant chaque test\n    const { resetContainers } = require('../../container/container.config');\n    resetContainers();\n    jest.clearAllMocks();\n  });\n\n  describe('Container Configuration', () => {\n    it('should successfully configure event system in server container', async () => {\n      const result = ContainerConfiguration.configureServer();\n      \n      expect(result.isSuccess()).toBe(true);\n      \n      if (result.isSuccess()) {\n        const container = result.getValue();\n        \n        // Vérifier que tous les services événementiels sont enregistrés\n        const eventBus = container.resolve(SERVICE_TOKENS.EVENT_BUS);\n        const eventStore = container.resolve(SERVICE_TOKENS.EVENT_STORE);\n        const eventPublisher = container.resolve(SERVICE_TOKENS.EVENT_PUBLISHER);\n        \n        expect(eventBus).toBeDefined();\n        expect(eventStore).toBeDefined();\n        expect(eventPublisher).toBeDefined();\n        \n        // Vérifier que les handlers sont enregistrés\n        const cartHandler = container.resolve(SERVICE_TOKENS.CART_EVENT_HANDLER);\n        const orderHandler = container.resolve(SERVICE_TOKENS.ORDER_EVENT_HANDLER);\n        const inventoryHandler = container.resolve(SERVICE_TOKENS.INVENTORY_EVENT_HANDLER);\n        const auditHandler = container.resolve(SERVICE_TOKENS.AUDIT_EVENT_HANDLER);\n        \n        expect(cartHandler).toBeDefined();\n        expect(orderHandler).toBeDefined();\n        expect(inventoryHandler).toBeDefined();\n        expect(auditHandler).toBeDefined();\n        \n        // Vérifier que les listeners sont enregistrés\n        const cartListener = container.resolve(SERVICE_TOKENS.CART_EVENT_LISTENER);\n        const orderWorkflowListener = container.resolve(SERVICE_TOKENS.ORDER_WORKFLOW_EVENT_LISTENER);\n        const notificationListener = container.resolve(SERVICE_TOKENS.NOTIFICATION_EVENT_LISTENER);\n        const auditListener = container.resolve(SERVICE_TOKENS.AUDIT_EVENT_LISTENER);\n        \n        expect(cartListener).toBeDefined();\n        expect(orderWorkflowListener).toBeDefined();\n        expect(notificationListener).toBeDefined();\n        expect(auditListener).toBeDefined();\n      }\n    });\n\n    it('should have event handlers subscribed to event bus', async () => {\n      const result = ContainerConfiguration.configureServer();\n      \n      expect(result.isSuccess()).toBe(true);\n      \n      if (result.isSuccess()) {\n        const container = result.getValue();\n        const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n        \n        const stats = eventBus.getStatistics();\n        \n        // Vérifier qu'il y a des handlers enregistrés\n        expect(stats.subscribedHandlers).toBeGreaterThan(0);\n        expect(stats.eventTypes.length).toBeGreaterThan(0);\n        \n        // Vérifier des types d'événements spécifiques\n        expect(stats.handlersByType['CART_ITEM_ADDED']).toBeGreaterThan(0);\n        expect(stats.handlersByType['ORDER_CREATED']).toBeGreaterThan(0);\n      }\n    });\n  });\n\n  describe('Event Publishing and Handling', () => {\n    it('should publish and handle cart item added event', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n      \n      // Créer un événement de test\n      const event = EventFactory.create(\n        'CART_ITEM_ADDED',\n        'cart_123',\n        'cart',\n        {\n          productId: 'product_456',\n          quantity: 2,\n          userId: 'user_789',\n          cartId: 'cart_123',\n          productName: 'Test Product',\n          productPrice: 25.99,\n        },\n        EventCorrelation.createMetadata('user_789', 'test')\n      );\n      \n      // Publier l'événement\n      const publishResult = await eventBus.publish(event);\n      \n      expect(publishResult.isSuccess()).toBe(true);\n      \n      // Vérifier que l'événement a été traité (via les logs ou mocks)\n      // En réalité, on vérifierait les effets de bord des handlers\n    });\n\n    it('should handle order created event with multiple handlers', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n      \n      // Créer un événement de commande\n      const orderEvent = EventFactory.create(\n        EventTypes.ORDER_CREATED,\n        'order_456',\n        'order',\n        {\n          orderId: 'order_456',\n          userId: 'user_789',\n          items: [\n            {\n              productId: 'product_123',\n              quantity: 1,\n              price: 29.99,\n              productName: 'Test Product',\n            },\n          ],\n          totalAmount: 29.99,\n          currency: 'EUR',\n          shippingAddress: { street: '123 Test St' },\n          billingAddress: { street: '123 Test St' },\n          paymentMethod: 'card',\n        }\n      );\n      \n      const publishResult = await eventBus.publish(orderEvent);\n      \n      expect(publishResult.isSuccess()).toBe(true);\n    });\n\n    it('should handle batch event publishing', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n      \n      // Créer plusieurs événements\n      const events = [\n        EventFactory.create(EventTypes.CART_ITEM_ADDED, 'cart_1', 'cart', { productId: 'p1', quantity: 1, userId: 'u1', cartId: 'cart_1' }),\n        EventFactory.create(EventTypes.CART_ITEM_ADDED, 'cart_1', 'cart', { productId: 'p2', quantity: 2, userId: 'u1', cartId: 'cart_1' }),\n        EventFactory.create(EventTypes.CART_ITEM_REMOVED, 'cart_1', 'cart', { productId: 'p1', quantity: 1, userId: 'u1', cartId: 'cart_1', itemId: 'item_1' }),\n      ];\n      \n      const batchResult = await eventBus.publishBatch(events);\n      \n      expect(batchResult.isSuccess()).toBe(true);\n    });\n  });\n\n  describe('Event Store Integration', () => {\n    it('should persist events to event store', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventStore = container.resolve<EventStore>(SERVICE_TOKENS.EVENT_STORE);\n      \n      // Créer et persister un événement\n      const event = EventFactory.create(\n        EventTypes.PRODUCT_CREATED,\n        'product_789',\n        'product',\n        {\n          name: 'New Test Product',\n          price: 39.99,\n          category: 'Electronics',\n        }\n      );\n      \n      const appendResult = await eventStore.append(event);\n      \n      expect(appendResult.isSuccess()).toBe(true);\n    });\n\n    it('should retrieve events by aggregate id', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventStore = container.resolve<EventStore>(SERVICE_TOKENS.EVENT_STORE);\n      \n      const aggregateId = 'test_aggregate_123';\n      \n      // Mock le retour de Supabase pour simuler des événements stockés\n      const mockSupabase = require('@/lib/supabase/server').createSupabaseServerClient();\n      mockSupabase.from.mockReturnValue({\n        select: jest.fn().mockReturnValue({\n          eq: jest.fn().mockReturnValue({\n            order: jest.fn().mockReturnValue({\n              gte: jest.fn().mockResolvedValue({\n                data: [\n                  {\n                    event_id: 'evt_1',\n                    event_type: EventTypes.CART_ITEM_ADDED,\n                    aggregate_id: aggregateId,\n                    aggregate_type: 'cart',\n                    event_data: { test: true },\n                    version: 1,\n                    occurred_at: new Date().toISOString(),\n                  },\n                ],\n                error: null,\n              }),\n            }),\n          }),\n        }),\n      });\n      \n      const eventsResult = await eventStore.getEvents(aggregateId);\n      \n      expect(eventsResult.isSuccess()).toBe(true);\n      \n      if (eventsResult.isSuccess()) {\n        const events = eventsResult.getValue();\n        expect(Array.isArray(events)).toBe(true);\n      }\n    });\n\n    it('should get events by type', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventStore = container.resolve<EventStore>(SERVICE_TOKENS.EVENT_STORE);\n      \n      // Mock le retour de Supabase\n      const mockSupabase = require('@/lib/supabase/server').createSupabaseServerClient();\n      mockSupabase.from.mockReturnValue({\n        select: jest.fn().mockReturnValue({\n          eq: jest.fn().mockReturnValue({\n            order: jest.fn().mockReturnValue({\n              gte: jest.fn().mockResolvedValue({\n                data: [],\n                error: null,\n              }),\n            }),\n          }),\n        }),\n      });\n      \n      const eventsResult = await eventStore.getEventsByType(EventTypes.ORDER_CREATED);\n      \n      expect(eventsResult.isSuccess()).toBe(true);\n    });\n  });\n\n  describe('Event Handler Error Handling', () => {\n    it('should handle event processing errors gracefully', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n      \n      // Créer un événement qui pourrait causer une erreur\n      const problematicEvent = EventFactory.create(\n        EventTypes.CART_ITEM_ADDED,\n        'cart_error',\n        'cart',\n        {\n          // Données manquantes volontairement pour déclencher une erreur\n          productId: null,\n          quantity: -1,\n          userId: '',\n        }\n      );\n      \n      // L'event bus devrait gérer l'erreur sans planter\n      const publishResult = await eventBus.publish(problematicEvent);\n      \n      // Selon l'implémentation, cela pourrait réussir ou échouer\n      // mais ne devrait pas planter l'application\n      expect(publishResult.isSuccess() || publishResult.isError()).toBe(true);\n    });\n  });\n\n  describe('Performance and Scalability', () => {\n    it('should handle multiple concurrent events', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n      \n      // Créer plusieurs événements concurrents\n      const concurrentEvents = Array.from({ length: 10 }, (_, i) =>\n        EventFactory.create(\n          EventTypes.CART_ITEM_ADDED,\n          `cart_${i}`,\n          'cart',\n          {\n            productId: `product_${i}`,\n            quantity: i + 1,\n            userId: `user_${i}`,\n            cartId: `cart_${i}`,\n          }\n        )\n      );\n      \n      // Publier tous les événements en parallèle\n      const publishPromises = concurrentEvents.map(event => eventBus.publish(event));\n      const results = await Promise.allSettled(publishPromises);\n      \n      // Vérifier que la plupart ont réussi\n      const successful = results.filter(r => r.status === 'fulfilled').length;\n      expect(successful).toBeGreaterThan(5); // Au moins la moitié\n    });\n\n    it('should provide event system statistics', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const eventBus = container.resolve<EventBus>(SERVICE_TOKENS.EVENT_BUS);\n      \n      const stats = eventBus.getStatistics();\n      \n      expect(stats).toHaveProperty('subscribedHandlers');\n      expect(stats).toHaveProperty('eventTypes');\n      expect(stats).toHaveProperty('handlersByType');\n      \n      expect(typeof stats.subscribedHandlers).toBe('number');\n      expect(Array.isArray(stats.eventTypes)).toBe(true);\n      expect(typeof stats.handlersByType).toBe('object');\n    });\n  });\n\n  describe('Event System Health Check', () => {\n    it('should provide health check information', async () => {\n      const result = ContainerConfiguration.configureServer();\n      expect(result.isSuccess()).toBe(true);\n      \n      const container = result.getValue();\n      const { checkContainerHealth } = require('../../container/container.config');\n      \n      const health = await checkContainerHealth();\n      \n      expect(health.server).toBe(true);\n      expect(health.admin).toBe(true);\n      expect(health.errors).toHaveLength(0);\n    });\n  });\n});\n\n/**\n * Tests de compatibilité avec les domaines métier existants\n */\ndescribe('Event System Business Domain Integration', () => {\n  it('should integrate with Cart Domain Service', async () => {\n    const result = ContainerConfiguration.configureServer();\n    expect(result.isSuccess()).toBe(true);\n    \n    const container = result.getValue();\n    const cartDomainService = container.resolve(SERVICE_TOKENS.CART_DOMAIN_SERVICE);\n    \n    // Vérifier que le service utilise le système d'événements\n    expect(cartDomainService).toBeDefined();\n    expect(typeof cartDomainService.addItemToCart).toBe('function');\n  });\n\n  it('should work with Repository Pattern', async () => {\n    const result = ContainerConfiguration.configureServer();\n    expect(result.isSuccess()).toBe(true);\n    \n    const container = result.getValue();\n    \n    // Vérifier que les repositories et les événements coexistent\n    const productRepository = container.resolve(SERVICE_TOKENS.PRODUCT_REPOSITORY);\n    const eventBus = container.resolve(SERVICE_TOKENS.EVENT_BUS);\n    \n    expect(productRepository).toBeDefined();\n    expect(eventBus).toBeDefined();\n    \n    // Les handlers devraient pouvoir utiliser les repositories\n    const inventoryHandler = container.resolve(SERVICE_TOKENS.INVENTORY_UPDATE_HANDLER);\n    expect(inventoryHandler).toBeDefined();\n  });\n});\n\n/**\n * Ces tests valident que :\n * \n * 1. ✅ Le système d'événements est correctement configuré dans le container DI\n * 2. ✅ Les Event Handlers sont enregistrés et souscris aux bons événements\n * 3. ✅ L'EventBus peut publier et traiter les événements\n * 4. ✅ L'EventStore persiste les événements correctement\n * 5. ✅ La gestion d'erreur fonctionne pour les événements problématiques\n * 6. ✅ Le système est performant avec des événements concurrents\n * 7. ✅ L'intégration avec les domaines métier existants fonctionne\n * 8. ✅ Le health check du système événementiel est opérationnel\n */","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\event-bus.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EventHandler' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EventProcessingResult' is defined but never used. Allowed unused vars must match /^_/u.","line":18,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[639,642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[639,642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Event Bus Implementation\n * \n * Coordinates event publishing and handling with support for:\n * - Event persistence via EventStore\n * - Async event processing\n * - Error handling and retries\n * - Event replay and recovery\n */\n\nimport { \n  DomainEvent, \n  EventBus, \n  EventHandler, \n  EventStore, \n  EventProcessor,\n  EventEnvelope,\n  EventProcessingResult,\n  EventMetadata,\n  EventFactory,\n  EventCorrelation\n} from '@/lib/core/events';\nimport { Result } from '@/lib/core/result';\nimport { logger, Logger } from '@/lib/core/logger';\n\n// Temporary helper function\nfunction createSimpleContext(action: string, resource: string, data: any = {}) {\n  return { action, resource, ...data };\n}\n\n/**\n * In-Memory Event Bus Implementation\n * \n * Provides immediate event processing with optional persistence\n */\nexport class InMemoryEventBus implements EventBus {\n  private subscribers = new Map<string, Set<(event: DomainEvent) => Promise<void>>>();\n  protected eventFactory = new EventFactory();\n  protected eventStore?: EventStore;\n\n  constructor(private readonly logger: Logger) {}\n\n  /**\n   * Subscribe an event handler to a specific event type\n   */\n  async subscribe(eventType: string, handler: (event: DomainEvent) => Promise<void>): Promise<void> {\n    const handlers = this.subscribers.get(eventType) || new Set();\n    handlers.add(handler);\n    this.subscribers.set(eventType, handlers);\n\n    logger.info('Event handler subscribed', {\n      eventType,\n      handlerName: handler.constructor?.name || 'Anonymous',\n    });\n  }\n\n  /**\n   * Unsubscribe an event handler\n   */\n  async unsubscribe(eventType: string, handler: (event: DomainEvent) => Promise<void>): Promise<void> {\n    const handlers = this.subscribers.get(eventType);\n    if (handlers) {\n      handlers.delete(handler);\n      if (handlers.size === 0) {\n        this.subscribers.delete(eventType);\n      }\n    }\n\n    logger.info('Event handler unsubscribed', {\n      eventType,\n      handlerName: handler.constructor?.name || 'Anonymous',\n    });\n  }\n\n  /**\n   * Get all subscribed handlers for an event type\n   */\n  getSubscribedHandlers(eventType: string): ((event: DomainEvent) => Promise<void>)[] {\n    const handlers = this.subscribers.get(eventType);\n    return handlers ? Array.from(handlers) : [];\n  }\n\n  /**\n   * Publish a single event\n   */\n  async publish<T extends DomainEvent>(event: T): Promise<Result<void, Error>> {\n    const context = {\n      eventId: event.eventId,\n      eventType: event.eventType,\n      aggregateId: event.aggregateId,\n      action: 'event_bus_publish',\n      resource: 'events',\n    };\n\n    logger.info('EventBus.publish started', context);\n\n    try {\n      // Store event if persistence is configured\n      if (this.eventStore) {\n        const storeResult = await this.eventStore.append(event);\n        if (storeResult.isError()) {\n          logger.error('EventBus.publish', storeResult.getError(), context);\n          return Result.error(storeResult.getError());\n        }\n      }\n\n      // Process event immediately\n      const processResult = await this.processEventImmediate(event);\n      if (processResult.isError()) {\n        logger.error('EventBus.publish', processResult.getError(), context);\n        return Result.error(processResult.getError());\n      }\n\n      logger.info('EventBus.publish', context);\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Unknown event publishing error');\n      logger.error('EventBus.publish', err, context);\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Publish multiple events as a batch\n   */\n  async publishBatch<T extends DomainEvent>(events: T[]): Promise<Result<void, Error>> {\n    const context = createSimpleContext('event_bus_publish_batch', 'events', {\n      eventCount: events.length,\n      eventTypes: events.map(e => e.eventType),\n    });\n\n    logger.info('EventBus.publishBatch', context);\n\n    try {\n      // Store events if persistence is configured\n      if (this.eventStore) {\n        const storeResult = await this.eventStore.appendBatch(events);\n        if (storeResult.isError()) {\n          logger.error('EventBus.publishBatch', storeResult.getError(), context);\n          return Result.error(storeResult.getError());\n        }\n      }\n\n      // Process all events\n      const results = await Promise.allSettled(\n        events.map(event => this.processEventImmediate(event))\n      );\n\n      // Check for failures\n      const failures = results\n        .map((result, index) => ({ result, index }))\n        .filter(({ result }) => result.status === 'rejected' || \n          (result.status === 'fulfilled' && result.value.isError()))\n        .map(({ result, index }) => ({\n          event: events[index],\n          error: result.status === 'rejected' \n            ? result.reason \n            : (result.value as Result<void, Error>).getError()\n        }));\n\n      if (failures.length > 0) {\n        const error = new Error(`Failed to process ${failures.length} out of ${events.length} events`);\n        logger.error('EventBus.publishBatch', error, {\n          ...context,\n          failures: failures.map(f => ({\n            eventId: f.event.eventId,\n            eventType: f.event.eventType,\n            error: f.error.message,\n          })),\n        });\n        return Result.error(error);\n      }\n\n      logger.info('EventBus.publishBatch', context);\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Unknown batch publishing error');\n      logger.error('EventBus.publishBatch', err, context);\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Process event immediately with all subscribed handlers\n   */\n  protected async processEventImmediate<T extends DomainEvent>(event: T): Promise<Result<void, Error>> {\n    const handlers = this.getSubscribedHandlers(event.eventType);\n    \n    if (handlers.length === 0) {\n      logger.debug('No handlers found for event type', {\n        eventType: event.eventType,\n        eventId: event.eventId,\n      });\n      return Result.ok(undefined);\n    }\n\n    const results = await Promise.allSettled(\n      handlers.map(async handler => {\n        try {\n          const startTime = Date.now();\n          await handler(event);\n          const duration = Date.now() - startTime;\n\n          logger.debug('Event handler completed successfully', {\n            eventType: event.eventType,\n            eventId: event.eventId,\n            handlerName: handler.constructor?.name || 'Anonymous',\n            duration,\n          });\n\n          return Result.ok(undefined);\n        } catch (error) {\n          const err = error instanceof Error ? error : new Error('Handler execution failed');\n          logger.error('Event handler threw exception', {\n            eventType: event.eventType,\n            eventId: event.eventId,\n            handlerName: handler.constructor.name,\n            error: err.message,\n          });\n          return Result.error(err);\n        }\n      })\n    );\n\n    // Collect failures\n    const failures = results\n      .map((result, index) => ({ result, index }))\n      .filter(({ result }) => result.status === 'rejected' || \n        (result.status === 'fulfilled' && result.value.isError()))\n      .map(({ result, index }) => ({\n        handler: handlers[index],\n        error: result.status === 'rejected' \n          ? result.reason \n          : (result.value as Result<void, Error>).getError()\n      }));\n\n    if (failures.length > 0) {\n      return Result.error(new Error(\n        `${failures.length} out of ${handlers.length} handlers failed for event ${event.eventType}`\n      ));\n    }\n\n    return Result.ok(undefined);\n  }\n\n  /**\n   * Replay events from the event store\n   */\n  async replayEvents(\n    aggregateId: string, \n    fromVersion?: number\n  ): Promise<Result<number, Error>> {\n    if (!this.eventStore) {\n      return Result.error(new Error('Event store not configured for replay'));\n    }\n\n    try {\n      const eventsResult = await this.eventStore.getEvents(aggregateId, fromVersion);\n      if (eventsResult.isError()) {\n        return Result.error(eventsResult.getError());\n      }\n\n      const events = eventsResult.getValue();\n      let processedCount = 0;\n\n      for (const event of events) {\n        const result = await this.processEventImmediate(event);\n        if (result.isSuccess()) {\n          processedCount++;\n        } else {\n          logger.error('Failed to replay event', {\n            eventId: event.eventId,\n            eventType: event.eventType,\n            error: result.getError().message,\n          });\n        }\n      }\n\n      logger.info('Event replay completed', {\n        aggregateId,\n        totalEvents: events.length,\n        processedEvents: processedCount,\n        fromVersion,\n      });\n\n      return Result.ok(processedCount);\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Event replay failed');\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Get statistics about the event bus\n   */\n  getStatistics(): {\n    subscribedHandlers: number;\n    eventTypes: string[];\n    handlersByType: Record<string, number>;\n  } {\n    const eventTypes = Array.from(this.subscribers.keys());\n    const handlersByType: Record<string, number> = {};\n    let totalHandlers = 0;\n\n    for (const [eventType, handlers] of this.subscribers) {\n      handlersByType[eventType] = handlers.size;\n      totalHandlers += handlers.size;\n    }\n\n    return {\n      subscribedHandlers: totalHandlers,\n      eventTypes,\n      handlersByType,\n    };\n  }\n\n  /**\n   * Clear all subscriptions (useful for testing)\n   */\n  clear(): void {\n    this.subscribers.clear();\n    logger.info('Event bus cleared');\n  }\n}\n\n/**\n * Async Event Bus Implementation\n * \n * Provides asynchronous event processing with queuing and retry logic\n */\nexport class AsyncEventBus extends InMemoryEventBus {\n  private processingQueue: EventEnvelope[] = [];\n  private isProcessing = false;\n  private processingInterval: NodeJS.Timeout | null = null;\n  private eventProcessor?: EventProcessor;\n\n  constructor(\n    logger: Logger,\n    eventStore?: EventStore,\n    eventProcessor?: EventProcessor,\n    private readonly processingIntervalMs: number = 1000\n  ) {\n    super(logger);\n    this.eventStore = eventStore;\n    this.eventProcessor = eventProcessor;\n    this.startProcessing();\n  }\n\n  /**\n   * Publish event asynchronously (queued processing)\n   */\n  async publishAsync<T extends DomainEvent>(\n    event: T, \n    metadata?: EventMetadata\n  ): Promise<Result<void, Error>> {\n    try {\n      // Store event if persistence is configured\n      if (this.eventStore) {\n        const storeResult = await this.eventStore.append(event);\n        if (storeResult.isError()) {\n          return Result.error(storeResult.getError());\n        }\n      }\n\n      // Add to processing queue\n      const envelope = this.eventFactory.createEnvelope(\n        event,\n        metadata || EventCorrelation.createMetadata(event.userId)\n      );\n\n      this.processingQueue.push(envelope);\n\n      logger.debug('Event queued for async processing', {\n        eventId: event.eventId,\n        eventType: event.eventType,\n        queueSize: this.processingQueue.length,\n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Async publish failed');\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Start the async processing loop\n   */\n  private startProcessing(): void {\n    if (this.processingInterval) {\n      return;\n    }\n\n    this.processingInterval = setInterval(async () => {\n      if (!this.isProcessing && this.processingQueue.length > 0) {\n        await this.processQueue();\n      }\n    }, this.processingIntervalMs);\n\n    logger.info('Async event processing started', {\n      intervalMs: this.processingIntervalMs,\n    });\n  }\n\n  /**\n   * Stop the async processing loop\n   */\n  stopProcessing(): void {\n    if (this.processingInterval) {\n      clearInterval(this.processingInterval);\n      this.processingInterval = null;\n    }\n\n    logger.info('Async event processing stopped');\n  }\n\n  /**\n   * Process the event queue\n   */\n  private async processQueue(): Promise<void> {\n    if (this.isProcessing || this.processingQueue.length === 0) {\n      return;\n    }\n\n    this.isProcessing = true;\n\n    try {\n      const batch = this.processingQueue.splice(0, 10); // Process up to 10 events at once\n      \n      for (const envelope of batch) {\n        await this.processEnvelope(envelope);\n      }\n    } finally {\n      this.isProcessing = false;\n    }\n  }\n\n  /**\n   * Process a single event envelope\n   */\n  private async processEnvelope(envelope: EventEnvelope): Promise<void> {\n    try {\n      const result = await this.processEventImmediate(envelope.event);\n      \n      if (result.isError()) {\n        envelope.retryCount++;\n        envelope.failedAt = new Date();\n        envelope.error = result.getError().message;\n\n        if (envelope.retryCount < envelope.maxRetries) {\n          // Re-queue for retry\n          this.processingQueue.push(envelope);\n          logger.warn('Event processing failed, queued for retry', {\n            eventId: envelope.event.eventId,\n            eventType: envelope.event.eventType,\n            retryCount: envelope.retryCount,\n            maxRetries: envelope.maxRetries,\n            error: envelope.error,\n          });\n        } else {\n          logger.error('Event processing failed after max retries', {\n            eventId: envelope.event.eventId,\n            eventType: envelope.event.eventType,\n            retryCount: envelope.retryCount,\n            error: envelope.error,\n          });\n        }\n      } else {\n        envelope.processedAt = new Date();\n        logger.debug('Event processed successfully', {\n          eventId: envelope.event.eventId,\n          eventType: envelope.event.eventType,\n          retryCount: envelope.retryCount,\n        });\n      }\n    } catch (error) {\n      logger.error('Unexpected error processing event envelope', {\n        eventId: envelope.event.eventId,\n        eventType: envelope.event.eventType,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n    }\n  }\n\n  /**\n   * Get queue statistics\n   */\n  getQueueStatistics(): {\n    queueSize: number;\n    isProcessing: boolean;\n    processingIntervalMs: number;\n  } {\n    return {\n      queueSize: this.processingQueue.length,\n      isProcessing: this.isProcessing,\n      processingIntervalMs: this.processingIntervalMs,\n    };\n  }\n\n  /**\n   * Clear the processing queue\n   */\n  clearQueue(): void {\n    this.processingQueue = [];\n    logger.info('Event processing queue cleared');\n  }\n\n  /**\n   * Dispose of the async event bus\n   */\n  dispose(): void {\n    this.stopProcessing();\n    this.clearQueue();\n    this.clear();\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\event-container-config.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createSupabaseServerClient' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":36},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":355,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":355,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12932,12935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12932,12935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":373,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":373,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13463,13466],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13463,13466],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Event System Container Configuration\n * \n * Configures the complete event-driven architecture within the DI container.\n */\n\nimport { ContainerBuilder, SERVICE_TOKENS } from \"../container/container\";\nimport { SimpleEventBus } from \"./simple-event-bus\";\nimport { InMemoryEventStore } from \"./event-store\";\nimport type { EventBus, EventStore } from \"@/lib/core/events\";\nimport { createSupabaseServerClient } from \"@/lib/supabase/server\";\nimport { logger } from \"@/lib/core/logger\";\n\n// Event Handlers\nimport { CartEventHandler } from \"./handlers/cart.event-handler\";\nimport { OrderEventHandler } from \"./handlers/order.event-handler\";\nimport { UserEventHandler } from \"./handlers/user.event-handler\";\nimport { InventoryEventHandler } from \"./handlers/inventory.event-handler\";\nimport { NotificationEventHandler } from \"./handlers/notification.event-handler\";\nimport { AuditEventHandler } from \"./handlers/audit.event-handler\";\n\n// Event Listeners (aggregate handlers)\nimport { CartEventListener } from \"./listeners/cart.event-listener\";\nimport { OrderWorkflowEventListener } from \"./listeners/order-workflow.event-listener\";\nimport { NotificationEventListener } from \"./listeners/notification.event-listener\";\nimport { AuditEventListener } from \"./listeners/audit.event-listener\";\n\n/**\n * Configure the complete event system in the DI container\n */\nexport function configureEventSystem(builder: ContainerBuilder): void {\n  // Core Event Infrastructure\n  configureEventInfrastructure(builder);\n  \n  // Event Handlers\n  configureEventHandlers(builder);\n  \n  // Event Listeners (aggregate handlers)\n  configureEventListeners(builder);\n  \n  // Event System Initialization\n  configureEventSystemInitialization(builder);\n}\n\n/**\n * Configure core event infrastructure\n */\nfunction configureEventInfrastructure(builder: ContainerBuilder): void {\n  // Event Bus - Singleton to ensure all events go through the same instance\n  builder.addSingleton(\n    SERVICE_TOKENS.EVENT_BUS,\n    () => new SimpleEventBus(logger),\n    []\n  );\n\n  // Event Store - Singleton for event persistence\n  builder.addSingleton(\n    SERVICE_TOKENS.EVENT_STORE,\n    (container) => new InMemoryEventStore(\n      container.resolve(SERVICE_TOKENS.SUPABASE_CLIENT),\n      logger\n    ),\n    [SERVICE_TOKENS.SUPABASE_CLIENT]\n  );\n\n  // Event Publisher - Uses Event Bus\n  builder.addSingleton(\n    SERVICE_TOKENS.EVENT_PUBLISHER,\n    (container) => container.resolve(SERVICE_TOKENS.EVENT_BUS),\n    [SERVICE_TOKENS.EVENT_BUS]\n  );\n}\n\n/**\n * Configure individual event handlers\n */\nfunction configureEventHandlers(builder: ContainerBuilder): void {\n  // Cart Event Handler\n  builder.addSingleton(\n    SERVICE_TOKENS.CART_EVENT_HANDLER,\n    (container) => new CartEventHandler(\n      container.resolve(SERVICE_TOKENS.CART_REPOSITORY),\n      container.resolve(SERVICE_TOKENS.EVENT_STORE),\n      logger\n    ),\n    [SERVICE_TOKENS.CART_REPOSITORY, SERVICE_TOKENS.EVENT_STORE]\n  );\n\n  // Order Event Handler\n  builder.addSingleton(\n    SERVICE_TOKENS.ORDER_EVENT_HANDLER,\n    (container) => new OrderEventHandler(\n      container.resolve(SERVICE_TOKENS.ORDER_REPOSITORY),\n      container.resolve(SERVICE_TOKENS.EVENT_STORE),\n      logger\n    ),\n    [SERVICE_TOKENS.ORDER_REPOSITORY, SERVICE_TOKENS.EVENT_STORE]\n  );\n\n  // User Event Handler\n  builder.addSingleton(\n    SERVICE_TOKENS.USER_EVENT_HANDLER,\n    (container) => new UserEventHandler(\n      container.resolve(SERVICE_TOKENS.USER_REPOSITORY),\n      container.resolve(SERVICE_TOKENS.EVENT_STORE),\n      logger\n    ),\n    [SERVICE_TOKENS.USER_REPOSITORY, SERVICE_TOKENS.EVENT_STORE]\n  );\n\n  // Inventory Event Handler\n  builder.addSingleton(\n    SERVICE_TOKENS.INVENTORY_EVENT_HANDLER,\n    (container) => new InventoryEventHandler(\n      container.resolve(SERVICE_TOKENS.PRODUCT_REPOSITORY),\n      container.resolve(SERVICE_TOKENS.EVENT_STORE),\n      logger\n    ),\n    [SERVICE_TOKENS.PRODUCT_REPOSITORY, SERVICE_TOKENS.EVENT_STORE]\n  );\n\n  // Notification Event Handler\n  builder.addSingleton(\n    SERVICE_TOKENS.NOTIFICATION_EVENT_HANDLER,\n    (container) => new NotificationEventHandler(\n      container.resolve(SERVICE_TOKENS.SUPABASE_CLIENT),\n      container.resolve(SERVICE_TOKENS.EVENT_STORE),\n      logger\n    ),\n    [SERVICE_TOKENS.SUPABASE_CLIENT, SERVICE_TOKENS.EVENT_STORE]\n  );\n\n  // Audit Event Handler\n  builder.addSingleton(\n    SERVICE_TOKENS.AUDIT_EVENT_HANDLER,\n    (container) => new AuditEventHandler(\n      container.resolve(SERVICE_TOKENS.SUPABASE_CLIENT),\n      container.resolve(SERVICE_TOKENS.EVENT_STORE),\n      logger\n    ),\n    [SERVICE_TOKENS.SUPABASE_CLIENT, SERVICE_TOKENS.EVENT_STORE]\n  );\n}\n\n/**\n * Configure event listeners (aggregate handlers that coordinate multiple handlers)\n */\nfunction configureEventListeners(builder: ContainerBuilder): void {\n  // Cart Event Listener - coordinates cart-related event handling\n  builder.addSingleton(\n    SERVICE_TOKENS.CART_EVENT_LISTENER,\n    (container) => new CartEventListener(\n      container.resolve(SERVICE_TOKENS.CART_EVENT_HANDLER),\n      container.resolve(SERVICE_TOKENS.INVENTORY_EVENT_HANDLER),\n      container.resolve(SERVICE_TOKENS.NOTIFICATION_EVENT_HANDLER),\n      container.resolve(SERVICE_TOKENS.AUDIT_EVENT_HANDLER),\n      logger\n    ),\n    [\n      SERVICE_TOKENS.CART_EVENT_HANDLER,\n      SERVICE_TOKENS.INVENTORY_EVENT_HANDLER,\n      SERVICE_TOKENS.NOTIFICATION_EVENT_HANDLER,\n      SERVICE_TOKENS.AUDIT_EVENT_HANDLER\n    ]\n  );\n\n  // Order Workflow Event Listener - coordinates order processing\n  builder.addSingleton(\n    SERVICE_TOKENS.ORDER_WORKFLOW_EVENT_LISTENER,\n    (container) => new OrderWorkflowEventListener(\n      container.resolve(SERVICE_TOKENS.ORDER_EVENT_HANDLER),\n      container.resolve(SERVICE_TOKENS.INVENTORY_EVENT_HANDLER),\n      container.resolve(SERVICE_TOKENS.NOTIFICATION_EVENT_HANDLER),\n      container.resolve(SERVICE_TOKENS.AUDIT_EVENT_HANDLER),\n      logger\n    ),\n    [\n      SERVICE_TOKENS.ORDER_EVENT_HANDLER,\n      SERVICE_TOKENS.INVENTORY_EVENT_HANDLER,\n      SERVICE_TOKENS.NOTIFICATION_EVENT_HANDLER,\n      SERVICE_TOKENS.AUDIT_EVENT_HANDLER\n    ]\n  );\n\n  // Notification Event Listener - handles all notification scenarios\n  builder.addSingleton(\n    SERVICE_TOKENS.NOTIFICATION_EVENT_LISTENER,\n    (container) => new NotificationEventListener(\n      container.resolve(SERVICE_TOKENS.NOTIFICATION_EVENT_HANDLER),\n      container.resolve(SERVICE_TOKENS.USER_EVENT_HANDLER),\n      logger\n    ),\n    [\n      SERVICE_TOKENS.NOTIFICATION_EVENT_HANDLER,\n      SERVICE_TOKENS.USER_EVENT_HANDLER\n    ]\n  );\n\n  // Audit Event Listener - comprehensive audit trail\n  builder.addSingleton(\n    SERVICE_TOKENS.AUDIT_EVENT_LISTENER,\n    (container) => new AuditEventListener(\n      container.resolve(SERVICE_TOKENS.AUDIT_EVENT_HANDLER),\n      logger\n    ),\n    [SERVICE_TOKENS.AUDIT_EVENT_HANDLER]\n  );\n}\n\n/**\n * Configure event system initialization\n */\nfunction configureEventSystemInitialization(builder: ContainerBuilder): void {\n  // Event System Initializer - sets up all event subscriptions\n  builder.addSingleton(\n    SERVICE_TOKENS.EVENT_SYSTEM_INITIALIZER,\n    (container) => ({\n      initialize: async () => {\n        await initializeEventSystem(container);\n      }\n    }),\n    [\n      SERVICE_TOKENS.EVENT_BUS,\n      SERVICE_TOKENS.CART_EVENT_LISTENER,\n      SERVICE_TOKENS.ORDER_WORKFLOW_EVENT_LISTENER,\n      SERVICE_TOKENS.NOTIFICATION_EVENT_LISTENER,\n      SERVICE_TOKENS.AUDIT_EVENT_LISTENER\n    ]\n  );\n}\n\n/**\n * Initialize the event system by registering all event listeners\n */\nexport async function initializeEventSystem(container: { resolve: (token: string) => unknown }): Promise<void> {\n  try {\n    logger.info('Initializing event system...');\n\n    const eventBus: EventBus = container.resolve(SERVICE_TOKENS.EVENT_BUS) as EventBus;\n    \n    // Get all event listeners\n    const cartListener = container.resolve(SERVICE_TOKENS.CART_EVENT_LISTENER) as { \n      handleCartItemAdded: (event: unknown) => Promise<void>;\n      handleCartItemRemoved: (event: unknown) => Promise<void>;\n      handleCartItemQuantityUpdated: (event: unknown) => Promise<void>;\n      handleCartCleared: (event: unknown) => Promise<void>;\n      handleProductStockUpdated: (event: unknown) => Promise<void>;\n      handleProductPriceChanged: (event: unknown) => Promise<void>;\n    };\n    const orderWorkflowListener = container.resolve(SERVICE_TOKENS.ORDER_WORKFLOW_EVENT_LISTENER) as {\n      handleOrderCreated: (event: unknown) => Promise<void>;\n      handleOrderConfirmed: (event: unknown) => Promise<void>;\n      handleOrderShipped: (event: unknown) => Promise<void>;\n      handleOrderDelivered: (event: unknown) => Promise<void>;\n      handleOrderCancelled: (event: unknown) => Promise<void>;\n    };\n    const notificationListener = container.resolve(SERVICE_TOKENS.NOTIFICATION_EVENT_LISTENER) as {\n      handleUserRegistered: (event: unknown) => Promise<void>;\n      handleUserProfileUpdated: (event: unknown) => Promise<void>;\n    };\n    const auditListener = container.resolve(SERVICE_TOKENS.AUDIT_EVENT_LISTENER) as {\n      handleAuditEvent: (event: unknown) => Promise<void>;\n    };\n\n    // Register Cart Event Subscriptions\n    await eventBus.subscribe('CART_ITEM_ADDED', (event) => cartListener.handleCartItemAdded(event));\n    await eventBus.subscribe('CART_ITEM_REMOVED', (event) => cartListener.handleCartItemRemoved(event));\n    await eventBus.subscribe('CART_ITEM_QUANTITY_UPDATED', (event) => cartListener.handleCartItemQuantityUpdated(event));\n    await eventBus.subscribe('CART_CLEARED', (event) => cartListener.handleCartCleared(event));\n\n    // Register Order Event Subscriptions\n    await eventBus.subscribe('ORDER_CREATED', (event) => orderWorkflowListener.handleOrderCreated(event));\n    await eventBus.subscribe('ORDER_CONFIRMED', (event) => orderWorkflowListener.handleOrderConfirmed(event));\n    await eventBus.subscribe('ORDER_SHIPPED', (event) => orderWorkflowListener.handleOrderShipped(event));\n    await eventBus.subscribe('ORDER_DELIVERED', (event) => orderWorkflowListener.handleOrderDelivered(event));\n    await eventBus.subscribe('ORDER_CANCELLED', (event) => orderWorkflowListener.handleOrderCancelled(event));\n\n    // Register User Event Subscriptions\n    await eventBus.subscribe('USER_REGISTERED', (event) => notificationListener.handleUserRegistered(event));\n    await eventBus.subscribe('USER_PROFILE_UPDATED', (event) => notificationListener.handleUserProfileUpdated(event));\n\n    // Register Inventory Event Subscriptions\n    await eventBus.subscribe('PRODUCT_STOCK_UPDATED', (event) => cartListener.handleProductStockUpdated(event));\n    await eventBus.subscribe('PRODUCT_PRICE_CHANGED', (event) => cartListener.handleProductPriceChanged(event));\n\n    // Register Audit Event Subscriptions (catch-all for audit trail)\n    const auditEvents = [\n      'CART_ITEM_ADDED', 'CART_ITEM_REMOVED', 'CART_ITEM_QUANTITY_UPDATED', 'CART_CLEARED',\n      'ORDER_CREATED', 'ORDER_CONFIRMED', 'ORDER_SHIPPED', 'ORDER_DELIVERED', 'ORDER_CANCELLED',\n      'USER_REGISTERED', 'USER_PROFILE_UPDATED',\n      'PRODUCT_STOCK_UPDATED', 'PRODUCT_PRICE_CHANGED'\n    ];\n\n    for (const eventType of auditEvents) {\n      await eventBus.subscribe(eventType, (event) => auditListener.handleAuditEvent(event));\n    }\n\n    logger.info('Event system initialized successfully', {\n      registeredEvents: auditEvents.length,\n      listeners: ['cart', 'order-workflow', 'notification', 'audit']\n    });\n  } catch (error) {\n    logger.error('Failed to initialize event system', error);\n    throw error;\n  }\n}\n\n/**\n * Health check for the event system\n */\nexport async function checkEventSystemHealth(container: { resolve: (token: string) => unknown }): Promise<{\n  eventBus: boolean;\n  eventStore: boolean;\n  handlers: Record<string, boolean>;\n  listeners: Record<string, boolean>;\n  errors: string[];\n}> {\n  const errors: string[] = [];\n  const result = {\n    eventBus: false,\n    eventStore: false,\n    handlers: {} as Record<string, boolean>,\n    listeners: {} as Record<string, boolean>,\n    errors\n  };\n\n  try {\n    // Check Event Bus\n    const eventBus = container.resolve(SERVICE_TOKENS.EVENT_BUS) as EventBus;\n    result.eventBus = eventBus !== null;\n  } catch (error) {\n    errors.push(`Event Bus: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  try {\n    // Check Event Store\n    const eventStore = container.resolve(SERVICE_TOKENS.EVENT_STORE) as EventStore;\n    result.eventStore = eventStore !== null;\n  } catch (error) {\n    errors.push(`Event Store: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  // Check Event Handlers\n  const handlerTokens = [\n    'CART_EVENT_HANDLER',\n    'ORDER_EVENT_HANDLER', \n    'USER_EVENT_HANDLER',\n    'INVENTORY_EVENT_HANDLER',\n    'NOTIFICATION_EVENT_HANDLER',\n    'AUDIT_EVENT_HANDLER'\n  ];\n\n  for (const token of handlerTokens) {\n    try {\n      const handler = container.resolve((SERVICE_TOKENS as any)[token]);\n      result.handlers[token] = handler !== null;\n    } catch (error) {\n      result.handlers[token] = false;\n      errors.push(`Handler ${token}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  // Check Event Listeners\n  const listenerTokens = [\n    'CART_EVENT_LISTENER',\n    'ORDER_WORKFLOW_EVENT_LISTENER',\n    'NOTIFICATION_EVENT_LISTENER', \n    'AUDIT_EVENT_LISTENER'\n  ];\n\n  for (const token of listenerTokens) {\n    try {\n      const listener = container.resolve((SERVICE_TOKENS as any)[token]);\n      result.listeners[token] = listener !== null;\n    } catch (error) {\n      result.listeners[token] = false;\n      errors.push(`Listener ${token}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  return result;\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\event-store.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[617,620],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[617,620],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Event Store Implementation\n * \n * Implémentations concrètes des interfaces EventStore pour la persistance des événements.\n */\n\nimport { Result } from \"@/lib/core/result\";\nimport { BusinessError } from \"@/lib/core/errors\";\nimport type { DomainEvent, EventStore } from \"@/lib/core/events\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport { logger, Logger } from \"@/lib/core/logger\";\n\n/**\n * Structure des événements stockés dans Supabase\n */\ninterface StoredEventRecord {\n  id: string;\n  event_id: string;\n  event_type: string;\n  aggregate_id: string;\n  aggregate_type: string;\n  event_data: any; // JSONB\n  version: number;\n  occurred_at: string;\n  created_at?: string;\n  checksum?: string;\n}\n\n/**\n * Event Store en mémoire pour les tests et développement\n */\nexport class InMemoryEventStore implements EventStore {\n  private events: DomainEvent[] = [];\n  private readonly supabaseClient: SupabaseClient;\n\n  constructor(supabaseClient: SupabaseClient, private readonly logger: Logger) {\n    this.supabaseClient = supabaseClient;\n  }\n\n  async append(event: DomainEvent): Promise<Result<void, BusinessError>> {\n    try {\n      // Stocker en mémoire pour accès rapide\n      this.events.push(event);\n\n      // Persister dans Supabase de manière asynchrone\n      const record: Partial<StoredEventRecord> = {\n        event_id: event.eventId,\n        event_type: event.eventType,\n        aggregate_id: event.aggregateId,\n        aggregate_type: event.aggregateType,\n        event_data: event.eventData,\n        version: event.version,\n        occurred_at: event.occurredAt.toISOString(),\n      };\n\n      const { error } = await this.supabaseClient\n        .from('domain_events')\n        .insert(record);\n\n      if (error) {\n        this.logger.error('Failed to persist event to Supabase', { error, event });\n        // Continue anyway - l'événement est en mémoire\n      }\n\n      this.logger.debug('Event appended to store', { \n        eventType: event.eventType,\n        aggregateId: event.aggregateId,\n        eventId: event.eventId \n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to append event', error);\n      return Result.error(new BusinessError('Failed to append event to event store', { error }));\n    }\n  }\n\n  async appendBatch(events: DomainEvent[]): Promise<Result<void, BusinessError>> {\n    try {\n      // Stocker en mémoire\n      this.events.push(...events);\n\n      // Persister en batch dans Supabase\n      const records: Partial<StoredEventRecord>[] = events.map(event => ({\n        event_id: event.eventId,\n        event_type: event.eventType,\n        aggregate_id: event.aggregateId,\n        aggregate_type: event.aggregateType,\n        event_data: event.eventData,\n        version: event.version,\n        occurred_at: event.occurredAt.toISOString(),\n      }));\n\n      const { error } = await this.supabaseClient\n        .from('domain_events')\n        .insert(records);\n\n      if (error) {\n        this.logger.error('Failed to persist event batch to Supabase', { error, count: events.length });\n        // Continue anyway - les événements sont en mémoire\n      }\n\n      this.logger.debug('Event batch appended to store', { count: events.length });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to append event batch', error);\n      return Result.error(new BusinessError('Failed to append event batch to event store', { error }));\n    }\n  }\n\n  async getEvents(aggregateId: string, fromVersion?: number): Promise<Result<DomainEvent[], BusinessError>> {\n    try {\n      // Essayer d'abord Supabase\n      let query = this.supabaseClient\n        .from('domain_events')\n        .select('*')\n        .eq('aggregate_id', aggregateId)\n        .order('version', { ascending: true });\n\n      if (fromVersion !== undefined) {\n        query = query.gte('version', fromVersion);\n      }\n\n      const { data, error } = await query;\n\n      if (error) {\n        this.logger.warn('Failed to fetch events from Supabase, falling back to memory', { error, aggregateId });\n        \n        // Fallback sur les événements en mémoire\n        let memoryEvents = this.events.filter(e => e.aggregateId === aggregateId);\n        \n        if (fromVersion !== undefined) {\n          memoryEvents = memoryEvents.filter(e => e.version >= fromVersion);\n        }\n        \n        return Result.ok(memoryEvents.sort((a, b) => a.version - b.version));\n      }\n\n      // Convertir les enregistrements Supabase en DomainEvent\n      const events: DomainEvent[] = (data || []).map(record => ({\n        eventId: record.event_id,\n        eventType: record.event_type,\n        aggregateId: record.aggregate_id,\n        aggregateType: record.aggregate_type,\n        eventData: record.event_data,\n        version: record.version,\n        occurredAt: new Date(record.occurred_at),\n      }));\n\n      return Result.ok(events);\n    } catch (error) {\n      this.logger.error('Failed to get events', error);\n      return Result.error(new BusinessError('Failed to retrieve events from event store', { error }));\n    }\n  }\n\n  async getEventsByType(eventType: string, options?: { fromDate?: Date; limit?: number }): Promise<Result<DomainEvent[], BusinessError>> {\n    try {\n      // Essayer d'abord Supabase\n      let query = this.supabaseClient\n        .from('domain_events')\n        .select('*')\n        .eq('event_type', eventType)\n        .order('occurred_at', { ascending: false });\n\n      if (options?.limit) {\n        query = query.limit(options.limit);\n      }\n\n      if (options?.fromDate) {\n        query = query.gte('occurred_at', options.fromDate.toISOString());\n      }\n\n      const { data, error } = await query;\n\n      if (error) {\n        this.logger.warn('Failed to fetch events by type from Supabase, falling back to memory', { error, eventType });\n        \n        // Fallback sur les événements en mémoire\n        let memoryEvents = this.events.filter(e => e.eventType === eventType);\n        memoryEvents.sort((a, b) => b.occurredAt.getTime() - a.occurredAt.getTime());\n        \n        if (options?.limit) {\n          memoryEvents = memoryEvents.slice(0, options.limit);\n        }\n        \n        return Result.ok(memoryEvents);\n      }\n\n      // Convertir les enregistrements Supabase en DomainEvent\n      const events: DomainEvent[] = (data || []).map(record => ({\n        eventId: record.event_id,\n        eventType: record.event_type,\n        aggregateId: record.aggregate_id,\n        aggregateType: record.aggregate_type,\n        eventData: record.event_data,\n        version: record.version,\n        occurredAt: new Date(record.occurred_at),\n      }));\n\n      return Result.ok(events);\n    } catch (error) {\n      this.logger.error('Failed to get events by type', error);\n      return Result.error(new BusinessError('Failed to retrieve events by type from event store', { error }));\n    }\n  }\n\n  async getStatistics(): Promise<Result<{ totalEvents: number; eventTypes: string[]; oldestEvent?: Date; newestEvent?: Date }, BusinessError>> {\n    try {\n      const memoryEventCount = this.events.length;\n      const memoryEventTypes = Array.from(new Set(this.events.map(e => e.eventType)));\n\n      // Essayer d'obtenir les statistiques de Supabase\n      const { data, error } = await this.supabaseClient\n        .from('domain_events')\n        .select('event_type, occurred_at', { count: 'exact' });\n\n      if (error) {\n        this.logger.warn('Failed to get statistics from Supabase, using memory data', { error });\n        \n        const oldestEvent = this.events.length > 0 \n          ? new Date(Math.min(...this.events.map(e => e.occurredAt.getTime())))\n          : undefined;\n        const newestEvent = this.events.length > 0\n          ? new Date(Math.max(...this.events.map(e => e.occurredAt.getTime())))\n          : undefined;\n\n        return Result.ok({\n          totalEvents: memoryEventCount,\n          eventTypes: memoryEventTypes,\n          oldestEvent,\n          newestEvent\n        });\n      }\n\n      const supabaseEventTypes = Array.from(new Set((data || []).map(record => record.event_type)));\n      const allEventTypes = Array.from(new Set([...memoryEventTypes, ...supabaseEventTypes]));\n\n      const dates = (data || []).map(record => new Date(record.occurred_at));\n      const oldestEvent = dates.length > 0 ? new Date(Math.min(...dates.map(d => d.getTime()))) : undefined;\n      const newestEvent = dates.length > 0 ? new Date(Math.max(...dates.map(d => d.getTime()))) : undefined;\n\n      return Result.ok({\n        totalEvents: (data?.length || 0) + memoryEventCount,\n        eventTypes: allEventTypes,\n        oldestEvent,\n        newestEvent\n      });\n    } catch (error) {\n      this.logger.error('Failed to get event store statistics', error);\n      return Result.error(new BusinessError('Failed to retrieve event store statistics', { error }));\n    }\n  }\n\n  // Méthodes utilitaires pour les tests\n  async clear(): Promise<void> {\n    this.events = [];\n    \n    try {\n      await this.supabaseClient\n        .from('domain_events')\n        .delete()\n        .neq('id', ''); // Supprimer tous les enregistrements\n    } catch (error) {\n      this.logger.warn('Failed to clear Supabase events (test cleanup)', { error: error instanceof Error ? error.message : 'Unknown error' });\n    }\n  }\n\n  getInMemoryEvents(): DomainEvent[] {\n    return [...this.events];\n  }\n\n  getInMemoryEventCount(): number {\n    return this.events.length;\n  }\n\n  async getAllEvents(fromDate?: Date, limit?: number): Promise<Result<DomainEvent[], BusinessError>> {\n    try {\n      let events = [...this.events];\n      \n      if (fromDate) {\n        events = events.filter(event => event.occurredAt >= fromDate);\n      }\n      \n      if (limit) {\n        events = events.slice(0, limit);\n      }\n      \n      return Result.ok(events);\n    } catch (error) {\n      this.logger.error('Failed to get all events', error);\n      return Result.error(new BusinessError('Failed to retrieve all events from event store', { error }));\n    }\n  }\n}\n\n/**\n * Event Store persistant (utilise uniquement Supabase)\n * Alternative à InMemoryEventStore pour la production\n */\nexport class SupabaseEventStore implements EventStore {\n  constructor(\n    private readonly supabaseClient: SupabaseClient,\n    private readonly logger: Logger = logger\n  ) {}\n\n  async append(event: DomainEvent): Promise<Result<void, BusinessError>> {\n    try {\n      const record: Partial<StoredEventRecord> = {\n        event_id: event.eventId,\n        event_type: event.eventType,\n        aggregate_id: event.aggregateId,\n        aggregate_type: event.aggregateType,\n        event_data: event.eventData,\n        version: event.version,\n        occurred_at: event.occurredAt.toISOString(),\n      };\n\n      const { error } = await this.supabaseClient\n        .from('domain_events')\n        .insert(record);\n\n      if (error) {\n        this.logger.error('Failed to persist event to Supabase', { error, event });\n        return Result.error(new BusinessError('Failed to persist event', { error }));\n      }\n\n      this.logger.debug('Event persisted to Supabase', { \n        eventType: event.eventType,\n        aggregateId: event.aggregateId,\n        eventId: event.eventId \n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to append event', error);\n      return Result.error(new BusinessError('Failed to append event to event store', { error }));\n    }\n  }\n\n  async appendBatch(events: DomainEvent[]): Promise<Result<void, BusinessError>> {\n    try {\n      const records: Partial<StoredEventRecord>[] = events.map(event => ({\n        event_id: event.eventId,\n        event_type: event.eventType,\n        aggregate_id: event.aggregateId,\n        aggregate_type: event.aggregateType,\n        event_data: event.eventData,\n        version: event.version,\n        occurred_at: event.occurredAt.toISOString(),\n      }));\n\n      const { error } = await this.supabaseClient\n        .from('domain_events')\n        .insert(records);\n\n      if (error) {\n        this.logger.error('Failed to persist event batch to Supabase', { error, count: events.length });\n        return Result.error(new BusinessError('Failed to persist event batch', { error }));\n      }\n\n      this.logger.debug('Event batch persisted to Supabase', { count: events.length });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to append event batch', error);\n      return Result.error(new BusinessError('Failed to append event batch to event store', { error }));\n    }\n  }\n\n  async getEvents(aggregateId: string, fromVersion?: number): Promise<Result<DomainEvent[], BusinessError>> {\n    try {\n      let query = this.supabaseClient\n        .from('domain_events')\n        .select('*')\n        .eq('aggregate_id', aggregateId)\n        .order('version', { ascending: true });\n\n      if (fromVersion !== undefined) {\n        query = query.gte('version', fromVersion);\n      }\n\n      const { data, error } = await query;\n\n      if (error) {\n        this.logger.error('Failed to fetch events from Supabase', { error, aggregateId });\n        return Result.error(new BusinessError('Failed to retrieve events', { error }));\n      }\n\n      const events: DomainEvent[] = (data || []).map(record => ({\n        eventId: record.event_id,\n        eventType: record.event_type,\n        aggregateId: record.aggregate_id,\n        aggregateType: record.aggregate_type,\n        eventData: record.event_data,\n        version: record.version,\n        occurredAt: new Date(record.occurred_at),\n      }));\n\n      return Result.ok(events);\n    } catch (error) {\n      this.logger.error('Failed to get events', error);\n      return Result.error(new BusinessError('Failed to retrieve events from event store', { error }));\n    }\n  }\n\n  async getEventsByType(eventType: string, options?: { fromDate?: Date; limit?: number }): Promise<Result<DomainEvent[], BusinessError>> {\n    try {\n      let query = this.supabaseClient\n        .from('domain_events')\n        .select('*')\n        .eq('event_type', eventType)\n        .order('occurred_at', { ascending: false });\n\n      if (options?.limit) {\n        query = query.limit(options.limit);\n      }\n\n      if (options?.fromDate) {\n        query = query.gte('occurred_at', options.fromDate.toISOString());\n      }\n\n      const { data, error } = await query;\n\n      if (error) {\n        this.logger.error('Failed to fetch events by type from Supabase', { error, eventType });\n        return Result.error(new BusinessError('Failed to retrieve events by type', { error }));\n      }\n\n      const events: DomainEvent[] = (data || []).map(record => ({\n        eventId: record.event_id,\n        eventType: record.event_type,\n        aggregateId: record.aggregate_id,\n        aggregateType: record.aggregate_type,\n        eventData: record.event_data,\n        version: record.version,\n        occurredAt: new Date(record.occurred_at),\n      }));\n\n      return Result.ok(events);\n    } catch (error) {\n      this.logger.error('Failed to get events by type', error);\n      return Result.error(new BusinessError('Failed to retrieve events by type from event store', { error }));\n    }\n  }\n\n  async getStatistics(): Promise<Result<{ totalEvents: number; eventTypes: string[]; oldestEvent?: Date; newestEvent?: Date }, BusinessError>> {\n    try {\n      const { data, error } = await this.supabaseClient\n        .from('domain_events')\n        .select('event_type, occurred_at', { count: 'exact' });\n\n      if (error) {\n        this.logger.error('Failed to get statistics from Supabase', { error });\n        return Result.error(new BusinessError('Failed to retrieve event store statistics', { error }));\n      }\n\n      const eventTypes = Array.from(new Set((data || []).map(record => record.event_type)));\n      const dates = (data || []).map(record => new Date(record.occurred_at));\n      const oldestEvent = dates.length > 0 ? new Date(Math.min(...dates.map(d => d.getTime()))) : undefined;\n      const newestEvent = dates.length > 0 ? new Date(Math.max(...dates.map(d => d.getTime()))) : undefined;\n\n      return Result.ok({\n        totalEvents: data?.length || 0,\n        eventTypes,\n        oldestEvent,\n        newestEvent\n      });\n    } catch (error) {\n      this.logger.error('Failed to get event store statistics', error);\n      return Result.error(new BusinessError('Failed to retrieve event store statistics', { error }));\n    }\n  }\n\n  async getAllEvents(fromDate?: Date, limit?: number): Promise<Result<DomainEvent[], BusinessError>> {\n    try {\n      let query = this.supabaseClient\n        .from('domain_events')\n        .select('*')\n        .order('occurred_at', { ascending: false });\n\n      if (fromDate) {\n        query = query.gte('occurred_at', fromDate.toISOString());\n      }\n\n      if (limit) {\n        query = query.limit(limit);\n      }\n\n      const { data, error } = await query;\n\n      if (error) {\n        this.logger.error('Failed to retrieve all events from Supabase', { error });\n        return Result.error(new BusinessError('Failed to retrieve all events from event store', { error }));\n      }\n\n      const events: DomainEvent[] = (data || []).map(record => ({\n        eventId: record.event_id,\n        eventType: record.event_type,\n        aggregateId: record.aggregate_id,\n        aggregateType: record.aggregate_type,\n        eventData: record.event_data,\n        version: record.version,\n        userId: record.user_id,\n        correlationId: record.correlation_id,\n        causationId: record.causation_id,\n        occurredAt: new Date(record.occurred_at),\n      }));\n\n      return Result.ok(events);\n    } catch (error) {\n      this.logger.error('Failed to get all events', error);\n      return Result.error(new BusinessError('Failed to retrieve all events from event store', { error }));\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\handlers\\audit.event-handler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Audit Event Handler\n */\n\nimport { Result } from \"@/lib/core/result\";\nimport { BusinessError } from \"@/lib/core/errors\";\nimport type { DomainEvent, EventStore } from \"@/lib/core/events\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport { logger, Logger } from \"@/lib/core/logger\";\n\nexport class AuditEventHandler {\n  constructor(\n    private readonly supabaseClient: SupabaseClient,\n    private readonly eventStore: EventStore,\n    private readonly logger: Logger = logger\n  ) {}\n\n  async handle(event: DomainEvent): Promise<Result<void, BusinessError>> {\n    try {\n      this.logger.info('Processing audit event', { eventType: event.eventType, eventId: event.eventId });\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Audit event handler error', { error, event });\n      return Result.error(new BusinessError('Audit event handling failed', { error, event }));\n    }\n  }\n\n  async logEvent(event: DomainEvent): Promise<Result<void, BusinessError>> {\n    try {\n      this.logger.info('Logging event for audit', { eventType: event.eventType, eventId: event.eventId });\n      return Result.ok(undefined);\n    } catch (error) {\n      return Result.error(new BusinessError('Failed to log audit event', { error }));\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\handlers\\cart-event-handlers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[526,529],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[526,529],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CartItemQuantityUpdatedEventData' is defined but never used. Allowed unused vars must match /^_/u.","line":50,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":43},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":194,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5834,5837],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5834,5837],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":252,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":252,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7836,7839],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7836,7839],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Cart Domain Event Handlers\n * \n * Handles cart-related events for:\n * - Analytics tracking\n * - Inventory management\n * - User behavior analysis\n * - Email notifications\n */\n\nimport { DomainEvent, EventHandler, EventTypes } from '@/lib/core/events';\nimport { Result } from '@/lib/core/result';\nimport { logger } from '@/lib/core/logger';\nimport { resolveService } from '@/lib/infrastructure/container/container.config';\n\n// Temporary helper function\nfunction createSimpleContext(action: string, resource: string, data: any = {}) {\n  return { action, resource, ...data };\n}\nimport { SERVICE_TOKENS } from '@/lib/infrastructure/container/container';\nimport type { IProductRepository } from '@/lib/domain/interfaces/product.repository.interface';\nimport type { IUserRepository } from '@/lib/domain/interfaces/user.repository.interface';\n\n/**\n * Cart Item Added Event Data\n */\ninterface CartItemAddedEventData {\n  productId: string;\n  quantity: number;\n  userId: string;\n  cartId: string;\n  productName?: string;\n  productPrice?: number;\n}\n\n/**\n * Cart Item Removed Event Data\n */\ninterface CartItemRemovedEventData {\n  itemId: string;\n  productId: string;\n  userId: string;\n  cartId: string;\n  quantity: number;\n}\n\n/**\n * Cart Item Quantity Updated Event Data\n */\ninterface CartItemQuantityUpdatedEventData {\n  itemId: string;\n  productId: string;\n  userId: string;\n  cartId: string;\n  oldQuantity: number;\n  newQuantity: number;\n}\n\n/**\n * Cart Analytics Event Handler\n * \n * Tracks cart events for business intelligence and analytics\n */\nexport class CartAnalyticsEventHandler implements EventHandler {\n  readonly eventType = EventTypes.CART_ITEM_ADDED;\n\n  async handle(event: DomainEvent<CartItemAddedEventData>): Promise<Result<void, Error>> {\n    const context = createSimpleContext('cart_analytics_handler', 'analytics', {\n      eventId: event.eventId,\n      userId: event.eventData.userId,\n      productId: event.eventData.productId,\n    });\n\n    logger.info('CartAnalyticsEventHandler.handle', context);\n\n    try {\n      // Track the cart addition for analytics\n      await this.trackCartAddition({\n        userId: event.eventData.userId,\n        productId: event.eventData.productId,\n        quantity: event.eventData.quantity,\n        timestamp: event.occurredAt,\n        sessionId: event.correlationId,\n      });\n\n      // Update user behavior metrics\n      await this.updateUserBehaviorMetrics(event.eventData.userId, {\n        lastCartActivity: event.occurredAt,\n        totalCartAdditions: 1,\n      });\n\n      logger.info('CartAnalyticsEventHandler.handle', context);\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Cart analytics tracking failed');\n      logger.error('CartAnalyticsEventHandler.handle', err, context);\n      return Result.error(err);\n    }\n  }\n\n  private async trackCartAddition(data: {\n    userId: string;\n    productId: string;\n    quantity: number;\n    timestamp: Date;\n    sessionId?: string;\n  }): Promise<void> {\n    // In a real implementation, this would write to an analytics database\n    // or send to an analytics service like Google Analytics, Mixpanel, etc.\n    logger.info('Cart addition tracked', {\n      analytics: {\n        event: 'cart_item_added',\n        ...data,\n      },\n    });\n  }\n\n  private async updateUserBehaviorMetrics(\n    userId: string, \n    metrics: { lastCartActivity: Date; totalCartAdditions: number }\n  ): Promise<void> {\n    // Update user behavior tracking\n    logger.info('User behavior metrics updated', {\n      userId,\n      metrics,\n    });\n  }\n}\n\n/**\n * Inventory Update Event Handler\n * \n * Updates product inventory when items are added/removed from carts\n */\nexport class InventoryUpdateEventHandler implements EventHandler {\n  readonly eventType = EventTypes.CART_ITEM_ADDED;\n\n  async handle(event: DomainEvent<CartItemAddedEventData>): Promise<Result<void, Error>> {\n    const context = createSimpleContext('inventory_update_handler', 'inventory', {\n      eventId: event.eventId,\n      productId: event.eventData.productId,\n      quantity: event.eventData.quantity,\n    });\n\n    logger.info('InventoryUpdateEventHandler.handle', context);\n\n    try {\n      const productRepository = await resolveService<IProductRepository>(SERVICE_TOKENS.PRODUCT_REPOSITORY);\n      \n      // Reserve inventory for items in cart (optional business rule)\n      const reservationResult = await productRepository.reserveStock(\n        event.eventData.productId,\n        event.eventData.quantity,\n        `cart_${event.aggregateId}`\n      );\n\n      if (reservationResult.isError()) {\n        // Log warning but don't fail the event processing\n        // Cart can still be created even if we can't reserve stock\n        logger.warn('Failed to reserve stock for cart item', {\n          productId: event.eventData.productId,\n          quantity: event.eventData.quantity,\n          error: reservationResult.getError().message,\n          ...context,\n        });\n      } else {\n        logger.info('Stock reserved for cart item', {\n          productId: event.eventData.productId,\n          quantity: event.eventData.quantity,\n          ...context,\n        });\n      }\n\n      logger.info('InventoryUpdateEventHandler.handle', context);\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Inventory update failed');\n      logger.error('InventoryUpdateEventHandler.handle', err, context);\n      return Result.error(err);\n    }\n  }\n}\n\n/**\n * Cart Abandonment Tracking Handler\n * \n * Handles cart abandonment scenarios for marketing campaigns\n */\nexport class CartAbandonmentTrackingHandler implements EventHandler {\n  readonly eventType = EventTypes.CART_ABANDONED;\n\n  async handle(event: DomainEvent<{ userId: string; cartId: string; items: any[] }>): Promise<Result<void, Error>> {\n    const context = createSimpleContext('cart_abandonment_handler', 'marketing', {\n      eventId: event.eventId,\n      userId: event.eventData.userId,\n      cartId: event.eventData.cartId,\n    });\n\n    logger.info('CartAbandonmentTrackingHandler.handle', context);\n\n    try {\n      const userRepository = await resolveService<IUserRepository>(SERVICE_TOKENS.USER_REPOSITORY);\n      \n      // Get user information for personalized recovery\n      const userResult = await userRepository.findByIdWithProfile(event.eventData.userId);\n      if (userResult.isError()) {\n        logger.warn('Failed to get user info for cart abandonment', {\n          userId: event.eventData.userId,\n          error: userResult.getError().message,\n        });\n        return Result.ok(undefined); // Don't fail the event\n      }\n\n      const user = userResult.getValue();\n      if (!user) {\n        return Result.ok(undefined);\n      }\n\n      // Schedule cart abandonment email (would integrate with email service)\n      await this.scheduleAbandonmentEmail({\n        userId: event.eventData.userId,\n        userEmail: user.email,\n        cartId: event.eventData.cartId,\n        items: event.eventData.items,\n        abandonedAt: event.occurredAt,\n      });\n\n      // Track abandonment for analytics\n      await this.trackCartAbandonment({\n        userId: event.eventData.userId,\n        cartId: event.eventData.cartId,\n        itemCount: event.eventData.items.length,\n        abandonedAt: event.occurredAt,\n      });\n\n      logger.info('CartAbandonmentTrackingHandler.handle', context);\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Cart abandonment tracking failed');\n      logger.error('CartAbandonmentTrackingHandler.handle', err, context);\n      return Result.error(err);\n    }\n  }\n\n  private async scheduleAbandonmentEmail(data: {\n    userId: string;\n    userEmail: string;\n    cartId: string;\n    items: any[];\n    abandonedAt: Date;\n  }): Promise<void> {\n    // In a real implementation, this would integrate with an email service\n    // like SendGrid, Mailchimp, or AWS SES\n    logger.info('Cart abandonment email scheduled', {\n      email: {\n        to: data.userEmail,\n        template: 'cart_abandonment',\n        data: {\n          cartId: data.cartId,\n          itemCount: data.items.length,\n          abandonedAt: data.abandonedAt,\n        },\n      },\n    });\n  }\n\n  private async trackCartAbandonment(data: {\n    userId: string;\n    cartId: string;\n    itemCount: number;\n    abandonedAt: Date;\n  }): Promise<void> {\n    logger.info('Cart abandonment tracked', {\n      analytics: {\n        event: 'cart_abandoned',\n        ...data,\n      },\n    });\n  }\n}\n\n/**\n * Product Recommendation Update Handler\n * \n * Updates recommendation engine based on cart activity\n */\nexport class ProductRecommendationUpdateHandler implements EventHandler {\n  readonly eventType = EventTypes.CART_ITEM_ADDED;\n\n  async handle(event: DomainEvent<CartItemAddedEventData>): Promise<Result<void, Error>> {\n    const context = createSimpleContext('recommendation_update_handler', 'recommendations', {\n      eventId: event.eventId,\n      userId: event.eventData.userId,\n      productId: event.eventData.productId,\n    });\n\n    logger.info('ProductRecommendationUpdateHandler.handle', context);\n\n    try {\n      // Update user's product affinity score\n      await this.updateProductAffinity({\n        userId: event.eventData.userId,\n        productId: event.eventData.productId,\n        action: 'cart_add',\n        timestamp: event.occurredAt,\n      });\n\n      // Update product co-occurrence matrix for \"frequently bought together\"\n      await this.updateProductCoOccurrence({\n        userId: event.eventData.userId,\n        productId: event.eventData.productId,\n        cartId: event.aggregateId,\n      });\n\n      logger.info('ProductRecommendationUpdateHandler.handle', context);\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Recommendation update failed');\n      logger.error('ProductRecommendationUpdateHandler.handle', err, context);\n      return Result.error(err);\n    }\n  }\n\n  private async updateProductAffinity(data: {\n    userId: string;\n    productId: string;\n    action: string;\n    timestamp: Date;\n  }): Promise<void> {\n    // In a real implementation, this would update a recommendation engine\n    // or machine learning model with user preference data\n    logger.info('Product affinity updated', {\n      recommendations: {\n        ...data,\n        actionType: 'update_affinity',\n      },\n    });\n  }\n\n  private async updateProductCoOccurrence(data: {\n    userId: string;\n    productId: string;\n    cartId: string;\n  }): Promise<void> {\n    // Update frequently bought together recommendations\n    logger.info('Product co-occurrence updated', {\n      recommendations: {\n        action: 'update_co_occurrence',\n        ...data,\n      },\n    });\n  }\n}\n\n/**\n * Multi-event handler for cart item removal\n */\nexport class CartItemRemovedEventHandler implements EventHandler {\n  readonly eventType = EventTypes.CART_ITEM_REMOVED;\n\n  async handle(event: DomainEvent<CartItemRemovedEventData>): Promise<Result<void, Error>> {\n    const context = createSimpleContext('cart_item_removed_handler', 'cart', {\n      eventId: event.eventId,\n      userId: event.eventData.userId,\n      productId: event.eventData.productId,\n    });\n\n    logger.info('CartItemRemovedEventHandler.handle', context);\n\n    try {\n      const productRepository = await resolveService<IProductRepository>(SERVICE_TOKENS.PRODUCT_REPOSITORY);\n      \n      // Release reserved stock\n      const releaseResult = await productRepository.releaseStock(\n        event.eventData.productId,\n        event.eventData.quantity,\n        `cart_${event.aggregateId}`\n      );\n\n      if (releaseResult.isError()) {\n        logger.warn('Failed to release reserved stock', {\n          productId: event.eventData.productId,\n          quantity: event.eventData.quantity,\n          error: releaseResult.getError().message,\n        });\n      }\n\n      // Track removal for analytics\n      logger.info('Cart item removal tracked', {\n        analytics: {\n          event: 'cart_item_removed',\n          userId: event.eventData.userId,\n          productId: event.eventData.productId,\n          quantity: event.eventData.quantity,\n          timestamp: event.occurredAt,\n        },\n      });\n\n      logger.info('CartItemRemovedEventHandler.handle', context);\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Cart item removal handling failed');\n      logger.error('CartItemRemovedEventHandler.handle', err, context);\n      return Result.error(err);\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\handlers\\cart.event-handler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":106,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":106,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":132,"column":52,"nodeType":null,"messageId":"unusedVar","endLine":132,"endColumn":58}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Cart Event Handler\n * \n * Gère tous les événements du domaine panier avec une approche unifiée.\n */\n\nimport { Result } from \"@/lib/core/result\";\nimport { BusinessError } from \"@/lib/core/errors\";\nimport type { DomainEvent, EventStore } from \"@/lib/core/events\";\nimport type { SupabaseCartRepository } from \"../../repositories/cart.repository\";\nimport { logger, Logger } from \"@/lib/core/logger\";\n\ninterface CartItemAddedEventData {\n  productId: string;\n  quantity: number;\n  userId: string;\n  cartId: string;\n  productName?: string;\n  productPrice?: number;\n}\n\ninterface CartItemRemovedEventData {\n  itemId: string;\n  productId: string;\n  userId: string;\n  cartId: string;\n  quantity: number;\n}\n\ninterface CartItemQuantityUpdatedEventData {\n  itemId: string;\n  productId: string;\n  userId: string;\n  cartId: string;\n  oldQuantity: number;\n  newQuantity: number;\n}\n\ninterface CartClearedEventData {\n  userId: string;\n  cartId: string;\n  itemCount: number;\n}\n\nexport class CartEventHandler {\n  constructor(\n    private readonly cartRepository: SupabaseCartRepository,\n    private readonly eventStore: EventStore,\n    private readonly logger: Logger = logger\n  ) {}\n\n  async handle(event: DomainEvent): Promise<Result<void, BusinessError>> {\n    try {\n      switch (event.eventType) {\n        case 'CART_ITEM_ADDED':\n          return await this.handleCartItemAdded(event as DomainEvent<CartItemAddedEventData>);\n        case 'CART_ITEM_REMOVED':\n          return await this.handleCartItemRemoved(event as DomainEvent<CartItemRemovedEventData>);\n        case 'CART_ITEM_QUANTITY_UPDATED':\n          return await this.handleCartItemQuantityUpdated(event as DomainEvent<CartItemQuantityUpdatedEventData>);\n        case 'CART_CLEARED':\n          return await this.handleCartCleared(event as DomainEvent<CartClearedEventData>);\n        default:\n          this.logger.warn('Unhandled cart event type', { eventType: event.eventType });\n          return Result.ok(undefined);\n      }\n    } catch (error) {\n      this.logger.error('Cart event handler error', { error, event });\n      return Result.error(new BusinessError('Cart event handling failed', { error, event }));\n    }\n  }\n\n  async handleCartItemAdded(event: DomainEvent<CartItemAddedEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { productId, quantity, userId, cartId } = event.eventData;\n\n      this.logger.info('Processing cart item added', {\n        cartId,\n        productId,\n        quantity,\n        userId,\n        eventId: event.eventId\n      });\n\n      // Ici on pourrait :\n      // - Mettre à jour des statistiques du panier\n      // - Déclencher des règles métier\n      // - Synchroniser avec des services externes\n      \n      // Pour les tests, on log simplement\n      this.logger.debug('Cart item added processed successfully', {\n        cartId,\n        productId,\n        eventId: event.eventId\n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to handle cart item added', error);\n      return Result.error(new BusinessError('Failed to process cart item added event', { error }));\n    }\n  }\n\n  async handleCartItemRemoved(event: DomainEvent<CartItemRemovedEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { productId, quantity, userId, cartId, itemId } = event.eventData;\n\n      this.logger.info('Processing cart item removed', {\n        cartId,\n        productId,\n        quantity,\n        itemId,\n        eventId: event.eventId\n      });\n\n      // Traitement spécifique au retrait d'article\n      this.logger.debug('Cart item removed processed successfully', {\n        cartId,\n        productId,\n        eventId: event.eventId\n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to handle cart item removed', error);\n      return Result.error(new BusinessError('Failed to process cart item removed event', { error }));\n    }\n  }\n\n  async handleCartItemQuantityUpdated(event: DomainEvent<CartItemQuantityUpdatedEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { productId, oldQuantity, newQuantity, userId, cartId } = event.eventData;\n\n      this.logger.info('Processing cart item quantity update', {\n        cartId,\n        productId,\n        oldQuantity,\n        newQuantity,\n        eventId: event.eventId\n      });\n\n      // Traitement spécifique à la mise à jour de quantité\n      this.logger.debug('Cart item quantity updated processed successfully', {\n        cartId,\n        productId,\n        quantityChange: newQuantity - oldQuantity,\n        eventId: event.eventId\n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to handle cart item quantity update', error);\n      return Result.error(new BusinessError('Failed to process cart item quantity update event', { error }));\n    }\n  }\n\n  async handleCartCleared(event: DomainEvent<CartClearedEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { userId, cartId, itemCount } = event.eventData;\n\n      this.logger.info('Processing cart cleared', {\n        cartId,\n        userId,\n        itemCount,\n        eventId: event.eventId\n      });\n\n      // Traitement spécifique à la vidange du panier\n      this.logger.debug('Cart cleared processed successfully', {\n        cartId,\n        itemCount,\n        eventId: event.eventId\n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to handle cart cleared', error);\n      return Result.error(new BusinessError('Failed to process cart cleared event', { error }));\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\handlers\\inventory.event-handler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Inventory Event Handler\n */\n\nimport { Result } from \"@/lib/core/result\";\nimport { BusinessError } from \"@/lib/core/errors\";\nimport type { DomainEvent, EventStore } from \"@/lib/core/events\";\nimport type { SupabaseProductRepository } from \"../../repositories/product.repository\";\nimport { logger, Logger } from \"@/lib/core/logger\";\n\ninterface ProductStockUpdatedEventData {\n  productId: string;\n  oldStock: number;\n  newStock: number;\n}\n\ninterface ProductPriceChangedEventData {\n  productId: string;\n  oldPrice: number;\n  newPrice: number;\n}\n\ninterface ProductReservedEventData {\n  productId: string;\n  quantity: number;\n}\n\nexport class InventoryEventHandler {\n  constructor(\n    private readonly productRepository: SupabaseProductRepository,\n    private readonly eventStore: EventStore,\n    private readonly logger: Logger = logger\n  ) {}\n\n  async handle(event: DomainEvent): Promise<Result<void, BusinessError>> {\n    try {\n      switch (event.eventType) {\n        case 'PRODUCT_STOCK_UPDATED':\n          return await this.handleProductStockUpdated(event as DomainEvent<ProductStockUpdatedEventData>);\n        case 'PRODUCT_PRICE_CHANGED':\n          return await this.handleProductPriceChanged(event as DomainEvent<ProductPriceChangedEventData>);\n        default:\n          this.logger.warn('Unhandled inventory event type', { eventType: event.eventType });\n          return Result.ok(undefined);\n      }\n    } catch (error) {\n      this.logger.error('Inventory event handler error', { error, event });\n      return Result.error(new BusinessError('Inventory event handling failed', { error, event }));\n    }\n  }\n\n  async handleProductStockUpdated(event: DomainEvent<ProductStockUpdatedEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { productId, oldStock, newStock } = event.eventData;\n      this.logger.info('Processing product stock updated', { productId, oldStock, newStock, eventId: event.eventId });\n      return Result.ok(undefined);\n    } catch (error) {\n      return Result.error(new BusinessError('Failed to process product stock updated event', { error }));\n    }\n  }\n\n  async handleProductPriceChanged(event: DomainEvent<ProductPriceChangedEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { productId, oldPrice, newPrice } = event.eventData;\n      this.logger.info('Processing product price changed', { productId, oldPrice, newPrice, eventId: event.eventId });\n      return Result.ok(undefined);\n    } catch (error) {\n      return Result.error(new BusinessError('Failed to process product price changed event', { error }));\n    }\n  }\n\n  async reserveStock(event: DomainEvent<ProductReservedEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { productId, quantity } = event.eventData;\n      this.logger.info('Reserving stock', { productId, quantity, eventId: event.eventId });\n      return Result.ok(undefined);\n    } catch (error) {\n      return Result.error(new BusinessError('Failed to reserve stock', { error }));\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\handlers\\notification.event-handler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Notification Event Handler\n */\n\nimport { Result } from \"@/lib/core/result\";\nimport { BusinessError } from \"@/lib/core/errors\";\nimport type { DomainEvent, EventStore } from \"@/lib/core/events\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport { logger, Logger } from \"@/lib/core/logger\";\n\ninterface CartNotificationEventData {\n  userId: string;\n  cartId: string;\n}\n\nexport class NotificationEventHandler {\n  constructor(\n    private readonly supabaseClient: SupabaseClient,\n    private readonly eventStore: EventStore,\n    private readonly logger: Logger = logger\n  ) {}\n\n  async handle(event: DomainEvent): Promise<Result<void, BusinessError>> {\n    try {\n      this.logger.info('Processing notification event', { eventType: event.eventType, eventId: event.eventId });\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Notification event handler error', { error, event });\n      return Result.error(new BusinessError('Notification event handling failed', { error, event }));\n    }\n  }\n\n  async sendCartNotification(event: DomainEvent<CartNotificationEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { userId, cartId } = event.eventData;\n      this.logger.info('Sending cart notification', { userId, cartId, eventId: event.eventId });\n      return Result.ok(undefined);\n    } catch (error) {\n      return Result.error(new BusinessError('Failed to send cart notification', { error }));\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\handlers\\order-event-handlers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[556,559],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[556,559],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1153,1156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1153,1156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1176,1179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1176,1179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":213,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6830,6833],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6830,6833],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Order Domain Event Handlers\n * \n * Handles order-related events for:\n * - Payment processing\n * - Inventory management\n * - Email notifications\n * - Analytics and reporting\n * - External integrations\n */\n\nimport { DomainEvent, EventHandler, EventTypes } from '@/lib/core/events';\nimport { Result } from '@/lib/core/result';\nimport { logger } from '@/lib/core/logger';\nimport { resolveService } from '@/lib/infrastructure/container/container.config';\n\n// Temporary helper function\nfunction createSimpleContext(action: string, resource: string, data: any = {}) {\n  return { action, resource, ...data };\n}\nimport { SERVICE_TOKENS } from '@/lib/infrastructure/container/container';\nimport type { IProductRepository } from '@/lib/domain/interfaces/product.repository.interface';\nimport type { IUserRepository } from '@/lib/domain/interfaces/user.repository.interface';\n\n/**\n * Order Created Event Data\n */\ninterface OrderCreatedEventData {\n  orderId: string;\n  userId: string;\n  items: Array<{\n    productId: string;\n    quantity: number;\n    price: number;\n    productName: string;\n  }>;\n  totalAmount: number;\n  currency: string;\n  shippingAddress: any;\n  billingAddress: any;\n  paymentMethod: string;\n}\n\n/**\n * Order Paid Event Data\n */\ninterface OrderPaidEventData {\n  orderId: string;\n  userId: string;\n  paymentId: string;\n  amount: number;\n  currency: string;\n  paymentMethod: string;\n  paidAt: Date;\n}\n\n/**\n * Order Confirmed Event Data\n */\ninterface OrderConfirmedEventData {\n  orderId: string;\n  userId: string;\n  confirmationNumber: string;\n  estimatedDelivery: Date;\n}\n\n/**\n * Order Inventory Update Handler\n * \n * Updates product inventory when orders are confirmed\n */\nexport class OrderInventoryUpdateHandler implements EventHandler {\n  readonly eventType = EventTypes.ORDER_CONFIRMED;\n\n  async handle(event: DomainEvent<OrderConfirmedEventData>): Promise<Result<void, Error>> {\n    const context = createSimpleContext('order_inventory_handler', 'inventory', {\n      eventId: event.eventId,\n      orderId: event.eventData.orderId,\n      userId: event.eventData.userId,\n    });\n\n    logger.info('OrderInventoryUpdateHandler.handle', context);\n\n    try {\n      // Get order details to update inventory\n      const orderDetails = await this.getOrderDetails(event.eventData.orderId);\n      if (!orderDetails) {\n        return Result.error(new Error(`Order not found: ${event.eventData.orderId}`));\n      }\n\n      const productRepository = await resolveService<IProductRepository>(SERVICE_TOKENS.PRODUCT_REPOSITORY);\n      \n      // Update stock for each item in the order\n      const stockUpdates = await Promise.allSettled(\n        orderDetails.items.map(async (item) => {\n          const updateResult = await productRepository.adjustStock({\n            product_id: item.productId,\n            quantity_delta: -item.quantity, // Reduce stock\n            reason: 'sale',\n            reference: event.eventData.orderId,\n          });\n\n          if (updateResult.isError()) {\n            logger.error('Failed to update stock for order item', {\n              orderId: event.eventData.orderId,\n              productId: item.productId,\n              quantity: item.quantity,\n              error: updateResult.getError().message,\n            });\n            throw updateResult.getError();\n          }\n\n          return updateResult.getValue();\n        })\n      );\n\n      // Check for any failures\n      const failures = stockUpdates.filter(result => result.status === 'rejected');\n      if (failures.length > 0) {\n        logger.error('Some inventory updates failed', {\n          orderId: event.eventData.orderId,\n          failureCount: failures.length,\n          totalItems: orderDetails.items.length,\n        });\n        // Continue processing but log the issue\n      }\n\n      logger.info('OrderInventoryUpdateHandler.handle', {\n        ...context,\n        itemsUpdated: stockUpdates.length - failures.length,\n        itemsFailed: failures.length,\n      });\n\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Order inventory update failed');\n      logger.error('OrderInventoryUpdateHandler.handle', err, context);\n      return Result.error(err);\n    }\n  }\n\n  private async getOrderDetails(orderId: string): Promise<OrderCreatedEventData | null> {\n    // In a real implementation, this would fetch from the order repository\n    // For now, we'll simulate with a placeholder\n    logger.debug('Fetching order details', { orderId });\n    return null; // Would return actual order data\n  }\n}\n\n/**\n * Order Confirmation Email Handler\n * \n * Sends confirmation emails when orders are placed or updated\n */\nexport class OrderConfirmationEmailHandler implements EventHandler {\n  readonly eventType = EventTypes.ORDER_CREATED;\n\n  async handle(event: DomainEvent<OrderCreatedEventData>): Promise<Result<void, Error>> {\n    const context = createSimpleContext('order_email_handler', 'email', {\n      eventId: event.eventId,\n      orderId: event.eventData.orderId,\n      userId: event.eventData.userId,\n    });\n\n    logger.info('OrderConfirmationEmailHandler.handle', context);\n\n    try {\n      const userRepository = await resolveService<IUserRepository>(SERVICE_TOKENS.USER_REPOSITORY);\n      \n      // Get user information\n      const userResult = await userRepository.findByIdWithProfile(event.eventData.userId);\n      if (userResult.isError()) {\n        return Result.error(new Error(`Failed to get user: ${userResult.getError().message}`));\n      }\n\n      const user = userResult.getValue();\n      if (!user) {\n        return Result.error(new Error(`User not found: ${event.eventData.userId}`));\n      }\n\n      // Send order confirmation email\n      await this.sendOrderConfirmationEmail({\n        recipientEmail: user.email,\n        recipientName: (user.profile?.first_name && user.profile?.last_name) \n          ? `${user.profile.first_name} ${user.profile.last_name}` \n          : user.email,\n        order: event.eventData,\n        templateData: {\n          orderNumber: event.eventData.orderId,\n          orderDate: event.occurredAt,\n          items: event.eventData.items,\n          totalAmount: event.eventData.totalAmount,\n          currency: event.eventData.currency,\n          shippingAddress: event.eventData.shippingAddress,\n        },\n      });\n\n      logger.info('OrderConfirmationEmailHandler.handle', context);\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Order confirmation email failed');\n      logger.error('OrderConfirmationEmailHandler.handle', err, context);\n      return Result.error(err);\n    }\n  }\n\n  private async sendOrderConfirmationEmail(data: {\n    recipientEmail: string;\n    recipientName: string;\n    order: OrderCreatedEventData;\n    templateData: any;\n  }): Promise<void> {\n    // In a real implementation, this would integrate with an email service\n    logger.info('Order confirmation email sent', {\n      email: {\n        to: data.recipientEmail,\n        template: 'order_confirmation',\n        orderId: data.order.orderId,\n        totalAmount: data.order.totalAmount,\n      },\n    });\n  }\n}\n\n/**\n * Order Analytics Handler\n * \n * Tracks order events for business intelligence\n */\nexport class OrderAnalyticsHandler implements EventHandler {\n  readonly eventType = EventTypes.ORDER_PAID;\n\n  async handle(event: DomainEvent<OrderPaidEventData>): Promise<Result<void, Error>> {\n    const context = createSimpleContext('order_analytics_handler', 'analytics', {\n      eventId: event.eventId,\n      orderId: event.eventData.orderId,\n      userId: event.eventData.userId,\n    });\n\n    logger.info('OrderAnalyticsHandler.handle', context);\n\n    try {\n      // Track order payment for analytics\n      await this.trackOrderPayment({\n        orderId: event.eventData.orderId,\n        userId: event.eventData.userId,\n        amount: event.eventData.amount,\n        currency: event.eventData.currency,\n        paymentMethod: event.eventData.paymentMethod,\n        paidAt: event.eventData.paidAt,\n        timestamp: event.occurredAt,\n      });\n\n      // Update customer lifetime value\n      await this.updateCustomerLifetimeValue({\n        userId: event.eventData.userId,\n        orderValue: event.eventData.amount,\n        currency: event.eventData.currency,\n      });\n\n      // Track conversion funnel\n      await this.trackConversionFunnel({\n        userId: event.eventData.userId,\n        orderId: event.eventData.orderId,\n        conversionStep: 'payment_completed',\n        timestamp: event.occurredAt,\n      });\n\n      logger.info('OrderAnalyticsHandler.handle', context);\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Order analytics tracking failed');\n      logger.error('OrderAnalyticsHandler.handle', err, context);\n      return Result.error(err);\n    }\n  }\n\n  private async trackOrderPayment(data: {\n    orderId: string;\n    userId: string;\n    amount: number;\n    currency: string;\n    paymentMethod: string;\n    paidAt: Date;\n    timestamp: Date;\n  }): Promise<void> {\n    logger.info('Order payment tracked', {\n      analytics: {\n        event: 'order_payment_completed',\n        ...data,\n      },\n    });\n  }\n\n  private async updateCustomerLifetimeValue(data: {\n    userId: string;\n    orderValue: number;\n    currency: string;\n  }): Promise<void> {\n    logger.info('Customer lifetime value updated', {\n      analytics: {\n        action: 'update_clv',\n        ...data,\n      },\n    });\n  }\n\n  private async trackConversionFunnel(data: {\n    userId: string;\n    orderId: string;\n    conversionStep: string;\n    timestamp: Date;\n  }): Promise<void> {\n    logger.info('Conversion funnel tracked', {\n      analytics: {\n        action: 'track_conversion',\n        ...data,\n      },\n    });\n  }\n}\n\n/**\n * Order Fulfillment Handler\n * \n * Initiates fulfillment process when orders are confirmed\n */\nexport class OrderFulfillmentHandler implements EventHandler {\n  readonly eventType = EventTypes.ORDER_CONFIRMED;\n\n  async handle(event: DomainEvent<OrderConfirmedEventData>): Promise<Result<void, Error>> {\n    const context = createSimpleContext('order_fulfillment_handler', 'fulfillment', {\n      eventId: event.eventId,\n      orderId: event.eventData.orderId,\n      confirmationNumber: event.eventData.confirmationNumber,\n    });\n\n    logger.info('OrderFulfillmentHandler.handle', context);\n\n    try {\n      // Create fulfillment request\n      await this.createFulfillmentRequest({\n        orderId: event.eventData.orderId,\n        confirmationNumber: event.eventData.confirmationNumber,\n        estimatedDelivery: event.eventData.estimatedDelivery,\n        priority: this.calculateFulfillmentPriority(event.eventData),\n      });\n\n      // Notify warehouse system\n      await this.notifyWarehouseSystem({\n        orderId: event.eventData.orderId,\n        confirmationNumber: event.eventData.confirmationNumber,\n        userId: event.eventData.userId,\n      });\n\n      logger.info('OrderFulfillmentHandler.handle', context);\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Order fulfillment initiation failed');\n      logger.error('OrderFulfillmentHandler.handle', err, context);\n      return Result.error(err);\n    }\n  }\n\n  private async createFulfillmentRequest(data: {\n    orderId: string;\n    confirmationNumber: string;\n    estimatedDelivery: Date;\n    priority: 'standard' | 'expedited' | 'rush';\n  }): Promise<void> {\n    logger.info('Fulfillment request created', {\n      fulfillment: {\n        action: 'create_request',\n        ...data,\n      },\n    });\n  }\n\n  private async notifyWarehouseSystem(data: {\n    orderId: string;\n    confirmationNumber: string;\n    userId: string;\n  }): Promise<void> {\n    // In a real implementation, this would integrate with a warehouse management system\n    logger.info('Warehouse system notified', {\n      warehouse: {\n        action: 'order_notification',\n        ...data,\n      },\n    });\n  }\n\n  private calculateFulfillmentPriority(orderData: OrderConfirmedEventData): 'standard' | 'expedited' | 'rush' {\n    // Simple priority calculation (would be more sophisticated in real implementation)\n    const deliveryDays = Math.ceil((orderData.estimatedDelivery.getTime() - Date.now()) / (1000 * 60 * 60 * 24));\n    \n    if (deliveryDays <= 1) return 'rush';\n    if (deliveryDays <= 3) return 'expedited';\n    return 'standard';\n  }\n}\n\n/**\n * Order Status Update Handler\n * \n * Handles order status changes and notifications\n */\nexport class OrderStatusUpdateHandler implements EventHandler {\n  readonly eventType = EventTypes.ORDER_SHIPPED;\n\n  async handle(event: DomainEvent<{ \n    orderId: string; \n    userId: string; \n    trackingNumber: string; \n    carrier: string;\n    estimatedDelivery: Date;\n  }>): Promise<Result<void, Error>> {\n    const context = createSimpleContext('order_status_handler', 'orders', {\n      eventId: event.eventId,\n      orderId: event.eventData.orderId,\n      trackingNumber: event.eventData.trackingNumber,\n    });\n\n    logger.info('OrderStatusUpdateHandler.handle', context);\n\n    try {\n      const userRepository = await resolveService<IUserRepository>(SERVICE_TOKENS.USER_REPOSITORY);\n      \n      // Get user for notification\n      const userResult = await userRepository.findByIdWithProfile(event.eventData.userId);\n      if (userResult.isError()) {\n        logger.warn('Failed to get user for shipping notification', {\n          userId: event.eventData.userId,\n          error: userResult.getError().message,\n        });\n        return Result.ok(undefined); // Don't fail the event\n      }\n\n      const user = userResult.getValue();\n      if (!user) {\n        return Result.ok(undefined);\n      }\n\n      // Send shipping notification email\n      await this.sendShippingNotification({\n        recipientEmail: user.email,\n        recipientName: (user.profile?.first_name && user.profile?.last_name) \n          ? `${user.profile.first_name} ${user.profile.last_name}` \n          : user.email,\n        orderId: event.eventData.orderId,\n        trackingNumber: event.eventData.trackingNumber,\n        carrier: event.eventData.carrier,\n        estimatedDelivery: event.eventData.estimatedDelivery,\n      });\n\n      // Update order tracking\n      await this.updateOrderTracking({\n        orderId: event.eventData.orderId,\n        status: 'shipped',\n        trackingNumber: event.eventData.trackingNumber,\n        carrier: event.eventData.carrier,\n        updatedAt: event.occurredAt,\n      });\n\n      logger.info('OrderStatusUpdateHandler.handle', context);\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Order status update failed');\n      logger.error('OrderStatusUpdateHandler.handle', err, context);\n      return Result.error(err);\n    }\n  }\n\n  private async sendShippingNotification(data: {\n    recipientEmail: string;\n    recipientName: string;\n    orderId: string;\n    trackingNumber: string;\n    carrier: string;\n    estimatedDelivery: Date;\n  }): Promise<void> {\n    logger.info('Shipping notification sent', {\n      email: {\n        to: data.recipientEmail,\n        template: 'order_shipped',\n        orderId: data.orderId,\n        trackingNumber: data.trackingNumber,\n        carrier: data.carrier,\n      },\n    });\n  }\n\n  private async updateOrderTracking(data: {\n    orderId: string;\n    status: string;\n    trackingNumber: string;\n    carrier: string;\n    updatedAt: Date;\n  }): Promise<void> {\n    logger.info('Order tracking updated', {\n      tracking: {\n        action: 'status_update',\n        ...data,\n      },\n    });\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\handlers\\order.event-handler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Order Event Handler\n * \n * Gère tous les événements du domaine commandes.\n */\n\nimport { Result } from \"@/lib/core/result\";\nimport { BusinessError } from \"@/lib/core/errors\";\nimport type { DomainEvent, EventStore } from \"@/lib/core/events\";\nimport type { OrderSupabaseRepository } from \"../../repositories/order.supabase.repository\";\nimport { logger, Logger } from \"@/lib/core/logger\";\n\ninterface OrderCreatedEventData {\n  orderId: string;\n  userId: string;\n  totalAmount: number;\n  items: Array<{\n    productId: string;\n    quantity: number;\n    price: number;\n  }>;\n}\n\ninterface OrderConfirmedEventData {\n  orderId: string;\n  confirmationNumber: string;\n}\n\ninterface OrderShippedEventData {\n  orderId: string;\n  trackingNumber: string;\n}\n\ninterface OrderDeliveredEventData {\n  orderId: string;\n  deliveredAt: Date;\n}\n\ninterface OrderCancelledEventData {\n  orderId: string;\n  reason: string;\n  refundAmount: number;\n}\n\nexport class OrderEventHandler {\n  constructor(\n    private readonly orderRepository: OrderSupabaseRepository,\n    private readonly eventStore: EventStore,\n    private readonly logger: Logger = logger\n  ) {}\n\n  async handle(event: DomainEvent): Promise<Result<void, BusinessError>> {\n    try {\n      switch (event.eventType) {\n        case 'ORDER_CREATED':\n          return await this.handleOrderCreated(event as DomainEvent<OrderCreatedEventData>);\n        case 'ORDER_CONFIRMED':\n          return await this.handleOrderConfirmed(event as DomainEvent<OrderConfirmedEventData>);\n        case 'ORDER_SHIPPED':\n          return await this.handleOrderShipped(event as DomainEvent<OrderShippedEventData>);\n        case 'ORDER_DELIVERED':\n          return await this.handleOrderDelivered(event as DomainEvent<OrderDeliveredEventData>);\n        case 'ORDER_CANCELLED':\n          return await this.handleOrderCancelled(event as DomainEvent<OrderCancelledEventData>);\n        default:\n          this.logger.warn('Unhandled order event type', { eventType: event.eventType });\n          return Result.ok(undefined);\n      }\n    } catch (error) {\n      this.logger.error('Order event handler error', { error, event });\n      return Result.error(new BusinessError('Order event handling failed', { error, event }));\n    }\n  }\n\n  async handleOrderCreated(event: DomainEvent<OrderCreatedEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { orderId, userId, totalAmount, items } = event.eventData;\n\n      this.logger.info('Processing order created', {\n        orderId,\n        userId,\n        totalAmount,\n        itemCount: items?.length,\n        eventId: event.eventId\n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to handle order created', error);\n      return Result.error(new BusinessError('Failed to process order created event', { error }));\n    }\n  }\n\n  async handleOrderConfirmed(event: DomainEvent<OrderConfirmedEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { orderId, confirmationNumber } = event.eventData;\n\n      this.logger.info('Processing order confirmed', {\n        orderId,\n        confirmationNumber,\n        eventId: event.eventId\n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to handle order confirmed', error);\n      return Result.error(new BusinessError('Failed to process order confirmed event', { error }));\n    }\n  }\n\n  async handleOrderShipped(event: DomainEvent<OrderShippedEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { orderId, trackingNumber } = event.eventData;\n\n      this.logger.info('Processing order shipped', {\n        orderId,\n        trackingNumber,\n        eventId: event.eventId\n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to handle order shipped', error);\n      return Result.error(new BusinessError('Failed to process order shipped event', { error }));\n    }\n  }\n\n  async handleOrderDelivered(event: DomainEvent<OrderDeliveredEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { orderId, deliveredAt } = event.eventData;\n\n      this.logger.info('Processing order delivered', {\n        orderId,\n        deliveredAt,\n        eventId: event.eventId\n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to handle order delivered', error);\n      return Result.error(new BusinessError('Failed to process order delivered event', { error }));\n    }\n  }\n\n  async handleOrderCancelled(event: DomainEvent<OrderCancelledEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { orderId, reason, refundAmount } = event.eventData;\n\n      this.logger.info('Processing order cancelled', {\n        orderId,\n        reason,\n        refundAmount,\n        eventId: event.eventId\n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to handle order cancelled', error);\n      return Result.error(new BusinessError('Failed to process order cancelled event', { error }));\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\handlers\\user.event-handler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * User Event Handler\n */\n\nimport { Result } from \"@/lib/core/result\";\nimport { BusinessError } from \"@/lib/core/errors\";\nimport type { DomainEvent, EventStore } from \"@/lib/core/events\";\nimport type { UserSupabaseRepository } from \"../../repositories/user.supabase.repository\";\nimport { logger, Logger } from \"@/lib/core/logger\";\n\ninterface UserRegisteredEventData {\n  userId: string;\n  email: string;\n}\n\ninterface UserProfileUpdatedEventData {\n  userId: string;\n  updatedFields?: Record<string, unknown>;\n}\n\nexport class UserEventHandler {\n  constructor(\n    private readonly userRepository: UserSupabaseRepository,\n    private readonly eventStore: EventStore,\n    private readonly logger: Logger = logger\n  ) {}\n\n  async handle(event: DomainEvent): Promise<Result<void, BusinessError>> {\n    try {\n      switch (event.eventType) {\n        case 'USER_REGISTERED':\n          return await this.handleUserRegistered(event as DomainEvent<UserRegisteredEventData>);\n        case 'USER_PROFILE_UPDATED':\n          return await this.handleUserProfileUpdated(event as DomainEvent<UserProfileUpdatedEventData>);\n        default:\n          this.logger.warn('Unhandled user event type', { eventType: event.eventType });\n          return Result.ok(undefined);\n      }\n    } catch (error) {\n      this.logger.error('User event handler error', { error, event });\n      return Result.error(new BusinessError('User event handling failed', { error, event }));\n    }\n  }\n\n  async handleUserRegistered(event: DomainEvent<UserRegisteredEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { userId, email } = event.eventData;\n      this.logger.info('Processing user registered', { userId, email, eventId: event.eventId });\n      return Result.ok(undefined);\n    } catch (error) {\n      return Result.error(new BusinessError('Failed to process user registered event', { error }));\n    }\n  }\n\n  async handleUserProfileUpdated(event: DomainEvent<UserProfileUpdatedEventData>): Promise<Result<void, BusinessError>> {\n    try {\n      const { userId, updatedFields } = event.eventData;\n      this.logger.info('Processing user profile updated', { userId, updatedFields, eventId: event.eventId });\n      return Result.ok(undefined);\n    } catch (error) {\n      return Result.error(new BusinessError('Failed to process user profile updated event', { error }));\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\listeners\\audit.event-listener.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Audit Event Listener\n */\n\nimport type { DomainEvent } from \"@/lib/core/events\";\nimport type { AuditEventHandler } from \"../handlers/audit.event-handler\";\nimport { logger, Logger } from \"@/lib/core/logger\";\n\nexport class AuditEventListener {\n  constructor(\n    private readonly auditHandler: AuditEventHandler,\n    private readonly logger: Logger = logger\n  ) {}\n\n  async handleAuditEvent(event: DomainEvent): Promise<void> {\n    try {\n      this.logger.debug('Audit listener processing event', { eventType: event.eventType, eventId: event.eventId });\n      await this.auditHandler.handle(event);\n    } catch (error) {\n      this.logger.error('Audit event processing failed', { error, eventId: event.eventId });\n      // Ne pas propager l'erreur pour éviter de bloquer les autres handlers\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\listeners\\cart.event-listener.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Cart Event Listener\n * \n * Orchestre les événements du domaine panier en coordonnant\n * plusieurs handlers spécialisés.\n */\n\nimport type { DomainEvent } from \"@/lib/core/events\";\nimport type { CartEventHandler } from \"../handlers/cart.event-handler\";\nimport type { InventoryEventHandler } from \"../handlers/inventory.event-handler\";\nimport type { NotificationEventHandler } from \"../handlers/notification.event-handler\";\nimport type { AuditEventHandler } from \"../handlers/audit.event-handler\";\nimport { logger } from \"@/lib/core/logger\";\n\nexport class CartEventListener {\n  constructor(\n    private readonly cartHandler: CartEventHandler,\n    private readonly inventoryHandler: InventoryEventHandler,\n    private readonly notificationHandler: NotificationEventHandler,\n    private readonly auditHandler: AuditEventHandler,\n    private readonly logger: typeof logger\n  ) {}\n\n  async handleCartItemAdded(event: DomainEvent): Promise<void> {\n    try {\n      this.logger.info('Cart listener orchestrating item added event', { eventId: event.eventId });\n\n      // Orchestration parallèle des handlers\n      await Promise.all([\n        this.cartHandler.handle(event),\n        this.inventoryHandler.reserveStock(event),\n        this.notificationHandler.sendCartNotification(event),\n        this.auditHandler.logEvent(event)\n      ]);\n\n      this.logger.debug('Cart item added orchestration completed', { eventId: event.eventId });\n    } catch (error) {\n      this.logger.error('Cart item added orchestration failed', { error, eventId: event.eventId });\n      throw error;\n    }\n  }\n\n  async handleCartItemRemoved(event: DomainEvent): Promise<void> {\n    try {\n      this.logger.info('Cart listener orchestrating item removed event', { eventId: event.eventId });\n\n      await Promise.all([\n        this.cartHandler.handle(event),\n        this.inventoryHandler.handle(event),\n        this.auditHandler.logEvent(event)\n      ]);\n    } catch (error) {\n      this.logger.error('Cart item removed orchestration failed', { error, eventId: event.eventId });\n      throw error;\n    }\n  }\n\n  async handleCartItemQuantityUpdated(event: DomainEvent): Promise<void> {\n    try {\n      this.logger.info('Cart listener orchestrating quantity update event', { eventId: event.eventId });\n\n      await Promise.all([\n        this.cartHandler.handle(event),\n        this.inventoryHandler.handle(event),\n        this.auditHandler.logEvent(event)\n      ]);\n    } catch (error) {\n      this.logger.error('Cart quantity update orchestration failed', { error, eventId: event.eventId });\n      throw error;\n    }\n  }\n\n  async handleCartCleared(event: DomainEvent): Promise<void> {\n    try {\n      this.logger.info('Cart listener orchestrating cart cleared event', { eventId: event.eventId });\n\n      await Promise.all([\n        this.cartHandler.handle(event),\n        this.inventoryHandler.handle(event),\n        this.auditHandler.logEvent(event)\n      ]);\n    } catch (error) {\n      this.logger.error('Cart cleared orchestration failed', { error, eventId: event.eventId });\n      throw error;\n    }\n  }\n\n  async handleProductStockUpdated(event: DomainEvent): Promise<void> {\n    try {\n      this.logger.info('Cart listener handling product stock update', { eventId: event.eventId });\n\n      await Promise.all([\n        this.inventoryHandler.handle(event),\n        this.auditHandler.logEvent(event)\n      ]);\n    } catch (error) {\n      this.logger.error('Product stock update handling failed', { error, eventId: event.eventId });\n      throw error;\n    }\n  }\n\n  async handleProductPriceChanged(event: DomainEvent): Promise<void> {\n    try {\n      this.logger.info('Cart listener handling product price change', { eventId: event.eventId });\n\n      await Promise.all([\n        this.inventoryHandler.handle(event),\n        this.notificationHandler.handle(event),\n        this.auditHandler.logEvent(event)\n      ]);\n    } catch (error) {\n      this.logger.error('Product price change handling failed', { error, eventId: event.eventId });\n      throw error;\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\listeners\\notification.event-listener.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Notification Event Listener\n */\n\nimport type { DomainEvent } from \"@/lib/core/events\";\nimport type { NotificationEventHandler } from \"../handlers/notification.event-handler\";\nimport type { UserEventHandler } from \"../handlers/user.event-handler\";\nimport { logger } from \"@/lib/core/logger\";\n\nexport class NotificationEventListener {\n  constructor(\n    private readonly notificationHandler: NotificationEventHandler,\n    private readonly userHandler: UserEventHandler,\n    private readonly logger: typeof logger\n  ) {}\n\n  async handleUserRegistered(event: DomainEvent): Promise<void> {\n    try {\n      this.logger.info('Notification listener orchestrating user registered event', { eventId: event.eventId });\n\n      await Promise.all([\n        this.notificationHandler.handle(event),\n        this.userHandler.handle(event)\n      ]);\n    } catch (error) {\n      this.logger.error('User registered orchestration failed', { error, eventId: event.eventId });\n      throw error;\n    }\n  }\n\n  async handleUserProfileUpdated(event: DomainEvent): Promise<void> {\n    try {\n      await Promise.all([\n        this.notificationHandler.handle(event),\n        this.userHandler.handle(event)\n      ]);\n    } catch (error) {\n      this.logger.error('User profile updated orchestration failed', { error, eventId: event.eventId });\n      throw error;\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\listeners\\order-workflow.event-listener.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Order Workflow Event Listener\n */\n\nimport type { DomainEvent } from \"@/lib/core/events\";\nimport type { OrderEventHandler } from \"../handlers/order.event-handler\";\nimport type { InventoryEventHandler } from \"../handlers/inventory.event-handler\";\nimport type { NotificationEventHandler } from \"../handlers/notification.event-handler\";\nimport type { AuditEventHandler } from \"../handlers/audit.event-handler\";\nimport { logger } from \"@/lib/core/logger\";\n\nexport class OrderWorkflowEventListener {\n  constructor(\n    private readonly orderHandler: OrderEventHandler,\n    private readonly inventoryHandler: InventoryEventHandler,\n    private readonly notificationHandler: NotificationEventHandler,\n    private readonly auditHandler: AuditEventHandler,\n    private readonly logger: typeof logger\n  ) {}\n\n  async handleOrderCreated(event: DomainEvent): Promise<void> {\n    try {\n      this.logger.info('Order workflow orchestrating order created event', { eventId: event.eventId });\n\n      await Promise.all([\n        this.orderHandler.handle(event),\n        this.inventoryHandler.handle(event),\n        this.notificationHandler.handle(event),\n        this.auditHandler.logEvent(event)\n      ]);\n    } catch (error) {\n      this.logger.error('Order created orchestration failed', { error, eventId: event.eventId });\n      throw error;\n    }\n  }\n\n  async handleOrderConfirmed(event: DomainEvent): Promise<void> {\n    try {\n      await Promise.all([\n        this.orderHandler.handle(event),\n        this.notificationHandler.handle(event),\n        this.auditHandler.logEvent(event)\n      ]);\n    } catch (error) {\n      this.logger.error('Order confirmed orchestration failed', { error, eventId: event.eventId });\n      throw error;\n    }\n  }\n\n  async handleOrderShipped(event: DomainEvent): Promise<void> {\n    try {\n      await Promise.all([\n        this.orderHandler.handle(event),\n        this.notificationHandler.handle(event),\n        this.auditHandler.logEvent(event)\n      ]);\n    } catch (error) {\n      this.logger.error('Order shipped orchestration failed', { error, eventId: event.eventId });\n      throw error;\n    }\n  }\n\n  async handleOrderDelivered(event: DomainEvent): Promise<void> {\n    try {\n      await Promise.all([\n        this.orderHandler.handle(event),\n        this.notificationHandler.handle(event),\n        this.auditHandler.logEvent(event)\n      ]);\n    } catch (error) {\n      this.logger.error('Order delivered orchestration failed', { error, eventId: event.eventId });\n      throw error;\n    }\n  }\n\n  async handleOrderCancelled(event: DomainEvent): Promise<void> {\n    try {\n      await Promise.all([\n        this.orderHandler.handle(event),\n        this.inventoryHandler.handle(event),\n        this.notificationHandler.handle(event),\n        this.auditHandler.logEvent(event)\n      ]);\n    } catch (error) {\n      this.logger.error('Order cancelled orchestration failed', { error, eventId: event.eventId });\n      throw error;\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\simple-event-bus.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Simple Event Bus Implementation\n * \n * Version simplifiée pour l'architecture Event-Driven avec les listeners.\n */\n\nimport { Result } from '@/lib/core/result';\nimport { BusinessError } from '@/lib/core/errors';\nimport type { DomainEvent, EventBus } from '@/lib/core/events';\nimport { logger } from '@/lib/core/logger';\n\nexport class SimpleEventBus implements EventBus {\n  private subscribers = new Map<string, Set<(event: DomainEvent) => Promise<void>>>();\n\n  constructor(private readonly logger: typeof logger) {}\n\n  /**\n   * Subscribe a handler function to a specific event type\n   */\n  async subscribe(eventType: string, handler: (event: DomainEvent) => Promise<void>): Promise<void> {\n    const handlers = this.subscribers.get(eventType) || new Set();\n    handlers.add(handler);\n    this.subscribers.set(eventType, handlers);\n    \n    this.logger.debug('Event handler subscribed', { eventType, handlerCount: handlers.size });\n  }\n\n  /**\n   * Unsubscribe a handler from an event type\n   */\n  async unsubscribe(eventType: string, handler: (event: DomainEvent) => Promise<void>): Promise<void> {\n    const handlers = this.subscribers.get(eventType);\n    if (handlers) {\n      handlers.delete(handler);\n      if (handlers.size === 0) {\n        this.subscribers.delete(eventType);\n      }\n    }\n  }\n\n  /**\n   * Publish a single event\n   */\n  async publish(event: DomainEvent): Promise<Result<void, BusinessError>> {\n    try {\n      this.logger.info('Publishing event', {\n        eventId: event.eventId,\n        eventType: event.eventType,\n        aggregateId: event.aggregateId\n      });\n\n      const handlers = this.subscribers.get(event.eventType);\n      if (!handlers || handlers.size === 0) {\n        this.logger.warn('No handlers found for event type', { eventType: event.eventType });\n        return Result.ok(undefined);\n      }\n\n      // Exécuter tous les handlers en parallèle\n      const handlerPromises = Array.from(handlers).map(async (handler) => {\n        try {\n          await handler(event);\n        } catch (error) {\n          this.logger.error('Handler failed', { \n            error, \n            eventType: event.eventType, \n            eventId: event.eventId \n          });\n          // Ne pas faire échouer les autres handlers\n        }\n      });\n\n      await Promise.allSettled(handlerPromises);\n\n      this.logger.debug('Event published successfully', {\n        eventType: event.eventType,\n        eventId: event.eventId,\n        handlerCount: handlers.size\n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to publish event', { error, event });\n      return Result.error(new BusinessError('Failed to publish event', { error, event }));\n    }\n  }\n\n  /**\n   * Publish multiple events as a batch\n   */\n  async publishBatch(events: DomainEvent[]): Promise<Result<void, BusinessError>> {\n    try {\n      this.logger.info('Publishing event batch', { eventCount: events.length });\n\n      const publishPromises = events.map(event => this.publish(event));\n      const results = await Promise.allSettled(publishPromises);\n\n      const successful = results.filter(r => r.status === 'fulfilled').length;\n      const failed = results.filter(r => r.status === 'rejected').length;\n\n      this.logger.info('Event batch published', {\n        total: events.length,\n        successful,\n        failed\n      });\n\n      return Result.ok(undefined);\n    } catch (error) {\n      this.logger.error('Failed to publish event batch', { error, eventCount: events.length });\n      return Result.error(new BusinessError('Failed to publish event batch', { error }));\n    }\n  }\n\n  /**\n   * Get statistics about the event bus\n   */\n  getStatistics(): {\n    subscribedHandlers: number;\n    eventTypes: string[];\n    handlersByType: Record<string, number>;\n  } {\n    const eventTypes = Array.from(this.subscribers.keys());\n    const handlersByType: Record<string, number> = {};\n    let totalHandlers = 0;\n\n    for (const [eventType, handlers] of this.subscribers.entries()) {\n      handlersByType[eventType] = handlers.size;\n      totalHandlers += handlers.size;\n    }\n\n    return {\n      subscribedHandlers: totalHandlers,\n      eventTypes,\n      handlersByType\n    };\n  }\n\n  /**\n   * Clear all subscriptions (useful for testing)\n   */\n  clear(): void {\n    this.subscribers.clear();\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\events\\supabase-event-store.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[601,604],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[601,604],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[852,855],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[852,855],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1384,1387],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1384,1387],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":375,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":375,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11287,11290],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11287,11290],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Supabase Event Store Implementation\n * \n * Provides persistent event storage using Supabase with:\n * - Event sourcing capabilities\n * - Event replay functionality\n * - Optimistic concurrency control\n * - Event snapshots and compaction\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { \n  DomainEvent, \n  EventStore, \n  EventSerializer,\n  JsonEventSerializer \n} from '@/lib/core/events';\nimport { Result } from '@/lib/core/result';\nimport { logger } from '@/lib/core/logger';\n\n// Temporary helper function\nfunction createSimpleContext(action: string, resource: string, data: any = {}) {\n  return { action, resource, ...data };\n}\n\n/**\n * Event record as stored in Supabase\n */\ninterface StoredEventRecord {\n  id: string;\n  event_id: string;\n  event_type: string;\n  aggregate_id: string;\n  aggregate_type: string;\n  event_data: any; // JSONB in Supabase\n  version: number;\n  occurred_at: string; // ISO timestamp\n  user_id?: string;\n  correlation_id?: string;\n  causation_id?: string;\n  created_at: string;\n  checksum?: string; // For data integrity\n}\n\n/**\n * Event stream metadata\n */\ninterface EventStreamMetadata {\n  aggregate_id: string;\n  aggregate_type: string;\n  current_version: number;\n  first_event_id: string;\n  last_event_id: string;\n  event_count: number;\n  created_at: string;\n  updated_at: string;\n  snapshot_version?: number;\n  snapshot_data?: any;\n}\n\n/**\n * Supabase Event Store Implementation\n */\nexport class SupabaseEventStore implements EventStore {\n  private readonly eventsTable = 'domain_events';\n  private readonly streamsTable = 'event_streams';\n  private readonly serializer: EventSerializer;\n\n  constructor(\n    private readonly supabase: SupabaseClient,\n    serializer: EventSerializer = new JsonEventSerializer()\n  ) {\n    this.serializer = serializer;\n  }\n\n  /**\n   * Append a single event to the store\n   */\n  async append<T extends DomainEvent>(event: T): Promise<Result<void, Error>> {\n    const context = createSimpleContext('event_store_append', 'events', {\n      eventId: event.eventId,\n      eventType: event.eventType,\n      aggregateId: event.aggregateId,\n    });\n\n    logger.info('SupabaseEventStore.append', context);\n\n    try {\n      // Prepare event record\n      const eventRecord: Omit<StoredEventRecord, 'id' | 'created_at'> = {\n        event_id: event.eventId,\n        event_type: event.eventType,\n        aggregate_id: event.aggregateId,\n        aggregate_type: event.aggregateType,\n        event_data: event.eventData,\n        version: event.version,\n        occurred_at: event.occurredAt.toISOString(),\n        user_id: event.userId,\n        correlation_id: event.correlationId,\n        causation_id: event.causationId,\n        checksum: this.calculateChecksum(event),\n      };\n\n      // Use a transaction to ensure consistency\n      const { error: transactionError } = await this.supabase.rpc('append_event_with_stream_update', {\n        p_event: eventRecord,\n        p_aggregate_id: event.aggregateId,\n        p_aggregate_type: event.aggregateType,\n        p_expected_version: event.version - 1, // Optimistic concurrency control\n      });\n\n      if (transactionError) {\n        const error = new Error(`Failed to append event: ${transactionError.message}`);\n        logger.error('SupabaseEventStore.append', error, context);\n        return Result.error(error);\n      }\n\n      logger.info('SupabaseEventStore.append', context);\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Unknown event store error');\n      logger.error('SupabaseEventStore.append', err, context);\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Append multiple events as a batch (atomic operation)\n   */\n  async appendBatch<T extends DomainEvent>(events: T[]): Promise<Result<void, Error>> {\n    if (events.length === 0) {\n      return Result.ok(undefined);\n    }\n\n    const context = createSimpleContext('event_store_append_batch', 'events', {\n      eventCount: events.length,\n      aggregateIds: [...new Set(events.map(e => e.aggregateId))],\n      eventTypes: [...new Set(events.map(e => e.eventType))],\n    });\n\n    logger.info('SupabaseEventStore.appendBatch', context);\n\n    try {\n      // Group events by aggregate to maintain version ordering\n      const eventsByAggregate = new Map<string, T[]>();\n      for (const event of events) {\n        const existing = eventsByAggregate.get(event.aggregateId) || [];\n        existing.push(event);\n        eventsByAggregate.set(event.aggregateId, existing);\n      }\n\n      // Prepare batch records\n      const eventRecords: Omit<StoredEventRecord, 'id' | 'created_at'>[] = events.map(event => ({\n        event_id: event.eventId,\n        event_type: event.eventType,\n        aggregate_id: event.aggregateId,\n        aggregate_type: event.aggregateType,\n        event_data: event.eventData,\n        version: event.version,\n        occurred_at: event.occurredAt.toISOString(),\n        user_id: event.userId,\n        correlation_id: event.correlationId,\n        causation_id: event.causationId,\n        checksum: this.calculateChecksum(event),\n      }));\n\n      // Execute batch insert with stream updates\n      const { error: batchError } = await this.supabase.rpc('append_events_batch', {\n        p_events: eventRecords,\n        p_aggregates_metadata: Array.from(eventsByAggregate.entries()).map(([aggregateId, aggEvents]) => ({\n          aggregate_id: aggregateId,\n          aggregate_type: aggEvents[0].aggregateType,\n          event_count: aggEvents.length,\n          first_version: Math.min(...aggEvents.map(e => e.version)),\n          last_version: Math.max(...aggEvents.map(e => e.version)),\n        })),\n      });\n\n      if (batchError) {\n        const error = new Error(`Failed to append event batch: ${batchError.message}`);\n        logger.error('SupabaseEventStore.appendBatch', error, context);\n        return Result.error(error);\n      }\n\n      logger.info('SupabaseEventStore.appendBatch', context);\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Unknown batch append error');\n      logger.error('SupabaseEventStore.appendBatch', err, context);\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Get events for a specific aggregate\n   */\n  async getEvents(\n    aggregateId: string, \n    fromVersion?: number\n  ): Promise<Result<DomainEvent[], Error>> {\n    const context = createSimpleContext('event_store_get_events', 'events', {\n      aggregateId,\n      fromVersion,\n    });\n\n    logger.info('SupabaseEventStore.getEvents', context);\n\n    try {\n      let query = this.supabase\n        .from(this.eventsTable)\n        .select('*')\n        .eq('aggregate_id', aggregateId)\n        .order('version', { ascending: true });\n\n      if (fromVersion !== undefined) {\n        query = query.gte('version', fromVersion);\n      }\n\n      const { data, error } = await query;\n\n      if (error) {\n        const err = new Error(`Failed to get events: ${error.message}`);\n        logger.error('SupabaseEventStore.getEvents', err, context);\n        return Result.error(err);\n      }\n\n      const events = (data as StoredEventRecord[]).map(record => this.recordToEvent(record));\n\n      logger.info('SupabaseEventStore.getEvents', {\n        ...context,\n        eventCount: events.length,\n      });\n\n      return Result.ok(events);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Unknown get events error');\n      logger.error('SupabaseEventStore.getEvents', err, context);\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Get events by type\n   */\n  async getEventsByType(\n    eventType: string, \n    fromDate?: Date\n  ): Promise<Result<DomainEvent[], Error>> {\n    const context = createSimpleContext('event_store_get_events_by_type', 'events', {\n      eventType,\n      fromDate: fromDate?.toISOString(),\n    });\n\n    logger.info('SupabaseEventStore.getEventsByType', context);\n\n    try {\n      let query = this.supabase\n        .from(this.eventsTable)\n        .select('*')\n        .eq('event_type', eventType)\n        .order('occurred_at', { ascending: true });\n\n      if (fromDate) {\n        query = query.gte('occurred_at', fromDate.toISOString());\n      }\n\n      const { data, error } = await query;\n\n      if (error) {\n        const err = new Error(`Failed to get events by type: ${error.message}`);\n        logger.error('SupabaseEventStore.getEventsByType', err, context);\n        return Result.error(err);\n      }\n\n      const events = (data as StoredEventRecord[]).map(record => this.recordToEvent(record));\n\n      logger.info('SupabaseEventStore.getEventsByType', {\n        ...context,\n        eventCount: events.length,\n      });\n\n      return Result.ok(events);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Unknown get events by type error');\n      logger.error('SupabaseEventStore.getEventsByType', err, context);\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Get all events with optional pagination\n   */\n  async getAllEvents(\n    fromDate?: Date, \n    limit?: number\n  ): Promise<Result<DomainEvent[], Error>> {\n    const context = createSimpleContext('event_store_get_all_events', 'events', {\n      fromDate: fromDate?.toISOString(),\n      limit,\n    });\n\n    logger.info('SupabaseEventStore.getAllEvents', context);\n\n    try {\n      let query = this.supabase\n        .from(this.eventsTable)\n        .select('*')\n        .order('occurred_at', { ascending: true });\n\n      if (fromDate) {\n        query = query.gte('occurred_at', fromDate.toISOString());\n      }\n\n      if (limit) {\n        query = query.limit(limit);\n      }\n\n      const { data, error } = await query;\n\n      if (error) {\n        const err = new Error(`Failed to get all events: ${error.message}`);\n        logger.error('SupabaseEventStore.getAllEvents', err, context);\n        return Result.error(err);\n      }\n\n      const events = (data as StoredEventRecord[]).map(record => this.recordToEvent(record));\n\n      logger.info('SupabaseEventStore.getAllEvents', {\n        ...context,\n        eventCount: events.length,\n      });\n\n      return Result.ok(events);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Unknown get all events error');\n      logger.error('SupabaseEventStore.getAllEvents', err, context);\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Get event stream metadata\n   */\n  async getStreamMetadata(aggregateId: string): Promise<Result<EventStreamMetadata | null, Error>> {\n    try {\n      const { data, error } = await this.supabase\n        .from(this.streamsTable)\n        .select('*')\n        .eq('aggregate_id', aggregateId)\n        .single();\n\n      if (error && error.code !== 'PGRST116') { // Not found error\n        return Result.error(new Error(`Failed to get stream metadata: ${error.message}`));\n      }\n\n      return Result.ok(data as EventStreamMetadata | null);\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Unknown stream metadata error');\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Create or update a snapshot for an aggregate\n   */\n  async createSnapshot(\n    aggregateId: string,\n    aggregateType: string,\n    version: number,\n    snapshotData: any\n  ): Promise<Result<void, Error>> {\n    try {\n      const { error } = await this.supabase\n        .from(this.streamsTable)\n        .upsert({\n          aggregate_id: aggregateId,\n          aggregate_type: aggregateType,\n          snapshot_version: version,\n          snapshot_data: snapshotData,\n          updated_at: new Date().toISOString(),\n        });\n\n      if (error) {\n        return Result.error(new Error(`Failed to create snapshot: ${error.message}`));\n      }\n\n      return Result.ok(undefined);\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Unknown snapshot error');\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Convert stored record to domain event\n   */\n  private recordToEvent(record: StoredEventRecord): DomainEvent {\n    return {\n      eventId: record.event_id,\n      eventType: record.event_type,\n      aggregateId: record.aggregate_id,\n      aggregateType: record.aggregate_type,\n      eventData: record.event_data,\n      version: record.version,\n      occurredAt: new Date(record.occurred_at),\n      userId: record.user_id,\n      correlationId: record.correlation_id,\n      causationId: record.causation_id,\n    };\n  }\n\n  /**\n   * Calculate event checksum for integrity verification\n   */\n  private calculateChecksum(event: DomainEvent): string {\n    const data = {\n      eventId: event.eventId,\n      eventType: event.eventType,\n      aggregateId: event.aggregateId,\n      aggregateType: event.aggregateType,\n      eventData: event.eventData,\n      version: event.version,\n    };\n\n    // Simple checksum (in production, use a proper hash function)\n    return Buffer.from(JSON.stringify(data)).toString('base64').slice(0, 16);\n  }\n\n  /**\n   * Verify event integrity\n   */\n  async verifyEventIntegrity(eventId: string): Promise<Result<boolean, Error>> {\n    try {\n      const { data, error } = await this.supabase\n        .from(this.eventsTable)\n        .select('*')\n        .eq('event_id', eventId)\n        .single();\n\n      if (error) {\n        return Result.error(new Error(`Failed to verify event: ${error.message}`));\n      }\n\n      const record = data as StoredEventRecord;\n      const event = this.recordToEvent(record);\n      const expectedChecksum = this.calculateChecksum(event);\n\n      return Result.ok(record.checksum === expectedChecksum);\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Unknown verification error');\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Get event store statistics\n   */\n  async getStatistics(): Promise<Result<{\n    totalEvents: number;\n    totalStreams: number;\n    eventsByType: Record<string, number>;\n    oldestEvent: Date | null;\n    newestEvent: Date | null;\n  }, Error>> {\n    try {\n      // Get total counts\n      const [eventsResult, streamsResult, typeStatsResult, dateRangeResult] = await Promise.all([\n        this.supabase.from(this.eventsTable).select('*', { count: 'exact', head: true }),\n        this.supabase.from(this.streamsTable).select('*', { count: 'exact', head: true }),\n        this.supabase.from(this.eventsTable).select('event_type'),\n        this.supabase\n          .from(this.eventsTable)\n          .select('occurred_at')\n          .order('occurred_at', { ascending: true })\n          .limit(1)\n          .union(\n            this.supabase\n              .from(this.eventsTable)\n              .select('occurred_at')\n              .order('occurred_at', { ascending: false })\n              .limit(1)\n          ),\n      ]);\n\n      if (eventsResult.error || streamsResult.error || typeStatsResult.error || dateRangeResult.error) {\n        return Result.error(new Error('Failed to get event store statistics'));\n      }\n\n      // Count events by type\n      const eventsByType: Record<string, number> = {};\n      for (const record of typeStatsResult.data || []) {\n        const eventType = (record as { event_type: string }).event_type;\n        eventsByType[eventType] = (eventsByType[eventType] || 0) + 1;\n      }\n\n      // Get date range\n      const dates = dateRangeResult.data?.map(r => new Date((r as { occurred_at: string }).occurred_at)) || [];\n      const oldestEvent = dates.length > 0 ? dates[0] : null;\n      const newestEvent = dates.length > 1 ? dates[1] : (dates.length > 0 ? dates[0] : null);\n\n      return Result.ok({\n        totalEvents: eventsResult.count || 0,\n        totalStreams: streamsResult.count || 0,\n        eventsByType,\n        oldestEvent,\n        newestEvent,\n      });\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Unknown statistics error');\n      return Result.error(err);\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\repositories\\__tests__\\cart.repository.integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[879,882],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[879,882],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Cart Repository Integration Tests\n * \n * Tests the repository layer with mock Supabase client\n * to ensure proper data persistence and retrieval.\n */\n\nimport { beforeEach, describe, expect, it, jest, afterEach } from '@jest/globals';\nimport { SupabaseCartRepository } from '../cart.repository';\nimport { Cart } from '@/lib/domain/entities/cart.entity';\nimport { Money } from '@/lib/domain/value-objects/money';\nimport { Quantity } from '@/lib/domain/value-objects/quantity';\nimport { ProductReference } from '@/lib/domain/value-objects/product-reference';\nimport { DatabaseError } from '@/lib/core/errors';\n\n// Mock logger\njest.mock('@/lib/core/logger', () => ({\n  logger: {\n    info: jest.fn(),\n    warn: jest.fn(),\n    error: jest.fn(),\n  }\n}));\n\ndescribe('SupabaseCartRepository Integration Tests', () => {\n  let repository: SupabaseCartRepository;\n  let mockSupabase: any;\n\n  beforeEach(() => {\n    // Create mock chain objects with proper Jest mocks\n    const mockChain = {\n      select: jest.fn().mockReturnThis(),\n      insert: jest.fn().mockReturnThis(),\n      update: jest.fn().mockReturnThis(),\n      upsert: jest.fn().mockReturnThis(),\n      delete: jest.fn().mockReturnThis(),\n      eq: jest.fn().mockReturnThis(),\n      single: jest.fn().mockResolvedValue({ data: null, error: null }),\n      maybeSingle: jest.fn().mockResolvedValue({ data: null, error: null }),\n    };\n\n    // Create comprehensive Supabase mock compatible with jest.setup.ts\n    mockSupabase = {\n      from: jest.fn(() => mockChain),\n      rpc: jest.fn().mockResolvedValue({ data: null, error: null }),\n    };\n\n    repository = new SupabaseCartRepository(mockSupabase);\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('findByUserId', () => {\n    const userId = 'user-123';\n\n    it('should successfully find cart by user ID', async () => {\n      // Arrange\n      const mockCartData = {\n        id: 'cart-456',\n        user_id: userId,\n        created_at: '2024-01-01T00:00:00Z',\n        updated_at: '2024-01-01T01:00:00Z'\n      };\n\n      // Configure the mock chain for this specific test\n      const mockChain = mockSupabase.from();\n      mockChain.single.mockResolvedValueOnce({\n        data: mockCartData,\n        error: null\n      });\n\n      // Act\n      const result = await repository.findByUserId(userId);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const cart = result.getValue();\n      expect(cart).toBeInstanceOf(Cart);\n      expect(cart.id).toBe(mockCartData.id);\n      expect(cart.userId).toBe(userId);\n\n      // Verify Supabase calls\n      expect(mockSupabase.from).toHaveBeenCalledWith('carts');\n    });\n\n    it('should return null when cart not found', async () => {\n      // Arrange\n      const mockChain = mockSupabase.from();\n      mockChain.single.mockResolvedValueOnce({\n        data: null,\n        error: { code: 'PGRST116' } // Supabase \"no rows returned\" error\n      });\n\n      // Act\n      const result = await repository.findByUserId(userId);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      expect(result.getValue()).toBeNull();\n    });\n\n    it('should handle database errors', async () => {\n      // Arrange\n      mockSupabase.single.mockResolvedValue({\n        data: null,\n        error: { code: 'CONNECTION_ERROR', message: 'Connection failed' }\n      });\n\n      // Act\n      const result = await repository.findByUserId(userId);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(DatabaseError);\n      expect(result.getError().message).toContain('Erreur lors de la récupération du panier');\n    });\n\n    it('should handle unexpected errors', async () => {\n      // Arrange\n      mockSupabase.single.mockRejectedValue(new Error('Unexpected error'));\n\n      // Act\n      const result = await repository.findByUserId(userId);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(DatabaseError);\n    });\n  });\n\n  describe('findByUserIdWithItems', () => {\n    const userId = 'user-123';\n\n    it('should successfully find cart with items', async () => {\n      // Arrange\n      const mockCartWithItems = {\n        id: 'cart-456',\n        user_id: userId,\n        created_at: '2024-01-01T00:00:00Z',\n        updated_at: '2024-01-01T01:00:00Z',\n        cart_items: [\n          {\n            id: 'item-1',\n            product_id: 'product-1',\n            quantity: 2,\n            added_at: '2024-01-01T00:30:00Z',\n            products: {\n              id: 'product-1',\n              name: 'Test Product',\n              price: 10.99,\n              slug: 'test-product',\n              image_url: 'https://example.com/image.jpg'\n            }\n          }\n        ]\n      };\n\n      mockSupabase.single.mockResolvedValue({\n        data: mockCartWithItems,\n        error: null\n      });\n\n      // Act\n      const result = await repository.findByUserIdWithItems(userId);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const cart = result.getValue();\n      expect(cart).toBeInstanceOf(Cart);\n      expect(cart.getItems()).toHaveLength(1);\n\n      const item = cart.getItems()[0];\n      expect(item.productReference.name).toBe('Test Product');\n      expect(item.quantity.value).toBe(2);\n\n      // Verify complex Supabase query\n      expect(mockSupabase.select).toHaveBeenCalledWith(`\n        id,\n        user_id,\n        created_at,\n        updated_at,\n        cart_items (\n          id,\n          product_id,\n          quantity,\n          added_at,\n          products (\n            id,\n            name,\n            price,\n            slug,\n            image_url\n          )\n        )\n      `);\n    });\n\n    it('should handle cart with no items', async () => {\n      // Arrange\n      const mockCartWithoutItems = {\n        id: 'cart-456',\n        user_id: userId,\n        created_at: '2024-01-01T00:00:00Z',\n        updated_at: '2024-01-01T01:00:00Z',\n        cart_items: []\n      };\n\n      mockSupabase.single.mockResolvedValue({\n        data: mockCartWithoutItems,\n        error: null\n      });\n\n      // Act\n      const result = await repository.findByUserIdWithItems(userId);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const cart = result.getValue();\n      expect(cart).toBeInstanceOf(Cart);\n      expect(cart.getItems()).toHaveLength(0);\n    });\n  });\n\n  describe('save', () => {\n    it('should successfully save new cart', async () => {\n      // Arrange\n      const cart = new Cart('user-123');\n      cart.addItem(\n        'item-1',\n        new ProductReference('product-1', 'Test Product', new Money(10.99), 'test-product'),\n        new Quantity(2)\n      );\n\n      // Mock cart insert\n      mockSupabase.single.mockResolvedValueOnce({\n        data: {\n          id: 'new-cart-id',\n          user_id: 'user-123',\n          created_at: '2024-01-01T00:00:00Z',\n          updated_at: '2024-01-01T00:00:00Z'\n        },\n        error: null\n      });\n\n      // Mock cart items insert\n      mockSupabase.select.mockResolvedValueOnce({\n        data: [\n          {\n            id: 'new-item-id',\n            cart_id: 'new-cart-id',\n            product_id: 'product-1',\n            quantity: 2,\n            added_at: '2024-01-01T00:00:00Z'\n          }\n        ],\n        error: null\n      });\n\n      // Act\n      const result = await repository.save(cart);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const savedCart = result.getValue();\n      expect(savedCart.id).toBe('new-cart-id');\n\n      // Verify insert operations\n      expect(mockSupabase.from).toHaveBeenCalledWith('carts');\n      expect(mockSupabase.insert).toHaveBeenCalled();\n    });\n\n    it('should successfully update existing cart', async () => {\n      // Arrange\n      const cart = new Cart('user-123');\n      cart.id = 'existing-cart-id'; // Simulate existing cart\n      cart.addItem(\n        'item-1',\n        new ProductReference('product-1', 'Test Product', new Money(10.99), 'test-product'),\n        new Quantity(3)\n      );\n\n      // Mock cart update\n      mockSupabase.single.mockResolvedValueOnce({\n        data: {\n          id: 'existing-cart-id',\n          user_id: 'user-123',\n          created_at: '2024-01-01T00:00:00Z',\n          updated_at: '2024-01-01T01:00:00Z'\n        },\n        error: null\n      });\n\n      // Mock delete existing items\n      mockSupabase.eq.mockReturnThis();\n\n      // Mock insert new items\n      mockSupabase.select.mockResolvedValueOnce({\n        data: [\n          {\n            id: 'updated-item-id',\n            cart_id: 'existing-cart-id',\n            product_id: 'product-1',\n            quantity: 3,\n            added_at: '2024-01-01T01:00:00Z'\n          }\n        ],\n        error: null\n      });\n\n      // Act\n      const result = await repository.save(cart);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const savedCart = result.getValue();\n      expect(savedCart.id).toBe('existing-cart-id');\n\n      // Verify update operation\n      expect(mockSupabase.update).toHaveBeenCalled();\n    });\n\n    it('should handle save errors', async () => {\n      // Arrange\n      const cart = new Cart('user-123');\n      \n      mockSupabase.single.mockResolvedValue({\n        data: null,\n        error: { code: 'CONSTRAINT_VIOLATION', message: 'Foreign key violation' }\n      });\n\n      // Act\n      const result = await repository.save(cart);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(DatabaseError);\n      expect(result.getError().message).toContain('Erreur lors de la sauvegarde du panier');\n    });\n  });\n\n  describe('delete', () => {\n    const userId = 'user-123';\n\n    it('should successfully delete cart', async () => {\n      // Arrange\n      mockSupabase.eq.mockReturnThis();\n\n      // Act\n      const result = await repository.delete(userId);\n\n      // Assert\n      expect(result.isError()).toBe(false);\n\n      // Verify delete operation\n      expect(mockSupabase.from).toHaveBeenCalledWith('carts');\n      expect(mockSupabase.delete).toHaveBeenCalled();\n      expect(mockSupabase.eq).toHaveBeenCalledWith('user_id', userId);\n    });\n\n    it('should handle delete errors', async () => {\n      // Arrange\n      mockSupabase.eq.mockRejectedValue(new Error('Delete failed'));\n\n      // Act\n      const result = await repository.delete(userId);\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(DatabaseError);\n      expect(result.getError().message).toContain('Erreur lors de la suppression du panier');\n    });\n  });\n\n  describe('Edge cases and error scenarios', () => {\n    it('should handle malformed cart data from database', async () => {\n      // Arrange\n      const malformedData = {\n        id: 'cart-456',\n        user_id: null, // Invalid: missing user_id\n        created_at: 'invalid-date',\n        updated_at: null\n      };\n\n      mockSupabase.single.mockResolvedValue({\n        data: malformedData,\n        error: null\n      });\n\n      // Act\n      const result = await repository.findByUserId('user-123');\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(DatabaseError);\n    });\n\n    it('should handle malformed cart items data', async () => {\n      // Arrange\n      const malformedCartWithItems = {\n        id: 'cart-456',\n        user_id: 'user-123',\n        created_at: '2024-01-01T00:00:00Z',\n        updated_at: '2024-01-01T01:00:00Z',\n        cart_items: [\n          {\n            id: 'item-1',\n            product_id: null, // Invalid: missing product_id\n            quantity: 'invalid', // Invalid: not a number\n            added_at: '2024-01-01T00:30:00Z',\n            products: null // Invalid: missing product data\n          }\n        ]\n      };\n\n      mockSupabase.single.mockResolvedValue({\n        data: malformedCartWithItems,\n        error: null\n      });\n\n      // Act\n      const result = await repository.findByUserIdWithItems('user-123');\n\n      // Assert\n      expect(result.isError()).toBe(true);\n      expect(result.getError()).toBeInstanceOf(DatabaseError);\n    });\n\n    it('should handle very large carts efficiently', async () => {\n      // Arrange\n      const largeCartData = {\n        id: 'cart-456',\n        user_id: 'user-123',\n        created_at: '2024-01-01T00:00:00Z',\n        updated_at: '2024-01-01T01:00:00Z',\n        cart_items: Array.from({ length: 100 }, (_, i) => ({\n          id: `item-${i}`,\n          product_id: `product-${i}`,\n          quantity: i + 1,\n          added_at: '2024-01-01T00:30:00Z',\n          products: {\n            id: `product-${i}`,\n            name: `Product ${i}`,\n            price: 10.99 + i,\n            slug: `product-${i}`,\n            image_url: `https://example.com/image-${i}.jpg`\n          }\n        }))\n      };\n\n      mockSupabase.single.mockResolvedValue({\n        data: largeCartData,\n        error: null\n      });\n\n      // Act\n      const startTime = Date.now();\n      const result = await repository.findByUserIdWithItems('user-123');\n      const endTime = Date.now();\n\n      // Assert\n      expect(result.isError()).toBe(false);\n      const cart = result.getValue();\n      expect(cart.getItems()).toHaveLength(100);\n      \n      // Performance assertion (should complete within reasonable time)\n      expect(endTime - startTime).toBeLessThan(1000); // 1 second\n    });\n\n    it('should handle concurrent save operations', async () => {\n      // Arrange\n      const cart1 = new Cart('user-123');\n      const cart2 = new Cart('user-456');\n      \n      cart1.addItem(\n        'item-1',\n        new ProductReference('product-1', 'Product 1', new Money(10.99), 'product-1'),\n        new Quantity(1)\n      );\n      \n      cart2.addItem(\n        'item-2',\n        new ProductReference('product-2', 'Product 2', new Money(15.99), 'product-2'),\n        new Quantity(2)\n      );\n\n      // Mock successful saves\n      mockSupabase.single\n        .mockResolvedValueOnce({\n          data: { id: 'cart-1', user_id: 'user-123', created_at: '2024-01-01T00:00:00Z', updated_at: '2024-01-01T00:00:00Z' },\n          error: null\n        })\n        .mockResolvedValueOnce({\n          data: { id: 'cart-2', user_id: 'user-456', created_at: '2024-01-01T00:00:00Z', updated_at: '2024-01-01T00:00:00Z' },\n          error: null\n        });\n\n      mockSupabase.select\n        .mockResolvedValueOnce({ data: [], error: null })\n        .mockResolvedValueOnce({ data: [], error: null });\n\n      // Act\n      const [result1, result2] = await Promise.all([\n        repository.save(cart1),\n        repository.save(cart2)\n      ]);\n\n      // Assert\n      expect(result1.isError()).toBe(false);\n      expect(result2.isError()).toBe(false);\n      expect(result1.getValue().userId).toBe('user-123');\n      expect(result2.getValue().userId).toBe('user-456');\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\repositories\\address.supabase.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ADDRESS_LIMITS' is defined but never used. Allowed unused vars must match /^_/u.","line":21,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'address' is defined but never used. Allowed unused args must match /^_/u.","line":738,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":738,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Address Repository - Implémentation Supabase\n * \n * Implémente IAddressRepository en utilisant Supabase comme source de données.\n * Hérite de BaseSupabaseRepository car les adresses sont des tables normales.\n */\n\nimport { createSupabaseServerClient } from '@/lib/supabase/server';\nimport { Result } from '@/lib/core/result';\nimport { DatabaseError, ValidationError, NotFoundError, BusinessError } from '@/lib/core/errors';\nimport { LogUtils } from '@/lib/core/logger';\nimport { BaseSupabaseRepository } from './base-supabase.repository';\nimport type { \n  IAddressRepository,\n  Address,\n  AddressType,\n  CreateAddressData,\n  UpdateAddressData,\n  AddressFilters,\n  UserAddressSummary,\n  ADDRESS_LIMITS\n} from '@/lib/domain/interfaces/address.repository.interface';\n\nexport class AddressSupabaseRepository extends BaseSupabaseRepository<Address, CreateAddressData, UpdateAddressData> implements IAddressRepository {\n  constructor() {\n    super(createSupabaseServerClient(), 'addresses');\n  }\n\n  // === Opérations de base par utilisateur ===\n\n  async findByUserId(userId: string, filters?: AddressFilters): Promise<Result<Address[], Error>> {\n    const context = LogUtils.createOperationContext('findByUserId', 'address-repository');\n    LogUtils.logOperationStart('findByUserId', { ...context, userId, filters });\n\n    try {\n      let query = this.supabase\n        .from(this.tableName)\n        .select('*')\n        .eq('user_id', userId)\n        .order('created_at', { ascending: false });\n\n      // Appliquer les filtres\n      if (filters?.address_type) {\n        query = query.eq('address_type', filters.address_type);\n      }\n      if (filters?.country_code) {\n        query = query.eq('country_code', filters.country_code);\n      }\n      if (filters?.is_default !== undefined) {\n        query = query.eq('is_default', filters.is_default);\n      }\n\n      const { data, error } = await query;\n\n      if (error) {\n        LogUtils.logOperationError('findByUserId', error, context);\n        return Result.failure(new DatabaseError(`Error finding addresses: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('findByUserId', { \n        ...context, \n        addressCount: data?.length || 0 \n      });\n      return Result.success(data || []);\n    } catch (error) {\n      LogUtils.logOperationError('findByUserId', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async findByUserIdAndType(userId: string, type: AddressType): Promise<Result<Address[], Error>> {\n    const context = LogUtils.createOperationContext('findByUserIdAndType', 'address-repository');\n    LogUtils.logOperationStart('findByUserIdAndType', { ...context, userId, type });\n\n    try {\n      const { data, error } = await this.supabase\n        .from(this.tableName)\n        .select('*')\n        .eq('user_id', userId)\n        .eq('address_type', type)\n        .order('is_default', { ascending: false }) // Adresses par défaut en premier\n        .order('created_at', { ascending: false });\n\n      if (error) {\n        LogUtils.logOperationError('findByUserIdAndType', error, context);\n        return Result.failure(new DatabaseError(`Error finding addresses by type: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('findByUserIdAndType', { \n        ...context, \n        addressCount: data?.length || 0 \n      });\n      return Result.success(data || []);\n    } catch (error) {\n      LogUtils.logOperationError('findByUserIdAndType', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async findDefaultByType(userId: string, type: AddressType): Promise<Result<Address | null, Error>> {\n    const context = LogUtils.createOperationContext('findDefaultByType', 'address-repository');\n    LogUtils.logOperationStart('findDefaultByType', { ...context, userId, type });\n\n    try {\n      const { data, error } = await this.supabase\n        .from(this.tableName)\n        .select('*')\n        .eq('user_id', userId)\n        .eq('address_type', type)\n        .eq('is_default', true)\n        .single();\n\n      if (error && error.code !== 'PGRST116') {\n        LogUtils.logOperationError('findDefaultByType', error, context);\n        return Result.failure(new DatabaseError(`Error finding default address: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('findDefaultByType', { \n        ...context, \n        found: !!data \n      });\n      return Result.success(data);\n    } catch (error) {\n      LogUtils.logOperationError('findDefaultByType', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async getUserAddressSummary(userId: string): Promise<Result<UserAddressSummary, Error>> {\n    const context = LogUtils.createOperationContext('getUserAddressSummary', 'address-repository');\n    LogUtils.logOperationStart('getUserAddressSummary', { ...context, userId });\n\n    try {\n      const { data, error } = await this.supabase\n        .from(this.tableName)\n        .select('*')\n        .eq('user_id', userId)\n        .order('address_type')\n        .order('is_default', { ascending: false });\n\n      if (error) {\n        LogUtils.logOperationError('getUserAddressSummary', error, context);\n        return Result.failure(new DatabaseError(`Error getting address summary: ${error.message}`));\n      }\n\n      const addresses = data || [];\n      const shippingAddresses = addresses.filter(a => a.address_type === 'shipping');\n      const billingAddresses = addresses.filter(a => a.address_type === 'billing');\n\n      const summary: UserAddressSummary = {\n        user_id: userId,\n        total_addresses: addresses.length,\n        has_default_shipping: shippingAddresses.some(a => a.is_default),\n        has_default_billing: billingAddresses.some(a => a.is_default),\n        shipping_addresses: shippingAddresses,\n        billing_addresses: billingAddresses,\n      };\n\n      LogUtils.logOperationSuccess('getUserAddressSummary', { \n        ...context, \n        totalAddresses: summary.total_addresses,\n        shippingCount: shippingAddresses.length,\n        billingCount: billingAddresses.length\n      });\n      return Result.success(summary);\n    } catch (error) {\n      LogUtils.logOperationError('getUserAddressSummary', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations CRUD ===\n\n  async createAddress(userId: string, addressData: CreateAddressData): Promise<Result<Address, Error>> {\n    const context = LogUtils.createOperationContext('createAddress', 'address-repository');\n    LogUtils.logOperationStart('createAddress', { ...context, userId, addressType: addressData.address_type });\n\n    try {\n      // Validation des limites\n      const limitCheck = await this.hasReachedAddressLimit(userId, addressData.address_type);\n      if (limitCheck.isSuccess() && limitCheck.getValue()) {\n        return Result.failure(new BusinessError('Address limit reached for this type'));\n      }\n\n      // Si c'est la première adresse de ce type, la marquer comme par défaut\n      const existingAddresses = await this.findByUserIdAndType(userId, addressData.address_type);\n      const isFirstOfType = existingAddresses.isSuccess() && existingAddresses.getValue()!.length === 0;\n\n      const addressToCreate = {\n        ...addressData,\n        user_id: userId,\n        is_default: addressData.is_default ?? isFirstOfType,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      };\n\n      // Si cette adresse doit être par défaut, retirer le statut des autres\n      if (addressToCreate.is_default) {\n        await this.unsetOtherDefaultsOfType(userId, addressData.address_type);\n      }\n\n      const { data, error } = await this.supabase\n        .from(this.tableName)\n        .insert(addressToCreate)\n        .select()\n        .single();\n\n      if (error) {\n        LogUtils.logOperationError('createAddress', error, context);\n        return Result.failure(new DatabaseError(`Error creating address: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('createAddress', { \n        ...context, \n        addressId: data.id,\n        isDefault: data.is_default\n      });\n      return Result.success(data);\n    } catch (error) {\n      LogUtils.logOperationError('createAddress', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async updateAddress(addressId: string, userId: string, addressData: UpdateAddressData): Promise<Result<Address, Error>> {\n    const context = LogUtils.createOperationContext('updateAddress', 'address-repository');\n    LogUtils.logOperationStart('updateAddress', { ...context, addressId, userId });\n\n    try {\n      // Si on met à jour le statut par défaut\n      if (addressData.is_default === true) {\n        // D'abord récupérer l'adresse pour connaître son type\n        const existingResult = await this.findById(addressId);\n        if (!existingResult.isSuccess() || !existingResult.getValue()) {\n          return Result.failure(new NotFoundError(`Address ${addressId} not found`));\n        }\n\n        const existingAddress = existingResult.getValue()!;\n        if (existingAddress.user_id !== userId) {\n          return Result.failure(new BusinessError('Address does not belong to this user'));\n        }\n\n        // Retirer le statut par défaut des autres adresses du même type\n        await this.unsetOtherDefaultsOfType(userId, existingAddress.address_type, addressId);\n      }\n\n      const { data, error } = await this.supabase\n        .from(this.tableName)\n        .update({\n          ...addressData,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', addressId)\n        .eq('user_id', userId) // Security: vérifier que l'adresse appartient à l'utilisateur\n        .select()\n        .single();\n\n      if (error) {\n        LogUtils.logOperationError('updateAddress', error, context);\n        if (error.code === 'PGRST116') {\n          return Result.failure(new NotFoundError(`Address ${addressId} not found for user ${userId}`));\n        }\n        return Result.failure(new DatabaseError(`Error updating address: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('updateAddress', { \n        ...context, \n        addressId: data.id \n      });\n      return Result.success(data);\n    } catch (error) {\n      LogUtils.logOperationError('updateAddress', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async deleteAddress(addressId: string, userId: string): Promise<Result<void, Error>> {\n    const context = LogUtils.createOperationContext('deleteAddress', 'address-repository');\n    LogUtils.logOperationStart('deleteAddress', { ...context, addressId, userId });\n\n    try {\n      const { error } = await this.supabase\n        .from(this.tableName)\n        .delete()\n        .eq('id', addressId)\n        .eq('user_id', userId); // Security: vérifier que l'adresse appartient à l'utilisateur\n\n      if (error) {\n        LogUtils.logOperationError('deleteAddress', error, context);\n        return Result.failure(new DatabaseError(`Error deleting address: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('deleteAddress', context);\n      return Result.success(undefined);\n    } catch (error) {\n      LogUtils.logOperationError('deleteAddress', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations de gestion des adresses par défaut ===\n\n  async setAsDefault(addressId: string, userId: string, type: AddressType): Promise<Result<Address, Error>> {\n    const context = LogUtils.createOperationContext('setAsDefault', 'address-repository');\n    LogUtils.logOperationStart('setAsDefault', { ...context, addressId, userId, type });\n\n    try {\n      // D'abord retirer le statut par défaut des autres adresses du même type\n      await this.unsetOtherDefaultsOfType(userId, type, addressId);\n\n      // Puis mettre cette adresse comme par défaut\n      const { data, error } = await this.supabase\n        .from(this.tableName)\n        .update({\n          is_default: true,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', addressId)\n        .eq('user_id', userId)\n        .eq('address_type', type)\n        .select()\n        .single();\n\n      if (error) {\n        LogUtils.logOperationError('setAsDefault', error, context);\n        if (error.code === 'PGRST116') {\n          return Result.failure(new NotFoundError(`Address ${addressId} not found for user ${userId}`));\n        }\n        return Result.failure(new DatabaseError(`Error setting address as default: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('setAsDefault', { \n        ...context, \n        addressId: data.id \n      });\n      return Result.success(data);\n    } catch (error) {\n      LogUtils.logOperationError('setAsDefault', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async unsetAsDefault(addressId: string, userId: string): Promise<Result<Address, Error>> {\n    const context = LogUtils.createOperationContext('unsetAsDefault', 'address-repository');\n    LogUtils.logOperationStart('unsetAsDefault', { ...context, addressId, userId });\n\n    try {\n      const { data, error } = await this.supabase\n        .from(this.tableName)\n        .update({\n          is_default: false,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', addressId)\n        .eq('user_id', userId)\n        .select()\n        .single();\n\n      if (error) {\n        LogUtils.logOperationError('unsetAsDefault', error, context);\n        if (error.code === 'PGRST116') {\n          return Result.failure(new NotFoundError(`Address ${addressId} not found for user ${userId}`));\n        }\n        return Result.failure(new DatabaseError(`Error unsetting address as default: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('unsetAsDefault', { \n        ...context, \n        addressId: data.id \n      });\n      return Result.success(data);\n    } catch (error) {\n      LogUtils.logOperationError('unsetAsDefault', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations de validation ===\n\n  async validateAddressData(addressData: CreateAddressData | UpdateAddressData): Promise<Result<void, Error>> {\n    const context = LogUtils.createOperationContext('validateAddressData', 'address-repository');\n\n    try {\n      // Validation basique\n      if ('first_name' in addressData && addressData.first_name && addressData.first_name.length < 2) {\n        return Result.failure(new ValidationError('First name must be at least 2 characters'));\n      }\n\n      if ('last_name' in addressData && addressData.last_name && addressData.last_name.length < 2) {\n        return Result.failure(new ValidationError('Last name must be at least 2 characters'));\n      }\n\n      if ('postal_code' in addressData && addressData.postal_code && addressData.country_code) {\n        const postalCodeValid = await this.validatePostalCodeFormat(addressData.postal_code, addressData.country_code);\n        if (!postalCodeValid.isSuccess() || !postalCodeValid.getValue()) {\n          return Result.failure(new ValidationError('Invalid postal code format for this country'));\n        }\n      }\n\n      LogUtils.logOperationSuccess('validateAddressData', context);\n      return Result.success(undefined);\n    } catch (error) {\n      LogUtils.logOperationError('validateAddressData', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async validatePostalCodeFormat(postalCode: string, countryCode: string): Promise<Result<boolean, Error>> {\n    const context = LogUtils.createOperationContext('validatePostalCodeFormat', 'address-repository');\n\n    try {\n      // Validation basique par pays (peut être étendue)\n      const patterns: Record<string, RegExp> = {\n        'FR': /^\\d{5}$/, // France: 5 chiffres\n        'US': /^\\d{5}(-\\d{4})?$/, // USA: 5 chiffres ou 5-4\n        'CA': /^[A-Z]\\d[A-Z] \\d[A-Z]\\d$/, // Canada: A1A 1A1\n        'GB': /^[A-Z]{1,2}\\d[A-Z\\d]? \\d[A-Z]{2}$/, // UK: SW1A 1AA\n        'DE': /^\\d{5}$/, // Allemagne: 5 chiffres\n        'ES': /^\\d{5}$/, // Espagne: 5 chiffres\n      };\n\n      const pattern = patterns[countryCode.toUpperCase()];\n      if (!pattern) {\n        // Si pas de pattern défini, accepter (validation basique)\n        LogUtils.logOperationSuccess('validatePostalCodeFormat', { \n          ...context, \n          countryCode, \n          validated: false, \n          result: true \n        });\n        return Result.success(true);\n      }\n\n      const isValid = pattern.test(postalCode);\n      LogUtils.logOperationSuccess('validatePostalCodeFormat', { \n        ...context, \n        countryCode, \n        validated: true, \n        result: isValid \n      });\n      return Result.success(isValid);\n    } catch (error) {\n      LogUtils.logOperationError('validatePostalCodeFormat', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async normalizeAddress(addressData: CreateAddressData | UpdateAddressData): Promise<Result<CreateAddressData | UpdateAddressData, Error>> {\n    const context = LogUtils.createOperationContext('normalizeAddress', 'address-repository');\n\n    try {\n      const normalized = { ...addressData };\n\n      // Normalisation des noms (première lettre majuscule)\n      if (normalized.first_name) {\n        normalized.first_name = this.capitalizeFirstLetter(normalized.first_name.trim());\n      }\n      if (normalized.last_name) {\n        normalized.last_name = this.capitalizeFirstLetter(normalized.last_name.trim());\n      }\n      if (normalized.city) {\n        normalized.city = this.capitalizeFirstLetter(normalized.city.trim());\n      }\n\n      // Normalisation du code pays (majuscules)\n      if (normalized.country_code) {\n        normalized.country_code = normalized.country_code.toUpperCase();\n      }\n\n      // Normalisation du code postal (suppression des espaces pour certains pays)\n      if (normalized.postal_code && normalized.country_code) {\n        normalized.postal_code = this.normalizePostalCode(normalized.postal_code, normalized.country_code);\n      }\n\n      LogUtils.logOperationSuccess('normalizeAddress', context);\n      return Result.success(normalized);\n    } catch (error) {\n      LogUtils.logOperationError('normalizeAddress', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations de recherche ===\n\n  async searchAddressesByUser(userId: string, searchTerm: string, filters?: AddressFilters): Promise<Result<Address[], Error>> {\n    const context = LogUtils.createOperationContext('searchAddressesByUser', 'address-repository');\n    LogUtils.logOperationStart('searchAddressesByUser', { ...context, userId, searchTerm });\n\n    try {\n      let query = this.supabase\n        .from(this.tableName)\n        .select('*')\n        .eq('user_id', userId);\n\n      // Recherche full-text basique\n      const searchPattern = `%${searchTerm.toLowerCase()}%`;\n      query = query.or(`first_name.ilike.${searchPattern},last_name.ilike.${searchPattern},city.ilike.${searchPattern},address_line1.ilike.${searchPattern}`);\n\n      // Appliquer les filtres\n      if (filters?.address_type) {\n        query = query.eq('address_type', filters.address_type);\n      }\n      if (filters?.country_code) {\n        query = query.eq('country_code', filters.country_code);\n      }\n\n      query = query.order('created_at', { ascending: false });\n\n      const { data, error } = await query;\n\n      if (error) {\n        LogUtils.logOperationError('searchAddressesByUser', error, context);\n        return Result.failure(new DatabaseError(`Error searching addresses: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('searchAddressesByUser', { \n        ...context, \n        resultCount: data?.length || 0 \n      });\n      return Result.success(data || []);\n    } catch (error) {\n      LogUtils.logOperationError('searchAddressesByUser', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async findRecentlyUsedAddresses(userId: string, limit = 5): Promise<Result<Address[], Error>> {\n    const context = LogUtils.createOperationContext('findRecentlyUsedAddresses', 'address-repository');\n    LogUtils.logOperationStart('findRecentlyUsedAddresses', { ...context, userId, limit });\n\n    try {\n      const { data, error } = await this.supabase\n        .from(this.tableName)\n        .select('*')\n        .eq('user_id', userId)\n        .order('updated_at', { ascending: false })\n        .limit(limit);\n\n      if (error) {\n        LogUtils.logOperationError('findRecentlyUsedAddresses', error, context);\n        return Result.failure(new DatabaseError(`Error finding recent addresses: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('findRecentlyUsedAddresses', { \n        ...context, \n        addressCount: data?.length || 0 \n      });\n      return Result.success(data || []);\n    } catch (error) {\n      LogUtils.logOperationError('findRecentlyUsedAddresses', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations de duplication ===\n\n  async findSimilarAddresses(userId: string, addressData: CreateAddressData): Promise<Result<Address[], Error>> {\n    const context = LogUtils.createOperationContext('findSimilarAddresses', 'address-repository');\n    LogUtils.logOperationStart('findSimilarAddresses', { ...context, userId });\n\n    try {\n      const { data, error } = await this.supabase\n        .from(this.tableName)\n        .select('*')\n        .eq('user_id', userId)\n        .eq('address_line1', addressData.address_line1)\n        .eq('postal_code', addressData.postal_code)\n        .eq('city', addressData.city)\n        .eq('country_code', addressData.country_code);\n\n      if (error) {\n        LogUtils.logOperationError('findSimilarAddresses', error, context);\n        return Result.failure(new DatabaseError(`Error finding similar addresses: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('findSimilarAddresses', { \n        ...context, \n        similarCount: data?.length || 0 \n      });\n      return Result.success(data || []);\n    } catch (error) {\n      LogUtils.logOperationError('findSimilarAddresses', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async duplicateAddress(addressId: string, userId: string, newType: AddressType): Promise<Result<Address, Error>> {\n    const context = LogUtils.createOperationContext('duplicateAddress', 'address-repository');\n    LogUtils.logOperationStart('duplicateAddress', { ...context, addressId, userId, newType });\n\n    try {\n      // D'abord récupérer l'adresse originale\n      const originalResult = await this.findById(addressId);\n      if (!originalResult.isSuccess() || !originalResult.getValue()) {\n        return Result.failure(new NotFoundError(`Address ${addressId} not found`));\n      }\n\n      const original = originalResult.getValue()!;\n      if (original.user_id !== userId) {\n        return Result.failure(new BusinessError('Address does not belong to this user'));\n      }\n\n      // Créer les données pour la nouvelle adresse\n      const newAddressData: CreateAddressData = {\n        address_type: newType,\n        company_name: original.company_name,\n        first_name: original.first_name,\n        last_name: original.last_name,\n        email: original.email,\n        street_number: original.street_number,\n        address_line1: original.address_line1,\n        address_line2: original.address_line2,\n        postal_code: original.postal_code,\n        city: original.city,\n        country_code: original.country_code,\n        state_province_region: original.state_province_region,\n        phone_number: original.phone_number,\n        is_default: false, // La nouvelle adresse n'est pas par défaut\n      };\n\n      // Créer la nouvelle adresse\n      const result = await this.createAddress(userId, newAddressData);\n\n      if (result.isSuccess()) {\n        LogUtils.logOperationSuccess('duplicateAddress', { \n          ...context, \n          newAddressId: result.getValue()!.id \n        });\n      }\n\n      return result;\n    } catch (error) {\n      LogUtils.logOperationError('duplicateAddress', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations utilitaires ===\n\n  async countAddressesByUser(userId: string, type?: AddressType): Promise<Result<number, Error>> {\n    const context = LogUtils.createOperationContext('countAddressesByUser', 'address-repository');\n    LogUtils.logOperationStart('countAddressesByUser', { ...context, userId, type });\n\n    try {\n      let query = this.supabase\n        .from(this.tableName)\n        .select('id', { count: 'exact', head: true })\n        .eq('user_id', userId);\n\n      if (type) {\n        query = query.eq('address_type', type);\n      }\n\n      const { count, error } = await query;\n\n      if (error) {\n        LogUtils.logOperationError('countAddressesByUser', error, context);\n        return Result.failure(new DatabaseError(`Error counting addresses: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('countAddressesByUser', { \n        ...context, \n        count: count || 0 \n      });\n      return Result.success(count || 0);\n    } catch (error) {\n      LogUtils.logOperationError('countAddressesByUser', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async hasReachedAddressLimit(userId: string, type?: AddressType): Promise<Result<boolean, Error>> {\n    const context = LogUtils.createOperationContext('hasReachedAddressLimit', 'address-repository');\n    LogUtils.logOperationStart('hasReachedAddressLimit', { ...context, userId, type });\n\n    try {\n      const countResult = await this.countAddressesByUser(userId, type);\n      if (!countResult.isSuccess()) {\n        return countResult;\n      }\n\n      const count = countResult.getValue()!;\n      const limit = type ? 5 : 10; // ADDRESS_LIMITS constants\n\n      const hasReached = count >= limit;\n      LogUtils.logOperationSuccess('hasReachedAddressLimit', { \n        ...context, \n        count, \n        limit, \n        hasReached \n      });\n      return Result.success(hasReached);\n    } catch (error) {\n      LogUtils.logOperationError('hasReachedAddressLimit', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async formatAddressForDisplay(address: Address): Promise<Result<string, Error>> {\n    const context = LogUtils.createOperationContext('formatAddressForDisplay', 'address-repository');\n\n    try {\n      const lines: string[] = [];\n\n      // Nom complet\n      const fullName = `${address.first_name} ${address.last_name}`.trim();\n      if (fullName) lines.push(fullName);\n\n      // Société\n      if (address.company_name) lines.push(address.company_name);\n\n      // Adresse ligne 1\n      const addressLine1 = [address.street_number, address.address_line1].filter(Boolean).join(' ');\n      if (addressLine1) lines.push(addressLine1);\n\n      // Adresse ligne 2\n      if (address.address_line2) lines.push(address.address_line2);\n\n      // Ville, code postal\n      const cityLine = `${address.postal_code} ${address.city}`.trim();\n      if (cityLine) lines.push(cityLine);\n\n      // État/Province (si présent)\n      if (address.state_province_region) lines.push(address.state_province_region);\n\n      // Pays\n      lines.push(address.country_code);\n\n      const formatted = lines.join('\\n');\n      LogUtils.logOperationSuccess('formatAddressForDisplay', context);\n      return Result.success(formatted);\n    } catch (error) {\n      LogUtils.logOperationError('formatAddressForDisplay', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async validateAddressWithExternalService(address: Address): Promise<Result<{ isValid: boolean; suggestions?: Address[] }, Error>> {\n    const context = LogUtils.createOperationContext('validateAddressWithExternalService', 'address-repository');\n\n    try {\n      // Pour l'instant, implémentation simplifiée\n      // Dans une vraie implémentation, on appellerait un service externe comme Google Maps API\n      LogUtils.logOperationSuccess('validateAddressWithExternalService', { \n        ...context, \n        isValid: true, \n        external: false \n      });\n      return Result.success({ isValid: true });\n    } catch (error) {\n      LogUtils.logOperationError('validateAddressWithExternalService', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  // === Méthodes utilitaires privées ===\n\n  private async unsetOtherDefaultsOfType(userId: string, type: AddressType, excludeAddressId?: string): Promise<void> {\n    let query = this.supabase\n      .from(this.tableName)\n      .update({ is_default: false, updated_at: new Date().toISOString() })\n      .eq('user_id', userId)\n      .eq('address_type', type)\n      .eq('is_default', true);\n\n    if (excludeAddressId) {\n      query = query.neq('id', excludeAddressId);\n    }\n\n    await query;\n  }\n\n  private capitalizeFirstLetter(str: string): string {\n    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n  }\n\n  private normalizePostalCode(postalCode: string, countryCode: string): string {\n    switch (countryCode.toUpperCase()) {\n      case 'CA':\n        // Canada: Assurer le format A1A 1A1\n        return postalCode.replace(/\\s/g, '').replace(/^([A-Z]\\d[A-Z])(\\d[A-Z]\\d)$/, '$1 $2');\n      case 'GB':\n        // UK: Assurer l'espace avant les 2 derniers caractères\n        return postalCode.replace(/\\s/g, '').replace(/^(.+)([A-Z]{2})$/, '$1 $2');\n      default:\n        return postalCode.trim();\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\repositories\\article.supabase.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ArticleType' is defined but never used. Allowed unused vars must match /^_/u.","line":30,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":122,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3674,3677],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3674,3677],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":229,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7649,7652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7649,7652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":310,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":310,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10717,10720],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10717,10720],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":423,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":423,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14406,14409],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14406,14409],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":675,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":675,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22858,22861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22858,22861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":861,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":861,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30249,30252],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30249,30252],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1274,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1274,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[44103,44106],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[44103,44106],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Article Repository - Implémentation Supabase\n * \n * Implémente IArticleRepository en utilisant Supabase comme source de données.\n * Gère les articles de contenu éditorial avec support i18n, SEO et analytics.\n * Phase 3.3 selon Context7 - Repository de contenu avec cache et validation.\n */\n\nimport { createSupabaseServerClient } from '@/lib/supabase/server';\nimport { createSupabaseAdminClient } from '@/lib/supabase/server-admin';\nimport { Result } from '@/lib/core/result';\nimport { DatabaseError, ValidationError, NotFoundError } from '@/lib/core/errors';\nimport { LogUtils } from '@/lib/core/logger';\nimport type { \n  IArticleRepository,\n  Article,\n  ArticleTranslation,\n  ArticleWithTranslations,\n  ArticleWithCurrentTranslation,\n  CreateArticleData,\n  UpdateArticleData,\n  CreateArticleTranslationData,\n  UpdateArticleTranslationData,\n  ArticleFilters,\n  ArticleSearchParams,\n  PaginatedArticles,\n  ArticleSEOData,\n  ArticleAnalytics,\n  ArticleStatus,\n  ArticleType,\n  ARTICLE_CONFIG\n} from '@/lib/domain/interfaces/article.repository.interface';\nimport type { SupabaseClient } from '@supabase/supabase-js';\n\nexport class ArticleSupabaseRepository implements IArticleRepository {\n  private client: SupabaseClient;\n  private adminClient: SupabaseClient;\n  private repositoryName = 'ArticleRepository';\n\n  constructor() {\n    this.client = createSupabaseServerClient();\n    this.adminClient = createSupabaseAdminClient();\n  }\n\n  /**\n   * Helper pour gérer les erreurs\n   */\n  private handleError(error: unknown): Result<never, Error> {\n    if (error instanceof Error) {\n      return Result.failure(new DatabaseError(error.message));\n    }\n    return Result.failure(new DatabaseError('Unknown error occurred'));\n  }\n\n  /**\n   * Helper pour calculer le temps de lecture basé sur le contenu\n   */\n  private calculateReadingTime(content: string): number {\n    const words = content.trim().split(/\\s+/).length;\n    return Math.ceil(words / ARTICLE_CONFIG.DEFAULT_READING_WPM);\n  }\n\n  /**\n   * Helper pour générer un slug unique\n   */\n  private async generateSlugFromTitle(title: string, locale: string, excludeId?: string): Promise<string> {\n    const baseSlug = title\n      .toLowerCase()\n      .normalize('NFD')\n      .replace(/[\\u0300-\\u036f]/g, '')\n      .replace(/[^a-z0-9]+/g, '-')\n      .replace(/^-+|-+$/g, '');\n\n    let slug = baseSlug;\n    let counter = 1;\n    \n    while (true) {\n      const { data } = await this.adminClient\n        .from('article_translations')\n        .select('id, article_id')\n        .eq('locale', locale)\n        .eq('slug', slug)\n        .maybeSingle();\n\n      if (!data || (excludeId && data.article_id === excludeId)) {\n        break;\n      }\n\n      slug = `${baseSlug}-${counter}`;\n      counter++;\n    }\n\n    return slug;\n  }\n\n  // === Opérations de base ===\n\n  async findBySlug(slug: string, locale = 'fr'): Promise<Result<ArticleWithCurrentTranslation | null, Error>> {\n    const context = LogUtils.createOperationContext('findBySlug', this.repositoryName);\n    LogUtils.logOperationStart('findBySlug', context, { slug, locale });\n\n    try {\n      const { data, error } = await this.client\n        .from('articles')\n        .select(`\n          *,\n          translations:article_translations(*)\n        `)\n        .eq('article_translations.slug', slug)\n        .eq('article_translations.locale', locale)\n        .eq('status', 'published')\n        .single();\n\n      if (error) {\n        if (error.code === 'PGRST116') {\n          LogUtils.logOperationEnd('findBySlug', context, { found: false });\n          return Result.success(null);\n        }\n        throw error;\n      }\n\n      const translation = data.translations.find((t: any) => t.locale === locale);\n      if (!translation) {\n        LogUtils.logOperationEnd('findBySlug', context, { found: false });\n        return Result.success(null);\n      }\n\n      const articleWithTranslation: ArticleWithCurrentTranslation = {\n        ...data,\n        title: translation.title,\n        slug: translation.slug,\n        excerpt: translation.excerpt,\n        content: translation.content,\n        meta_title: translation.meta_title,\n        meta_description: translation.meta_description,\n        keywords: translation.keywords\n      };\n\n      LogUtils.logOperationEnd('findBySlug', context, { found: true });\n      return Result.success(articleWithTranslation);\n\n    } catch (error) {\n      LogUtils.logOperationError('findBySlug', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async findByIdWithTranslations(id: string): Promise<Result<ArticleWithTranslations | null, Error>> {\n    const context = LogUtils.createOperationContext('findByIdWithTranslations', this.repositoryName);\n    LogUtils.logOperationStart('findByIdWithTranslations', context, { id });\n\n    try {\n      const { data, error } = await this.client\n        .from('articles')\n        .select(`\n          *,\n          translations:article_translations(*)\n        `)\n        .eq('id', id)\n        .single();\n\n      if (error) {\n        if (error.code === 'PGRST116') {\n          LogUtils.logOperationEnd('findByIdWithTranslations', context, { found: false });\n          return Result.success(null);\n        }\n        throw error;\n      }\n\n      LogUtils.logOperationEnd('findByIdWithTranslations', context, { found: true });\n      return Result.success(data as ArticleWithTranslations);\n\n    } catch (error) {\n      LogUtils.logOperationError('findByIdWithTranslations', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async findPublishedArticles(params: ArticleSearchParams): Promise<Result<PaginatedArticles, Error>> {\n    const context = LogUtils.createOperationContext('findPublishedArticles', this.repositoryName);\n    LogUtils.logOperationStart('findPublishedArticles', context, params);\n\n    try {\n      const { \n        filters = {}, \n        locale = 'fr', \n        sort_by = 'published_at', \n        sort_order = 'desc',\n        page = 1,\n        limit = 10\n      } = params;\n\n      let query = this.client\n        .from('articles')\n        .select(`\n          *,\n          translations:article_translations!inner(*)\n        `)\n        .eq('status', 'published')\n        .eq('article_translations.locale', locale);\n\n      // Apply filters\n      if (filters.type) query = query.eq('type', filters.type);\n      if (filters.author_id) query = query.eq('author_id', filters.author_id);\n      if (filters.is_featured !== undefined) query = query.eq('is_featured', filters.is_featured);\n      if (filters.is_pinned !== undefined) query = query.eq('is_pinned', filters.is_pinned);\n      if (filters.published_from) query = query.gte('published_at', filters.published_from);\n      if (filters.published_to) query = query.lte('published_at', filters.published_to);\n      if (filters.tags?.length) query = query.overlaps('tags', filters.tags);\n      if (filters.categories?.length) query = query.overlaps('categories', filters.categories);\n\n      // Text search\n      if (filters.search) {\n        query = query.or(`article_translations.title.ilike.%${filters.search}%,article_translations.content.ilike.%${filters.search}%,article_translations.excerpt.ilike.%${filters.search}%`);\n      }\n\n      // Count total\n      const { count } = await query.select('*', { count: 'exact', head: true });\n\n      // Apply sorting and pagination\n      const offset = (page - 1) * limit;\n      query = query.order(sort_by, { ascending: sort_order === 'asc' })\n                  .range(offset, offset + limit - 1);\n\n      const { data, error } = await query;\n\n      if (error) throw error;\n\n      const articles: ArticleWithCurrentTranslation[] = data.map((article: any) => {\n        const translation = article.translations[0];\n        return {\n          ...article,\n          title: translation.title,\n          slug: translation.slug,\n          excerpt: translation.excerpt,\n          content: translation.content,\n          meta_title: translation.meta_title,\n          meta_description: translation.meta_description,\n          keywords: translation.keywords\n        };\n      });\n\n      const result: PaginatedArticles = {\n        articles,\n        total: count || 0,\n        page,\n        limit,\n        total_pages: Math.ceil((count || 0) / limit)\n      };\n\n      LogUtils.logOperationEnd('findPublishedArticles', context, { count: articles.length });\n      return Result.success(result);\n\n    } catch (error) {\n      LogUtils.logOperationError('findPublishedArticles', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async findAllArticles(params: ArticleSearchParams): Promise<Result<PaginatedArticles, Error>> {\n    const context = LogUtils.createOperationContext('findAllArticles', this.repositoryName);\n    LogUtils.logOperationStart('findAllArticles', context, params);\n\n    try {\n      const { \n        filters = {}, \n        locale = 'fr', \n        sort_by = 'created_at', \n        sort_order = 'desc',\n        page = 1,\n        limit = 10\n      } = params;\n\n      let query = this.adminClient\n        .from('articles')\n        .select(`\n          *,\n          translations:article_translations!inner(*)\n        `)\n        .eq('article_translations.locale', locale);\n\n      // Apply all filters (including non-published articles)\n      if (filters.status) query = query.eq('status', filters.status);\n      if (filters.type) query = query.eq('type', filters.type);\n      if (filters.author_id) query = query.eq('author_id', filters.author_id);\n      if (filters.is_featured !== undefined) query = query.eq('is_featured', filters.is_featured);\n      if (filters.is_pinned !== undefined) query = query.eq('is_pinned', filters.is_pinned);\n      if (filters.published_from) query = query.gte('published_at', filters.published_from);\n      if (filters.published_to) query = query.lte('published_at', filters.published_to);\n      if (filters.tags?.length) query = query.overlaps('tags', filters.tags);\n      if (filters.categories?.length) query = query.overlaps('categories', filters.categories);\n\n      // Text search\n      if (filters.search) {\n        query = query.or(`article_translations.title.ilike.%${filters.search}%,article_translations.content.ilike.%${filters.search}%,article_translations.excerpt.ilike.%${filters.search}%`);\n      }\n\n      // Count total\n      const { count } = await query.select('*', { count: 'exact', head: true });\n\n      // Apply sorting and pagination\n      const offset = (page - 1) * limit;\n      query = query.order(sort_by, { ascending: sort_order === 'asc' })\n                  .range(offset, offset + limit - 1);\n\n      const { data, error } = await query;\n\n      if (error) throw error;\n\n      const articles: ArticleWithCurrentTranslation[] = data.map((article: any) => {\n        const translation = article.translations[0];\n        return {\n          ...article,\n          title: translation.title,\n          slug: translation.slug,\n          excerpt: translation.excerpt,\n          content: translation.content,\n          meta_title: translation.meta_title,\n          meta_description: translation.meta_description,\n          keywords: translation.keywords\n        };\n      });\n\n      const result: PaginatedArticles = {\n        articles,\n        total: count || 0,\n        page,\n        limit,\n        total_pages: Math.ceil((count || 0) / limit)\n      };\n\n      LogUtils.logOperationEnd('findAllArticles', context, { count: articles.length });\n      return Result.success(result);\n\n    } catch (error) {\n      LogUtils.logOperationError('findAllArticles', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations CRUD ===\n\n  async createArticle(articleData: CreateArticleData): Promise<Result<Article, Error>> {\n    const context = LogUtils.createOperationContext('createArticle', this.repositoryName);\n    LogUtils.logOperationStart('createArticle', context, { type: articleData.type });\n\n    try {\n      const { data, error } = await this.adminClient\n        .from('articles')\n        .insert({\n          ...articleData,\n          view_count: 0,\n          like_count: 0,\n          comment_count: 0,\n          is_featured: articleData.is_featured || false,\n          is_pinned: articleData.is_pinned || false,\n          sort_order: articleData.sort_order || 0\n        })\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('createArticle', context, { id: data.id });\n      return Result.success(data as Article);\n\n    } catch (error) {\n      LogUtils.logOperationError('createArticle', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async updateArticle(articleId: string, articleData: UpdateArticleData): Promise<Result<Article, Error>> {\n    const context = LogUtils.createOperationContext('updateArticle', this.repositoryName);\n    LogUtils.logOperationStart('updateArticle', context, { articleId });\n\n    try {\n      const { data, error } = await this.adminClient\n        .from('articles')\n        .update(articleData)\n        .eq('id', articleId)\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('updateArticle', context, { updated: true });\n      return Result.success(data as Article);\n\n    } catch (error) {\n      LogUtils.logOperationError('updateArticle', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async deleteArticle(articleId: string): Promise<Result<void, Error>> {\n    const context = LogUtils.createOperationContext('deleteArticle', this.repositoryName);\n    LogUtils.logOperationStart('deleteArticle', context, { articleId });\n\n    try {\n      // Soft delete - update status to archived\n      const { error } = await this.adminClient\n        .from('articles')\n        .update({ status: 'archived' as ArticleStatus })\n        .eq('id', articleId);\n\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('deleteArticle', context, { deleted: true });\n      return Result.success(void 0);\n\n    } catch (error) {\n      LogUtils.logOperationError('deleteArticle', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async updateArticleStatus(articleId: string, status: ArticleStatus): Promise<Result<Article, Error>> {\n    const context = LogUtils.createOperationContext('updateArticleStatus', this.repositoryName);\n    LogUtils.logOperationStart('updateArticleStatus', context, { articleId, status });\n\n    try {\n      const updateData: any = { status };\n\n      // Set published_at when publishing\n      if (status === 'published') {\n        updateData.published_at = new Date().toISOString();\n      }\n\n      const { data, error } = await this.adminClient\n        .from('articles')\n        .update(updateData)\n        .eq('id', articleId)\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('updateArticleStatus', context, { updated: true });\n      return Result.success(data as Article);\n\n    } catch (error) {\n      LogUtils.logOperationError('updateArticleStatus', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations de traduction ===\n\n  async createTranslation(articleId: string, translationData: CreateArticleTranslationData): Promise<Result<ArticleTranslation, Error>> {\n    const context = LogUtils.createOperationContext('createTranslation', this.repositoryName);\n    LogUtils.logOperationStart('createTranslation', context, { articleId, locale: translationData.locale });\n\n    try {\n      // Generate unique slug\n      const slug = await this.generateSlugFromTitle(translationData.title, translationData.locale);\n\n      const { data, error } = await this.adminClient\n        .from('article_translations')\n        .insert({\n          ...translationData,\n          article_id: articleId,\n          slug\n        })\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('createTranslation', context, { created: true });\n      return Result.success(data as ArticleTranslation);\n\n    } catch (error) {\n      LogUtils.logOperationError('createTranslation', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async updateTranslation(articleId: string, locale: string, translationData: UpdateArticleTranslationData): Promise<Result<ArticleTranslation, Error>> {\n    const context = LogUtils.createOperationContext('updateTranslation', this.repositoryName);\n    LogUtils.logOperationStart('updateTranslation', context, { articleId, locale });\n\n    try {\n      const updateData = { ...translationData };\n\n      // Regenerate slug if title changed\n      if (translationData.title) {\n        updateData.slug = await this.generateSlugFromTitle(translationData.title, locale, articleId);\n      }\n\n      const { data, error } = await this.adminClient\n        .from('article_translations')\n        .update(updateData)\n        .eq('article_id', articleId)\n        .eq('locale', locale)\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('updateTranslation', context, { updated: true });\n      return Result.success(data as ArticleTranslation);\n\n    } catch (error) {\n      LogUtils.logOperationError('updateTranslation', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async deleteTranslation(articleId: string, locale: string): Promise<Result<void, Error>> {\n    const context = LogUtils.createOperationContext('deleteTranslation', this.repositoryName);\n    LogUtils.logOperationStart('deleteTranslation', context, { articleId, locale });\n\n    try {\n      const { error } = await this.adminClient\n        .from('article_translations')\n        .delete()\n        .eq('article_id', articleId)\n        .eq('locale', locale);\n\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('deleteTranslation', context, { deleted: true });\n      return Result.success(void 0);\n\n    } catch (error) {\n      LogUtils.logOperationError('deleteTranslation', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async findTranslation(articleId: string, locale: string): Promise<Result<ArticleTranslation | null, Error>> {\n    const context = LogUtils.createOperationContext('findTranslation', this.repositoryName);\n    LogUtils.logOperationStart('findTranslation', context, { articleId, locale });\n\n    try {\n      const { data, error } = await this.client\n        .from('article_translations')\n        .select('*')\n        .eq('article_id', articleId)\n        .eq('locale', locale)\n        .maybeSingle();\n\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('findTranslation', context, { found: !!data });\n      return Result.success(data as ArticleTranslation | null);\n\n    } catch (error) {\n      LogUtils.logOperationError('findTranslation', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations de recherche ===\n\n  async searchArticles(query: string, filters?: ArticleFilters, locale = 'fr'): Promise<Result<ArticleWithCurrentTranslation[], Error>> {\n    const searchParams: ArticleSearchParams = {\n      filters: { ...filters, search: query },\n      locale,\n      sort_by: 'published_at',\n      sort_order: 'desc',\n      limit: 50\n    };\n\n    const result = await this.findPublishedArticles(searchParams);\n    if (result.isFailure()) return result;\n\n    return Result.success(result.data.articles);\n  }\n\n  async getFeaturedArticles(limit = ARTICLE_CONFIG.FEATURED_ARTICLES_LIMIT, locale = 'fr'): Promise<Result<ArticleWithCurrentTranslation[], Error>> {\n    const searchParams: ArticleSearchParams = {\n      filters: { is_featured: true },\n      locale,\n      sort_by: 'sort_order',\n      sort_order: 'asc',\n      limit\n    };\n\n    const result = await this.findPublishedArticles(searchParams);\n    if (result.isFailure()) return result;\n\n    return Result.success(result.data.articles);\n  }\n\n  async getRecentArticles(limit = 10, locale = 'fr'): Promise<Result<ArticleWithCurrentTranslation[], Error>> {\n    const searchParams: ArticleSearchParams = {\n      locale,\n      sort_by: 'published_at',\n      sort_order: 'desc',\n      limit\n    };\n\n    const result = await this.findPublishedArticles(searchParams);\n    if (result.isFailure()) return result;\n\n    return Result.success(result.data.articles);\n  }\n\n  async getPopularArticles(limit = 10, locale = 'fr'): Promise<Result<ArticleWithCurrentTranslation[], Error>> {\n    const searchParams: ArticleSearchParams = {\n      locale,\n      sort_by: 'view_count',\n      sort_order: 'desc',\n      limit\n    };\n\n    const result = await this.findPublishedArticles(searchParams);\n    if (result.isFailure()) return result;\n\n    return Result.success(result.data.articles);\n  }\n\n  async findByCategory(category: string, locale = 'fr'): Promise<Result<ArticleWithCurrentTranslation[], Error>> {\n    const searchParams: ArticleSearchParams = {\n      filters: { categories: [category] },\n      locale,\n      sort_by: 'published_at',\n      sort_order: 'desc',\n      limit: 50\n    };\n\n    const result = await this.findPublishedArticles(searchParams);\n    if (result.isFailure()) return result;\n\n    return Result.success(result.data.articles);\n  }\n\n  async findByTag(tag: string, locale = 'fr'): Promise<Result<ArticleWithCurrentTranslation[], Error>> {\n    const searchParams: ArticleSearchParams = {\n      filters: { tags: [tag] },\n      locale,\n      sort_by: 'published_at',\n      sort_order: 'desc',\n      limit: 50\n    };\n\n    const result = await this.findPublishedArticles(searchParams);\n    if (result.isFailure()) return result;\n\n    return Result.success(result.data.articles);\n  }\n\n  async findRelatedArticles(articleId: string, limit = ARTICLE_CONFIG.RELATED_ARTICLES_LIMIT, locale = 'fr'): Promise<Result<ArticleWithCurrentTranslation[], Error>> {\n    const context = LogUtils.createOperationContext('findRelatedArticles', this.repositoryName);\n    LogUtils.logOperationStart('findRelatedArticles', context, { articleId, limit });\n\n    try {\n      // Get the source article to find common tags/categories\n      const sourceResult = await this.findById(articleId);\n      if (sourceResult.isFailure()) return sourceResult;\n\n      const sourceArticle = sourceResult.data;\n      if (!sourceArticle) {\n        return Result.success([]);\n      }\n\n      // Find articles with similar tags or categories\n      const { data, error } = await this.client\n        .from('articles')\n        .select(`\n          *,\n          translations:article_translations!inner(*)\n        `)\n        .eq('status', 'published')\n        .eq('article_translations.locale', locale)\n        .neq('id', articleId)\n        .or(`tags.ov.{${sourceArticle.tags.join(',')}},categories.ov.{${sourceArticle.categories.join(',')}}`)\n        .order('published_at', { ascending: false })\n        .limit(limit);\n\n      if (error) throw error;\n\n      const articles: ArticleWithCurrentTranslation[] = data.map((article: any) => {\n        const translation = article.translations[0];\n        return {\n          ...article,\n          title: translation.title,\n          slug: translation.slug,\n          excerpt: translation.excerpt,\n          content: translation.content,\n          meta_title: translation.meta_title,\n          meta_description: translation.meta_description,\n          keywords: translation.keywords\n        };\n      });\n\n      LogUtils.logOperationEnd('findRelatedArticles', context, { count: articles.length });\n      return Result.success(articles);\n\n    } catch (error) {\n      LogUtils.logOperationError('findRelatedArticles', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations de validation ===\n\n  async validateArticleData(articleData: CreateArticleData | UpdateArticleData): Promise<Result<void, Error>> {\n    const context = LogUtils.createOperationContext('validateArticleData', this.repositoryName);\n    LogUtils.logOperationStart('validateArticleData', context);\n\n    try {\n      // Validate basic fields\n      if ('status' in articleData && articleData.status === 'scheduled' && !articleData.scheduled_at) {\n        return Result.failure(new ValidationError('scheduled_at is required when status is scheduled'));\n      }\n\n      if ('published_at' in articleData && articleData.published_at && new Date(articleData.published_at) > new Date()) {\n        return Result.failure(new ValidationError('published_at cannot be in the future unless status is scheduled'));\n      }\n\n      LogUtils.logOperationEnd('validateArticleData', context, { valid: true });\n      return Result.success(void 0);\n\n    } catch (error) {\n      LogUtils.logOperationError('validateArticleData', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async isSlugAvailable(slug: string, locale: string, excludeArticleId?: string): Promise<Result<boolean, Error>> {\n    const context = LogUtils.createOperationContext('isSlugAvailable', this.repositoryName);\n    LogUtils.logOperationStart('isSlugAvailable', context, { slug, locale });\n\n    try {\n      let query = this.client\n        .from('article_translations')\n        .select('article_id')\n        .eq('slug', slug)\n        .eq('locale', locale);\n\n      if (excludeArticleId) {\n        query = query.neq('article_id', excludeArticleId);\n      }\n\n      const { data, error } = await query.maybeSingle();\n\n      if (error) throw error;\n\n      const available = !data;\n      LogUtils.logOperationEnd('isSlugAvailable', context, { available });\n      return Result.success(available);\n\n    } catch (error) {\n      LogUtils.logOperationError('isSlugAvailable', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async validateTranslations(translations: CreateArticleTranslationData[]): Promise<Result<void, Error>> {\n    const context = LogUtils.createOperationContext('validateTranslations', this.repositoryName);\n    LogUtils.logOperationStart('validateTranslations', context, { count: translations.length });\n\n    try {\n      const locales = translations.map(t => t.locale);\n      const uniqueLocales = new Set(locales);\n\n      if (locales.length !== uniqueLocales.size) {\n        return Result.failure(new ValidationError('Duplicate locales in translations'));\n      }\n\n      for (const translation of translations) {\n        if (!translation.title?.trim()) {\n          return Result.failure(new ValidationError(`Title is required for locale ${translation.locale}`));\n        }\n        if (!translation.content?.trim()) {\n          return Result.failure(new ValidationError(`Content is required for locale ${translation.locale}`));\n        }\n      }\n\n      LogUtils.logOperationEnd('validateTranslations', context, { valid: true });\n      return Result.success(void 0);\n\n    } catch (error) {\n      LogUtils.logOperationError('validateTranslations', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations SEO ===\n\n  async generateSEOData(articleId: string, locale: string): Promise<Result<ArticleSEOData, Error>> {\n    const context = LogUtils.createOperationContext('generateSEOData', this.repositoryName);\n    LogUtils.logOperationStart('generateSEOData', context, { articleId, locale });\n\n    try {\n      const translationResult = await this.findTranslation(articleId, locale);\n      if (translationResult.isFailure()) return translationResult;\n\n      const translation = translationResult.data;\n      if (!translation) {\n        return Result.failure(new NotFoundError(`Translation not found for article ${articleId} in locale ${locale}`));\n      }\n\n      const seoData: ArticleSEOData = {\n        title: translation.meta_title || translation.title,\n        description: translation.meta_description || translation.excerpt || '',\n        keywords: translation.keywords || [],\n        canonical_url: `/articles/${translation.slug}`,\n        og_title: translation.meta_title || translation.title,\n        og_description: translation.meta_description || translation.excerpt || '',\n        twitter_title: translation.meta_title || translation.title,\n        twitter_description: translation.meta_description || translation.excerpt || ''\n      };\n\n      LogUtils.logOperationEnd('generateSEOData', context, { generated: true });\n      return Result.success(seoData);\n\n    } catch (error) {\n      LogUtils.logOperationError('generateSEOData', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async updateSEOMetadata(articleId: string, locale: string, seoData: Partial<ArticleSEOData>): Promise<Result<ArticleTranslation, Error>> {\n    const context = LogUtils.createOperationContext('updateSEOMetadata', this.repositoryName);\n    LogUtils.logOperationStart('updateSEOMetadata', context, { articleId, locale });\n\n    try {\n      const updateData: UpdateArticleTranslationData = {};\n\n      if (seoData.title) updateData.meta_title = seoData.title;\n      if (seoData.description) updateData.meta_description = seoData.description;\n      if (seoData.keywords) updateData.keywords = seoData.keywords;\n\n      return this.updateTranslation(articleId, locale, updateData);\n\n    } catch (error) {\n      LogUtils.logOperationError('updateSEOMetadata', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async generateUniqueSlug(title: string, locale: string): Promise<Result<string, Error>> {\n    const context = LogUtils.createOperationContext('generateUniqueSlug', this.repositoryName);\n    LogUtils.logOperationStart('generateUniqueSlug', context, { title, locale });\n\n    try {\n      const slug = await this.generateSlugFromTitle(title, locale);\n      LogUtils.logOperationEnd('generateUniqueSlug', context, { slug });\n      return Result.success(slug);\n\n    } catch (error) {\n      LogUtils.logOperationError('generateUniqueSlug', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations d'analytics ===\n\n  async recordView(articleId: string, visitorData?: { ip: string; userAgent: string; referrer?: string }): Promise<Result<void, Error>> {\n    const context = LogUtils.createOperationContext('recordView', this.repositoryName);\n    LogUtils.logOperationStart('recordView', context, { articleId });\n\n    try {\n      // Increment view count\n      const { error: updateError } = await this.adminClient\n        .from('articles')\n        .update({ view_count: this.adminClient.sql`view_count + 1` } as any)\n        .eq('id', articleId);\n\n      if (updateError) throw updateError;\n\n      // Record detailed analytics if visitor data provided\n      if (visitorData) {\n        const { error: analyticsError } = await this.adminClient\n          .from('article_views')\n          .insert({\n            article_id: articleId,\n            visitor_ip: visitorData.ip,\n            user_agent: visitorData.userAgent,\n            referrer: visitorData.referrer,\n            viewed_at: new Date().toISOString()\n          });\n\n        // Don't fail if analytics insert fails\n        if (analyticsError) {\n          LogUtils.logOperationError('recordView', context, analyticsError);\n        }\n      }\n\n      LogUtils.logOperationEnd('recordView', context, { recorded: true });\n      return Result.success(void 0);\n\n    } catch (error) {\n      LogUtils.logOperationError('recordView', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async getArticleAnalytics(articleId: string, _dateFrom?: string, _dateTo?: string): Promise<Result<ArticleAnalytics, Error>> {\n    const context = LogUtils.createOperationContext('getArticleAnalytics', this.repositoryName);\n    LogUtils.logOperationStart('getArticleAnalytics', context, { articleId });\n\n    try {\n      // Basic article data\n      const articleResult = await this.findById(articleId);\n      if (articleResult.isFailure()) return articleResult;\n\n      const article = articleResult.data;\n      if (!article) {\n        return Result.failure(new NotFoundError(`Article ${articleId} not found`));\n      }\n\n      // Calculate date ranges\n      const now = new Date();\n      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n      const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);\n      const monthAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n      // Get view analytics (if views table exists)\n      let viewsToday = 0, viewsWeek = 0, viewsMonth = 0, uniqueVisitors = 0;\n      let topReferrers: { source: string; count: number }[] = [];\n\n      try {\n        const { data: todayViews } = await this.adminClient\n          .from('article_views')\n          .select('*')\n          .eq('article_id', articleId)\n          .gte('viewed_at', today.toISOString());\n\n        viewsToday = todayViews?.length || 0;\n\n        const { data: weekViews } = await this.adminClient\n          .from('article_views')\n          .select('*')\n          .eq('article_id', articleId)\n          .gte('viewed_at', weekAgo.toISOString());\n\n        viewsWeek = weekViews?.length || 0;\n\n        const { data: monthViews } = await this.adminClient\n          .from('article_views')\n          .select('*')\n          .eq('article_id', articleId)\n          .gte('viewed_at', monthAgo.toISOString());\n\n        viewsMonth = monthViews?.length || 0;\n        uniqueVisitors = new Set(monthViews?.map(v => v.visitor_ip)).size;\n\n        // Calculate top referrers\n        const referrerCounts: { [key: string]: number } = {};\n        monthViews?.forEach(view => {\n          if (view.referrer) {\n            const domain = new URL(view.referrer).hostname;\n            referrerCounts[domain] = (referrerCounts[domain] || 0) + 1;\n          }\n        });\n\n        topReferrers = Object.entries(referrerCounts)\n          .map(([source, count]) => ({ source, count }))\n          .sort((a, b) => b.count - a.count)\n          .slice(0, 10);\n\n      } catch (error) {\n        // Views table might not exist, continue with basic data\n        LogUtils.logOperationError('getArticleAnalytics', context, error);\n      }\n\n      const analytics: ArticleAnalytics = {\n        article_id: articleId,\n        views_today: viewsToday,\n        views_week: viewsWeek,\n        views_month: viewsMonth,\n        views_total: article.view_count,\n        unique_visitors: uniqueVisitors,\n        avg_time_on_page: 0, // Would need session tracking\n        bounce_rate: 0, // Would need session tracking\n        top_referrers: topReferrers,\n        top_keywords: [] // Would need search analytics\n      };\n\n      LogUtils.logOperationEnd('getArticleAnalytics', context, { calculated: true });\n      return Result.success(analytics);\n\n    } catch (error) {\n      LogUtils.logOperationError('getArticleAnalytics', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async getMostViewedArticles(limit = 10, locale = 'fr', _period: 'day' | 'week' | 'month' | 'all' = 'all'): Promise<Result<ArticleWithCurrentTranslation[], Error>> {\n    // For simplicity, return popular articles (same as getPopularArticles)\n    return this.getPopularArticles(limit, locale);\n  }\n\n  // === Opérations de gestion ===\n\n  async publishScheduledArticle(articleId: string): Promise<Result<Article, Error>> {\n    const context = LogUtils.createOperationContext('publishScheduledArticle', this.repositoryName);\n    LogUtils.logOperationStart('publishScheduledArticle', context, { articleId });\n\n    try {\n      const { data, error } = await this.adminClient\n        .from('articles')\n        .update({\n          status: 'published' as ArticleStatus,\n          published_at: new Date().toISOString()\n        })\n        .eq('id', articleId)\n        .eq('status', 'scheduled')\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('publishScheduledArticle', context, { published: true });\n      return Result.success(data as Article);\n\n    } catch (error) {\n      LogUtils.logOperationError('publishScheduledArticle', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async archiveOldArticles(olderThanDays: number): Promise<Result<number, Error>> {\n    const context = LogUtils.createOperationContext('archiveOldArticles', this.repositoryName);\n    LogUtils.logOperationStart('archiveOldArticles', context, { olderThanDays });\n\n    try {\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);\n\n      const { data, error } = await this.adminClient\n        .from('articles')\n        .update({ status: 'archived' as ArticleStatus })\n        .lt('published_at', cutoffDate.toISOString())\n        .eq('status', 'published')\n        .select('id');\n\n      if (error) throw error;\n\n      const archivedCount = data?.length || 0;\n      LogUtils.logOperationEnd('archiveOldArticles', context, { archived: archivedCount });\n      return Result.success(archivedCount);\n\n    } catch (error) {\n      LogUtils.logOperationError('archiveOldArticles', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async updateReadingTime(articleId: string): Promise<Result<Article, Error>> {\n    const context = LogUtils.createOperationContext('updateReadingTime', this.repositoryName);\n    LogUtils.logOperationStart('updateReadingTime', context, { articleId });\n\n    try {\n      // Get article content from translations\n      const { data: translations, error: translationError } = await this.client\n        .from('article_translations')\n        .select('content')\n        .eq('article_id', articleId);\n\n      if (translationError) throw translationError;\n\n      // Calculate reading time from longest content\n      let maxReadingTime = 0;\n      if (translations) {\n        for (const translation of translations) {\n          const readingTime = this.calculateReadingTime(translation.content);\n          maxReadingTime = Math.max(maxReadingTime, readingTime);\n        }\n      }\n\n      const { data, error } = await this.adminClient\n        .from('articles')\n        .update({ reading_time_minutes: maxReadingTime })\n        .eq('id', articleId)\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('updateReadingTime', context, { updated: true });\n      return Result.success(data as Article);\n\n    } catch (error) {\n      LogUtils.logOperationError('updateReadingTime', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async getArticleStats(): Promise<Result<{\n    total: number;\n    published: number;\n    draft: number;\n    archived: number;\n    scheduled: number;\n    total_views: number;\n    avg_reading_time: number;\n  }, Error>> {\n    const context = LogUtils.createOperationContext('getArticleStats', this.repositoryName);\n    LogUtils.logOperationStart('getArticleStats', context);\n\n    try {\n      const { data, error } = await this.adminClient\n        .from('articles')\n        .select('status, view_count, reading_time_minutes');\n\n      if (error) throw error;\n\n      const stats = {\n        total: 0,\n        published: 0,\n        draft: 0,\n        archived: 0,\n        scheduled: 0,\n        total_views: 0,\n        avg_reading_time: 0\n      };\n\n      let totalReadingTime = 0;\n      let articlesWithReadingTime = 0;\n\n      if (data) {\n        stats.total = data.length;\n        \n        for (const article of data) {\n          stats[article.status as keyof typeof stats] = (stats[article.status as keyof typeof stats] as number) + 1;\n          stats.total_views += article.view_count || 0;\n          \n          if (article.reading_time_minutes) {\n            totalReadingTime += article.reading_time_minutes;\n            articlesWithReadingTime++;\n          }\n        }\n\n        if (articlesWithReadingTime > 0) {\n          stats.avg_reading_time = Math.round(totalReadingTime / articlesWithReadingTime);\n        }\n      }\n\n      LogUtils.logOperationEnd('getArticleStats', context, stats);\n      return Result.success(stats);\n\n    } catch (error) {\n      LogUtils.logOperationError('getArticleStats', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations utilitaires ===\n\n  async getAllCategories(): Promise<Result<string[], Error>> {\n    const context = LogUtils.createOperationContext('getAllCategories', this.repositoryName);\n    LogUtils.logOperationStart('getAllCategories', context);\n\n    try {\n      const { data, error } = await this.client\n        .from('articles')\n        .select('categories')\n        .eq('status', 'published');\n\n      if (error) throw error;\n\n      const categoriesSet = new Set<string>();\n      if (data) {\n        for (const article of data) {\n          if (article.categories) {\n            article.categories.forEach((cat: string) => categoriesSet.add(cat));\n          }\n        }\n      }\n\n      const categories = Array.from(categoriesSet).sort();\n      LogUtils.logOperationEnd('getAllCategories', context, { count: categories.length });\n      return Result.success(categories);\n\n    } catch (error) {\n      LogUtils.logOperationError('getAllCategories', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async getAllTags(): Promise<Result<string[], Error>> {\n    const context = LogUtils.createOperationContext('getAllTags', this.repositoryName);\n    LogUtils.logOperationStart('getAllTags', context);\n\n    try {\n      const { data, error } = await this.client\n        .from('articles')\n        .select('tags')\n        .eq('status', 'published');\n\n      if (error) throw error;\n\n      const tagsSet = new Set<string>();\n      if (data) {\n        for (const article of data) {\n          if (article.tags) {\n            article.tags.forEach((tag: string) => tagsSet.add(tag));\n          }\n        }\n      }\n\n      const tags = Array.from(tagsSet).sort();\n      LogUtils.logOperationEnd('getAllTags', context, { count: tags.length });\n      return Result.success(tags);\n\n    } catch (error) {\n      LogUtils.logOperationError('getAllTags', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async cleanupUnusedTaxonomies(): Promise<Result<{ removedTags: number; removedCategories: number }, Error>> {\n    const context = LogUtils.createOperationContext('cleanupUnusedTaxonomies', this.repositoryName);\n    LogUtils.logOperationStart('cleanupUnusedTaxonomies', context);\n\n    try {\n      // This would require a more complex implementation to identify and remove unused taxonomies\n      // For now, return a placeholder result\n      const result = { removedTags: 0, removedCategories: 0 };\n      \n      LogUtils.logOperationEnd('cleanupUnusedTaxonomies', context, result);\n      return Result.success(result);\n\n    } catch (error) {\n      LogUtils.logOperationError('cleanupUnusedTaxonomies', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async exportArticles(filters?: ArticleFilters): Promise<Result<string, Error>> {\n    const context = LogUtils.createOperationContext('exportArticles', this.repositoryName);\n    LogUtils.logOperationStart('exportArticles', context, filters);\n\n    try {\n      const searchParams: ArticleSearchParams = {\n        filters,\n        limit: 1000 // Large limit for export\n      };\n\n      const result = await this.findAllArticles(searchParams);\n      if (result.isFailure()) return result;\n\n      const exportData = JSON.stringify(result.data.articles, null, 2);\n      \n      LogUtils.logOperationEnd('exportArticles', context, { exported: result.data.articles.length });\n      return Result.success(exportData);\n\n    } catch (error) {\n      LogUtils.logOperationError('exportArticles', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  // === Base Repository Implementation ===\n\n  async findById(id: string): Promise<Result<Article | null, Error>> {\n    const context = LogUtils.createOperationContext('findById', this.repositoryName);\n    LogUtils.logOperationStart('findById', context, { id });\n\n    try {\n      const { data, error } = await this.client\n        .from('articles')\n        .select('*')\n        .eq('id', id)\n        .maybeSingle();\n\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('findById', context, { found: !!data });\n      return Result.success(data as Article | null);\n\n    } catch (error) {\n      LogUtils.logOperationError('findById', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async findMany(options?: { where?: any; orderBy?: { field: string; direction: 'asc' | 'desc' }; limit?: number }): Promise<Result<Article[], Error>> {\n    const context = LogUtils.createOperationContext('findMany', this.repositoryName);\n    LogUtils.logOperationStart('findMany', context, options);\n\n    try {\n      let query = this.client.from('articles').select('*');\n\n      if (options?.where) {\n        Object.entries(options.where).forEach(([key, value]) => {\n          query = query.eq(key, value);\n        });\n      }\n\n      if (options?.orderBy) {\n        query = query.order(options.orderBy.field, { ascending: options.orderBy.direction === 'asc' });\n      }\n\n      if (options?.limit) {\n        query = query.limit(options.limit);\n      }\n\n      const { data, error } = await query;\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('findMany', context, { count: data?.length || 0 });\n      return Result.success((data || []) as Article[]);\n\n    } catch (error) {\n      LogUtils.logOperationError('findMany', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async findFirst(criteria: Partial<Article>): Promise<Result<Article | null, Error>> {\n    const context = LogUtils.createOperationContext('findFirst', this.repositoryName);\n    LogUtils.logOperationStart('findFirst', context, criteria);\n\n    try {\n      let query = this.client.from('articles').select('*');\n\n      Object.entries(criteria).forEach(([key, value]) => {\n        if (value !== undefined) {\n          query = query.eq(key, value);\n        }\n      });\n\n      const { data, error } = await query.limit(1).maybeSingle();\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('findFirst', context, { found: !!data });\n      return Result.success(data as Article | null);\n\n    } catch (error) {\n      LogUtils.logOperationError('findFirst', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async create(data: CreateArticleData): Promise<Result<Article, Error>> {\n    return this.createArticle(data);\n  }\n\n  async update(id: string, data: UpdateArticleData): Promise<Result<Article, Error>> {\n    return this.updateArticle(id, data);\n  }\n\n  async delete(id: string): Promise<Result<boolean, Error>> {\n    const result = await this.deleteArticle(id);\n    if (result.isFailure()) return Result.failure(result.error);\n    return Result.success(true);\n  }\n\n  async count(criteria?: Partial<Article>): Promise<Result<number, Error>> {\n    const context = LogUtils.createOperationContext('count', this.repositoryName);\n    LogUtils.logOperationStart('count', context, criteria);\n\n    try {\n      let query = this.client.from('articles').select('*', { count: 'exact', head: true });\n\n      if (criteria) {\n        Object.entries(criteria).forEach(([key, value]) => {\n          if (value !== undefined) {\n            query = query.eq(key, value);\n          }\n        });\n      }\n\n      const { count, error } = await query;\n      if (error) throw error;\n\n      LogUtils.logOperationEnd('count', context, { count: count || 0 });\n      return Result.success(count || 0);\n\n    } catch (error) {\n      LogUtils.logOperationError('count', context, error);\n      return this.handleError(error);\n    }\n  }\n\n  async exists(criteria: Partial<Article>): Promise<Result<boolean, Error>> {\n    const result = await this.findFirst(criteria);\n    if (result.isFailure()) return Result.failure(result.error);\n    return Result.success(!!result.data);\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\repositories\\base-supabase.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1160,1163],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1160,1163],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1246,1249],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1246,1249],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1305,1308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1305,1308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":383,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":383,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11749,11752],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11749,11752],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-prototype-builtins","severity":1,"message":"Do not access Object.prototype method 'hasOwnProperty' from target object.","line":416,"column":55,"nodeType":"CallExpression","messageId":"prototypeBuildIn","endLine":416,"endColumn":69,"suggestions":[{"messageId":"callObjectPrototype","data":{"prop":"hasOwnProperty"},"fix":{"range":[12830,12851],"text":"Object.prototype.hasOwnProperty.call(value, "},"desc":"Call Object.prototype.hasOwnProperty explicitly."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":418,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":418,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13010,13013],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13010,13013],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'entity' is defined but never used. Allowed unused args must match /^_/u.","line":465,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":465,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Base Supabase Repository Implementation\n * \n * Provides common functionality for all Supabase repositories\n * with type safety and error handling.\n */\n\nimport { SupabaseClient } from \"@supabase/supabase-js\";\nimport { Result } from \"@/lib/core/result\";\nimport { DatabaseError, NotFoundError, ErrorUtils } from \"@/lib/core/errors\";\nimport { logger } from \"@/lib/core/logger\";\nimport { Repository, FindManyOptions, PaginatedResult } from \"@/lib/domain/interfaces/repository.interface\";\n\n/**\n * Supabase query builder type helpers\n */\ntype SupabaseQueryBuilder = ReturnType<SupabaseClient['from']>;\ntype SupabaseSelectBuilder = ReturnType<SupabaseQueryBuilder['select']>;\n\n/**\n * Base repository for Supabase with common operations\n */\nexport abstract class BaseSupabaseRepository<\n  TEntity,\n  TCreateInput = Partial<TEntity>,\n  TUpdateInput = Partial<TEntity>\n> implements Repository<TEntity, TCreateInput, TUpdateInput> {\n  \n  constructor(\n    protected readonly supabase: SupabaseClient,\n    protected readonly tableName: string\n  ) {}\n\n  /**\n   * Abstract methods that must be implemented by concrete repositories\n   */\n  abstract mapFromDatabase(raw: any): Result<TEntity, DatabaseError>;\n  abstract mapToDatabase(entity: TCreateInput): any;\n  abstract mapUpdateToDatabase(entity: TUpdateInput): any;\n\n  /**\n   * Find entity by ID\n   */\n  async findById(id: string): Promise<Result<TEntity | null, DatabaseError>> {\n    try {\n      const { data, error } = await this.supabase\n        .from(this.tableName)\n        .select('*')\n        .eq('id', id)\n        .maybeSingle();\n\n      if (error) {\n        logger.error(`Repository findById failed for ${this.tableName}`, error, { id });\n        return Result.error(ErrorUtils.fromSupabaseError(error) as DatabaseError);\n      }\n\n      if (!data) {\n        return Result.ok(null);\n      }\n\n      const mappingResult = this.mapFromDatabase(data);\n      if (mappingResult.isError()) {\n        return Result.error(mappingResult.getError());\n      }\n\n      return Result.ok(mappingResult.getValue());\n    } catch (error) {\n      logger.error(`Repository findById exception for ${this.tableName}`, error, { id });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Find multiple entities\n   */\n  async findMany(options: FindManyOptions<TEntity> = {}): Promise<Result<TEntity[], DatabaseError>> {\n    try {\n      let query = this.supabase.from(this.tableName).select('*');\n\n      // Apply where conditions\n      if (options.where) {\n        query = this.applyWhereConditions(query, options.where);\n      }\n\n      // Apply ordering\n      if (options.orderBy) {\n        for (const order of options.orderBy) {\n          query = query.order(order.field as string, { ascending: order.direction === 'asc' });\n        }\n      }\n\n      // Apply pagination\n      if (options.limit) {\n        query = query.limit(options.limit);\n      }\n      if (options.offset) {\n        query = query.range(options.offset, options.offset + (options.limit || 100) - 1);\n      }\n\n      const { data, error } = await query;\n\n      if (error) {\n        logger.error(`Repository findMany failed for ${this.tableName}`, error, { options });\n        return Result.error(ErrorUtils.fromSupabaseError(error) as DatabaseError);\n      }\n\n      if (!data) {\n        return Result.ok([]);\n      }\n\n      // Map all entities\n      const entities: TEntity[] = [];\n      for (const raw of data) {\n        const mappingResult = this.mapFromDatabase(raw);\n        if (mappingResult.isError()) {\n          logger.warn(`Failed to map entity in findMany for ${this.tableName}`, mappingResult.getError(), { raw });\n          continue; // Skip invalid entities\n        }\n        entities.push(mappingResult.getValue());\n      }\n\n      return Result.ok(entities);\n    } catch (error) {\n      logger.error(`Repository findMany exception for ${this.tableName}`, error, { options });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Find first entity matching criteria\n   */\n  async findFirst(criteria: Partial<TEntity>): Promise<Result<TEntity | null, DatabaseError>> {\n    const result = await this.findMany({ where: criteria, limit: 1 });\n    if (result.isError()) {\n      return Result.error(result.getError());\n    }\n\n    const entities = result.getValue();\n    return Result.ok(entities.length > 0 ? entities[0] : null);\n  }\n\n  /**\n   * Create new entity\n   */\n  async create(data: TCreateInput): Promise<Result<TEntity, DatabaseError>> {\n    try {\n      const dbData = this.mapToDatabase(data);\n      \n      const { data: createdData, error } = await this.supabase\n        .from(this.tableName)\n        .insert(dbData)\n        .select()\n        .single();\n\n      if (error) {\n        logger.error(`Repository create failed for ${this.tableName}`, error, { data: dbData });\n        return Result.error(ErrorUtils.fromSupabaseError(error) as DatabaseError);\n      }\n\n      if (!createdData) {\n        return Result.error(new DatabaseError('Create operation returned no data'));\n      }\n\n      const mappingResult = this.mapFromDatabase(createdData);\n      if (mappingResult.isError()) {\n        return Result.error(mappingResult.getError());\n      }\n\n      return Result.ok(mappingResult.getValue());\n    } catch (error) {\n      logger.error(`Repository create exception for ${this.tableName}`, error, { data });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Update existing entity\n   */\n  async update(id: string, data: TUpdateInput): Promise<Result<TEntity, DatabaseError>> {\n    try {\n      const dbData = this.mapUpdateToDatabase(data);\n      \n      const { data: updatedData, error } = await this.supabase\n        .from(this.tableName)\n        .update(dbData)\n        .eq('id', id)\n        .select()\n        .single();\n\n      if (error) {\n        logger.error(`Repository update failed for ${this.tableName}`, error, { id, data: dbData });\n        return Result.error(ErrorUtils.fromSupabaseError(error) as DatabaseError);\n      }\n\n      if (!updatedData) {\n        return Result.error(new NotFoundError(this.tableName, id));\n      }\n\n      const mappingResult = this.mapFromDatabase(updatedData);\n      if (mappingResult.isError()) {\n        return Result.error(mappingResult.getError());\n      }\n\n      return Result.ok(mappingResult.getValue());\n    } catch (error) {\n      logger.error(`Repository update exception for ${this.tableName}`, error, { id, data });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Delete entity by ID\n   */\n  async delete(id: string): Promise<Result<boolean, DatabaseError>> {\n    try {\n      const { error } = await this.supabase\n        .from(this.tableName)\n        .delete()\n        .eq('id', id);\n\n      if (error) {\n        logger.error(`Repository delete failed for ${this.tableName}`, error, { id });\n        return Result.error(ErrorUtils.fromSupabaseError(error) as DatabaseError);\n      }\n\n      return Result.ok(true);\n    } catch (error) {\n      logger.error(`Repository delete exception for ${this.tableName}`, error, { id });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Count entities matching criteria\n   */\n  async count(criteria?: Partial<TEntity>): Promise<Result<number, DatabaseError>> {\n    try {\n      let query = this.supabase\n        .from(this.tableName)\n        .select('*', { count: 'exact', head: true });\n\n      if (criteria) {\n        query = this.applyWhereConditions(query, criteria);\n      }\n\n      const { count, error } = await query;\n\n      if (error) {\n        logger.error(`Repository count failed for ${this.tableName}`, error, { criteria });\n        return Result.error(ErrorUtils.fromSupabaseError(error) as DatabaseError);\n      }\n\n      return Result.ok(count || 0);\n    } catch (error) {\n      logger.error(`Repository count exception for ${this.tableName}`, error, { criteria });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Check if entity exists\n   */\n  async exists(criteria: Partial<TEntity>): Promise<Result<boolean, DatabaseError>> {\n    const countResult = await this.count(criteria);\n    if (countResult.isError()) {\n      return Result.error(countResult.getError());\n    }\n\n    return Result.ok(countResult.getValue() > 0);\n  }\n\n  /**\n   * Find with pagination\n   */\n  async findWithPagination(\n    options: FindManyOptions<TEntity> & { page: number; limit: number }\n  ): Promise<Result<PaginatedResult<TEntity>, DatabaseError>> {\n    const offset = (options.page - 1) * options.limit;\n    \n    // Get total count\n    const countResult = await this.count(options.where);\n    if (countResult.isError()) {\n      return Result.error(countResult.getError());\n    }\n\n    const total = countResult.getValue();\n\n    // Get paginated data\n    const dataResult = await this.findMany({\n      ...options,\n      offset,\n      limit: options.limit,\n    });\n\n    if (dataResult.isError()) {\n      return Result.error(dataResult.getError());\n    }\n\n    const data = dataResult.getValue();\n    const totalPages = Math.ceil(total / options.limit);\n\n    const paginatedResult: PaginatedResult<TEntity> = {\n      data,\n      pagination: {\n        page: options.page,\n        limit: options.limit,\n        total,\n        totalPages,\n        hasNext: options.page < totalPages,\n        hasPrev: options.page > 1,\n      },\n    };\n\n    return Result.ok(paginatedResult);\n  }\n\n  /**\n   * Batch create entities\n   */\n  async createMany(data: TCreateInput[]): Promise<Result<TEntity[], DatabaseError>> {\n    try {\n      const dbData = data.map(item => this.mapToDatabase(item));\n      \n      const { data: createdData, error } = await this.supabase\n        .from(this.tableName)\n        .insert(dbData)\n        .select();\n\n      if (error) {\n        logger.error(`Repository createMany failed for ${this.tableName}`, error, { count: data.length });\n        return Result.error(ErrorUtils.fromSupabaseError(error) as DatabaseError);\n      }\n\n      if (!createdData) {\n        return Result.error(new DatabaseError('Batch create operation returned no data'));\n      }\n\n      // Map all entities\n      const entities: TEntity[] = [];\n      for (const raw of createdData) {\n        const mappingResult = this.mapFromDatabase(raw);\n        if (mappingResult.isError()) {\n          logger.warn(`Failed to map entity in createMany for ${this.tableName}`, mappingResult.getError(), { raw });\n          continue;\n        }\n        entities.push(mappingResult.getValue());\n      }\n\n      return Result.ok(entities);\n    } catch (error) {\n      logger.error(`Repository createMany exception for ${this.tableName}`, error, { count: data.length });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Batch delete entities\n   */\n  async deleteMany(ids: string[]): Promise<Result<boolean, DatabaseError>> {\n    try {\n      const { error } = await this.supabase\n        .from(this.tableName)\n        .delete()\n        .in('id', ids);\n\n      if (error) {\n        logger.error(`Repository deleteMany failed for ${this.tableName}`, error, { ids });\n        return Result.error(ErrorUtils.fromSupabaseError(error) as DatabaseError);\n      }\n\n      return Result.ok(true);\n    } catch (error) {\n      logger.error(`Repository deleteMany exception for ${this.tableName}`, error, { ids });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Execute raw SQL query (use with caution)\n   */\n  protected async executeRawQuery<T>(\n    query: string,\n    params?: any[]\n  ): Promise<Result<T[], DatabaseError>> {\n    try {\n      const { data, error } = await this.supabase.rpc('execute_sql', {\n        query,\n        params: params || [],\n      });\n\n      if (error) {\n        logger.error(`Raw query failed for ${this.tableName}`, error, { query, params });\n        return Result.error(ErrorUtils.fromSupabaseError(error) as DatabaseError);\n      }\n\n      return Result.ok(data || []);\n    } catch (error) {\n      logger.error(`Raw query exception for ${this.tableName}`, error, { query, params });\n      return Result.error(new DatabaseError('Raw query execution failed', error));\n    }\n  }\n\n  /**\n   * Apply where conditions to query\n   */\n  private applyWhereConditions(\n    query: SupabaseSelectBuilder,\n    where: Partial<TEntity>\n  ): SupabaseSelectBuilder {\n    let modifiedQuery = query;\n\n    for (const [key, value] of Object.entries(where)) {\n      if (value !== undefined && value !== null) {\n        if (Array.isArray(value)) {\n          modifiedQuery = modifiedQuery.in(key, value);\n        } else if (typeof value === 'object' && value.hasOwnProperty('operator')) {\n          // Support for complex operators like { operator: 'gte', value: 100 }\n          const condition = value as { operator: string; value: any };\n          switch (condition.operator) {\n            case 'gte':\n              modifiedQuery = modifiedQuery.gte(key, condition.value);\n              break;\n            case 'lte':\n              modifiedQuery = modifiedQuery.lte(key, condition.value);\n              break;\n            case 'gt':\n              modifiedQuery = modifiedQuery.gt(key, condition.value);\n              break;\n            case 'lt':\n              modifiedQuery = modifiedQuery.lt(key, condition.value);\n              break;\n            case 'like':\n              modifiedQuery = modifiedQuery.like(key, condition.value);\n              break;\n            case 'ilike':\n              modifiedQuery = modifiedQuery.ilike(key, condition.value);\n              break;\n          }\n        } else {\n          modifiedQuery = modifiedQuery.eq(key, value);\n        }\n      }\n    }\n\n    return modifiedQuery;\n  }\n\n  /**\n   * Helper method to generate UUID\n   */\n  protected generateId(): string {\n    return crypto.randomUUID();\n  }\n\n  /**\n   * Helper method to get current timestamp\n   */\n  protected getCurrentTimestamp(): Date {\n    return new Date();\n  }\n\n  /**\n   * Validate entity before database operation\n   */\n  protected validateEntity(entity: TCreateInput | TUpdateInput): Result<void, DatabaseError> {\n    // Override in concrete repositories for specific validation\n    return Result.ok(undefined);\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\repositories\\cart.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NotFoundError' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'raw' is defined but never used. Allowed unused args must match /^_/u.","line":428,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":428,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":428,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":428,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12792,12795],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12792,12795],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":432,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":432,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12961,12964],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12961,12964],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":441,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":441,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13191,13194],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13191,13194],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":442,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":442,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13213,13216],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13213,13216],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Cart Repository Implementation with Supabase\n * \n * Handles cart persistence with proper mapping between domain entities\n * and database records.\n */\n\nimport { SupabaseClient } from \"@supabase/supabase-js\";\nimport { Result } from \"@/lib/core/result\";\nimport { DatabaseError, NotFoundError, ErrorUtils } from \"@/lib/core/errors\";\nimport { logger } from \"@/lib/core/logger\";\nimport { BaseSupabaseRepository } from \"./base-supabase.repository\";\nimport { Cart } from \"@/lib/domain/entities/cart.entity\";\nimport { CartRepository } from \"@/lib/domain/services/cart.service\";\n\n/**\n * Database interfaces for cart-related tables\n */\ninterface CartRecord {\n  id: string;\n  user_id: string;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface CartItemRecord {\n  id: string;\n  cart_id: string;\n  product_id: string;\n  quantity: number;\n  added_at: string;\n}\n\ninterface ProductRecord {\n  id: string;\n  name: string;\n  price: number;\n  stock: number;\n  slug?: string;\n  image_url?: string;\n  is_active: boolean;\n}\n\n/**\n * Combined cart with items data structure from database\n */\ninterface CartWithItemsRecord extends CartRecord {\n  cart_items: (CartItemRecord & {\n    products: ProductRecord;\n  })[];\n}\n\n/**\n * Supabase Cart Repository implementation\n */\nexport class SupabaseCartRepository extends BaseSupabaseRepository<Cart, Partial<Cart>, Partial<Cart>> implements CartRepository {\n  \n  constructor(supabase: SupabaseClient) {\n    super(supabase, 'carts');\n  }\n\n  /**\n   * Find cart by user ID with all items and product details\n   */\n  async findByUserId(userId: string): Promise<Result<Cart | null, DatabaseError>> {\n    try {\n      const { data, error } = await this.supabase\n        .from('carts')\n        .select(`\n          id,\n          user_id,\n          created_at,\n          updated_at,\n          cart_items (\n            id,\n            cart_id,\n            product_id,\n            quantity,\n            added_at,\n            products (\n              id,\n              name,\n              price,\n              stock,\n              slug,\n              image_url,\n              is_active\n            )\n          )\n        `)\n        .eq('user_id', userId)\n        .maybeSingle();\n\n      if (error) {\n        logger.error('Failed to find cart by user ID', error, { userId });\n        return Result.error(ErrorUtils.fromSupabaseError(error) as DatabaseError);\n      }\n\n      if (!data) {\n        return Result.ok(null);\n      }\n\n      const mappingResult = this.mapCartWithItemsFromDatabase(data as unknown as CartWithItemsRecord);\n      if (mappingResult.isError()) {\n        return Result.error(mappingResult.getError() as DatabaseError);\n      }\n\n      return Result.ok(mappingResult.getValue());\n    } catch (error) {\n      logger.error('Exception in findByUserId', error, { userId });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Find cart by ID with all items and product details\n   */\n  async findById(cartId: string): Promise<Result<Cart | null, DatabaseError>> {\n    try {\n      const { data, error } = await this.supabase\n        .from('carts')\n        .select(`\n          id,\n          user_id,\n          created_at,\n          updated_at,\n          cart_items (\n            id,\n            cart_id,\n            product_id,\n            quantity,\n            added_at,\n            products (\n              id,\n              name,\n              price,\n              stock,\n              slug,\n              image_url,\n              is_active\n            )\n          )\n        `)\n        .eq('id', cartId)\n        .maybeSingle();\n\n      if (error) {\n        logger.error('Failed to find cart by ID', error, { cartId });\n        return Result.error(ErrorUtils.fromSupabaseError(error) as DatabaseError);\n      }\n\n      if (!data) {\n        return Result.ok(null);\n      }\n\n      const mappingResult = this.mapCartWithItemsFromDatabase(data as unknown as CartWithItemsRecord);\n      if (mappingResult.isError()) {\n        return Result.error(mappingResult.getError() as DatabaseError);\n      }\n\n      return Result.ok(mappingResult.getValue());\n    } catch (error) {\n      logger.error('Exception in findById', error, { cartId });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Save cart with all its items\n   */\n  async save(cart: Cart): Promise<Result<Cart, DatabaseError>> {\n    try {\n      // Start transaction using Supabase's built-in transaction support\n      const { error: cartError } = await this.supabase\n        .from('carts')\n        .upsert({\n          id: cart.id,\n          user_id: cart.userId,\n          created_at: cart.createdAt.toISOString(),\n          updated_at: cart.updatedAt.toISOString(),\n        })\n        .select()\n        .single();\n\n      if (cartError) {\n        logger.error('Failed to save cart', cartError, { cartId: cart.id });\n        return Result.error(ErrorUtils.fromSupabaseError(cartError) as DatabaseError);\n      }\n\n      // Get current cart items to determine what to add/update/delete\n      const { data: currentItems, error: currentItemsError } = await this.supabase\n        .from('cart_items')\n        .select('id, product_id')\n        .eq('cart_id', cart.id);\n\n      if (currentItemsError) {\n        logger.error('Failed to get current cart items', currentItemsError, { cartId: cart.id });\n        return Result.error(ErrorUtils.fromSupabaseError(currentItemsError) as DatabaseError);\n      }\n\n      const currentItemIds = new Set((currentItems || []).map(item => item.id));\n      const newItems = cart.getItems();\n      const newItemIds = new Set(newItems.map(item => item.id));\n\n      // Delete items that are no longer in the cart\n      const itemsToDelete = Array.from(currentItemIds).filter(id => !newItemIds.has(id));\n      if (itemsToDelete.length > 0) {\n        const { error: deleteError } = await this.supabase\n          .from('cart_items')\n          .delete()\n          .in('id', itemsToDelete);\n\n        if (deleteError) {\n          logger.error('Failed to delete cart items', deleteError, { cartId: cart.id, itemsToDelete });\n          return Result.error(ErrorUtils.fromSupabaseError(deleteError) as DatabaseError);\n        }\n      }\n\n      // Upsert current items\n      if (newItems.length > 0) {\n        const itemRecords = newItems.map(item => ({\n          id: item.id,\n          cart_id: cart.id,\n          product_id: item.productReference.id,\n          quantity: item.quantity.value,\n          added_at: item.addedAt.toISOString(),\n        }));\n\n        const { error: itemsError } = await this.supabase\n          .from('cart_items')\n          .upsert(itemRecords);\n\n        if (itemsError) {\n          logger.error('Failed to save cart items', itemsError, { cartId: cart.id });\n          return Result.error(ErrorUtils.fromSupabaseError(itemsError) as DatabaseError);\n        }\n      }\n\n      // Return the saved cart by fetching it with all items\n      const savedCartResult = await this.findById(cart.id);\n      if (savedCartResult.isError()) {\n        return Result.error(savedCartResult.getError());\n      }\n\n      const savedCartWithItems = savedCartResult.getValue();\n      if (!savedCartWithItems) {\n        return Result.error(new DatabaseError('Cart not found', new Error(`Cart ${cart.id} not found`)));\n      }\n\n      return Result.ok(savedCartWithItems);\n    } catch (error) {\n      logger.error('Exception in save cart', error, { cartId: cart.id });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Delete cart and all its items\n   */\n  async delete(cartId: string): Promise<Result<boolean, DatabaseError>> {\n    try {\n      // Delete cart items first (foreign key constraint)\n      const { error: itemsError } = await this.supabase\n        .from('cart_items')\n        .delete()\n        .eq('cart_id', cartId);\n\n      if (itemsError) {\n        logger.error('Failed to delete cart items', itemsError, { cartId });\n        return Result.error(ErrorUtils.fromSupabaseError(itemsError) as DatabaseError);\n      }\n\n      // Delete cart\n      const { error: cartError } = await this.supabase\n        .from('carts')\n        .delete()\n        .eq('id', cartId);\n\n      if (cartError) {\n        logger.error('Failed to delete cart', cartError, { cartId });\n        return Result.error(ErrorUtils.fromSupabaseError(cartError) as DatabaseError);\n      }\n\n      return Result.ok(true);\n    } catch (error) {\n      logger.error('Exception in delete cart', error, { cartId });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Find all carts for admin/reporting purposes\n   */\n  async findAllWithPagination(options: {\n    page: number;\n    limit: number;\n    userId?: string;\n    dateFrom?: Date;\n    dateTo?: Date;\n  }): Promise<Result<{ carts: Cart[]; total: number }, Error>> {\n    try {\n      let query = this.supabase\n        .from('carts')\n        .select(`\n          id,\n          user_id,\n          created_at,\n          updated_at,\n          cart_items (\n            id,\n            cart_id,\n            product_id,\n            quantity,\n            added_at,\n            products (\n              id,\n              name,\n              price,\n              stock,\n              slug,\n              image_url,\n              is_active\n            )\n          )\n        `, { count: 'exact' });\n\n      // Apply filters\n      if (options.userId) {\n        query = query.eq('user_id', options.userId);\n      }\n      if (options.dateFrom) {\n        query = query.gte('created_at', options.dateFrom.toISOString());\n      }\n      if (options.dateTo) {\n        query = query.lte('created_at', options.dateTo.toISOString());\n      }\n\n      // Apply pagination\n      const offset = (options.page - 1) * options.limit;\n      query = query.range(offset, offset + options.limit - 1);\n\n      // Order by creation date (newest first)\n      query = query.order('created_at', { ascending: false });\n\n      const { data, error, count } = await query;\n\n      if (error) {\n        logger.error('Failed to find carts with pagination', error, { options });\n        return Result.error(ErrorUtils.fromSupabaseError(error) as DatabaseError);\n      }\n\n      if (!data) {\n        return Result.ok({ carts: [], total: count || 0 });\n      }\n\n      // Map carts\n      const carts: Cart[] = [];\n      for (const cartData of data as unknown as CartWithItemsRecord[]) {\n        const mappingResult = this.mapCartWithItemsFromDatabase(cartData);\n        if (mappingResult.isError()) {\n          logger.warn('Failed to map cart in findAllWithPagination', { error: mappingResult.getError(), cartId: cartData.id });\n          continue;\n        }\n        carts.push(mappingResult.getValue());\n      }\n\n      return Result.ok({ carts, total: count || 0 });\n    } catch (error) {\n      logger.error('Exception in findAllWithPagination', error, { options });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Get cart statistics for admin dashboard\n   */\n  async getCartStatistics(): Promise<Result<{\n    totalCarts: number;\n    activeCarts: number;\n    totalItems: number;\n    averageItemsPerCart: number;\n  }, Error>> {\n    try {\n      // Get cart counts\n      const { count: totalCarts, error: totalError } = await this.supabase\n        .from('carts')\n        .select('*', { count: 'exact', head: true });\n\n      if (totalError) {\n        return Result.error(ErrorUtils.fromSupabaseError(totalError));\n      }\n\n      // Get active carts (with items)\n      const { count: activeCarts, error: activeError } = await this.supabase\n        .from('carts')\n        .select('cart_items!inner(*)', { count: 'exact', head: true });\n\n      if (activeError) {\n        return Result.error(ErrorUtils.fromSupabaseError(activeError));\n      }\n\n      // Get total items count\n      const { count: totalItems, error: itemsError } = await this.supabase\n        .from('cart_items')\n        .select('*', { count: 'exact', head: true });\n\n      if (itemsError) {\n        return Result.error(ErrorUtils.fromSupabaseError(itemsError) as DatabaseError);\n      }\n\n      const averageItemsPerCart = (activeCarts || 0) > 0 ? (totalItems || 0) / (activeCarts || 1) : 0;\n\n      return Result.ok({\n        totalCarts: totalCarts || 0,\n        activeCarts: activeCarts || 0,\n        totalItems: totalItems || 0,\n        averageItemsPerCart: Math.round(averageItemsPerCart * 100) / 100,\n      });\n    } catch (error) {\n      logger.error('Exception in getCartStatistics', error);\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Required by base class but not used for carts (use specific methods instead)\n   */\n  mapFromDatabase(raw: any): Result<Cart, DatabaseError> {\n    return Result.error(new DatabaseError('Use mapCartWithItemsFromDatabase instead'));\n  }\n\n  mapToDatabase(entity: Partial<Cart>): any {\n    return {\n      id: entity.id,\n      user_id: entity.userId,\n      created_at: entity.createdAt?.toISOString(),\n      updated_at: entity.updatedAt?.toISOString(),\n    };\n  }\n\n  mapUpdateToDatabase(entity: Partial<Cart>): any {\n    const data: any = {};\n    if (entity.userId) data.user_id = entity.userId;\n    if (entity.updatedAt) data.updated_at = entity.updatedAt.toISOString();\n    return data;\n  }\n\n  /**\n   * Map cart with items from database record to domain entity\n   */\n  private mapCartWithItemsFromDatabase(record: CartWithItemsRecord): Result<Cart, DatabaseError> {\n    try {\n      const items: Array<{\n        id: string;\n        productId: string;\n        productName: string;\n        productPrice: number;\n        productStock: number;\n        productSlug?: string;\n        productImageUrl?: string;\n        productIsActive: boolean;\n        quantity: number;\n        addedAt: Date;\n      }> = [];\n\n      // Map cart items\n      for (const itemRecord of record.cart_items || []) {\n        if (!itemRecord.products) {\n          logger.warn('Cart item missing product data', { itemId: itemRecord.id });\n          continue;\n        }\n\n        items.push({\n          id: itemRecord.id,\n          productId: itemRecord.product_id,\n          productName: itemRecord.products.name,\n          productPrice: itemRecord.products.price,\n          productStock: itemRecord.products.stock,\n          productSlug: itemRecord.products.slug,\n          productImageUrl: itemRecord.products.image_url,\n          productIsActive: itemRecord.products.is_active,\n          quantity: itemRecord.quantity,\n          addedAt: new Date(itemRecord.added_at),\n        });\n      }\n\n      // Create cart using domain entity factory\n      const cartResult = Cart.fromPrimitives({\n        id: record.id,\n        userId: record.user_id,\n        items,\n        createdAt: new Date(record.created_at),\n        updatedAt: new Date(record.updated_at),\n      });\n\n      if (cartResult.isError()) {\n        return Result.error(new DatabaseError(cartResult.getError().message));\n      }\n\n      return Result.ok(cartResult.getValue());\n    } catch (error) {\n      logger.error('Failed to map cart from database', error, { cartId: record.id });\n      return Result.error(new DatabaseError('Failed to map cart from database', error));\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\repositories\\product.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":411,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":411,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12170,12173],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12170,12173],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":428,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":428,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12618,12621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12618,12621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":429,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":429,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12640,12643],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12640,12643],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Product Repository Implementation with Supabase\n * \n * Handles product data access with proper mapping between domain entities\n * and database records.\n */\n\nimport { SupabaseClient } from \"@supabase/supabase-js\";\nimport { Result } from \"@/lib/core/result\";\nimport { DatabaseError, ErrorUtils } from \"@/lib/core/errors\";\nimport { logger } from \"@/lib/core/logger\";\nimport { BaseSupabaseRepository } from \"./base-supabase.repository\";\nimport { Money, Quantity, ProductReference } from \"@/lib/domain/entities/cart.entity\";\nimport { ProductRepository } from \"@/lib/domain/services/cart.service\";\n\n/**\n * Database interface for products table\n */\ninterface ProductRecord {\n  id: string;\n  name: string;\n  price: number;\n  stock: number;\n  slug?: string;\n  image_url?: string;\n  is_active: boolean;\n  created_at: string;\n  updated_at: string;\n  // Translation fields (assuming single locale for simplicity)\n  description_short?: string;\n  description_long?: string;\n}\n\n/**\n * Product with translations record\n */\ninterface ProductWithTranslationsRecord extends ProductRecord {\n  product_translations: Array<{\n    locale: string;\n    name: string;\n    description_short?: string;\n    description_long?: string;\n  }>;\n}\n\n/**\n * Supabase Product Repository implementation\n */\nexport class SupabaseProductRepository extends BaseSupabaseRepository<ProductReference, Partial<ProductReference>, Partial<ProductReference>> implements ProductRepository {\n  \n  constructor(supabase: SupabaseClient) {\n    super(supabase, 'products');\n  }\n\n  /**\n   * Find product by ID with translations\n   */\n  async findById(productId: string): Promise<Result<ProductReference | null, Error>> {\n    try {\n      const { data, error } = await this.supabase\n        .from('products')\n        .select(`\n          id,\n          name,\n          price,\n          stock,\n          slug,\n          image_url,\n          is_active,\n          created_at,\n          updated_at,\n          description_short,\n          description_long,\n          product_translations (\n            locale,\n            name,\n            description_short,\n            description_long\n          )\n        `)\n        .eq('id', productId)\n        .eq('is_active', true) // Only return active products\n        .maybeSingle();\n\n      if (error) {\n        logger.error('Failed to find product by ID', error, { productId });\n        return Result.error(ErrorUtils.fromSupabaseError(error));\n      }\n\n      if (!data) {\n        return Result.ok(null);\n      }\n\n      const mappingResult = this.mapProductWithTranslationsFromDatabase(data as ProductWithTranslationsRecord);\n      if (mappingResult.isError()) {\n        return Result.error(mappingResult.getError());\n      }\n\n      return Result.ok(mappingResult.getValue());\n    } catch (error) {\n      logger.error('Exception in findById', error, { productId });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Find multiple products by IDs\n   */\n  async findByIds(productIds: string[]): Promise<Result<ProductReference[], Error>> {\n    try {\n      if (productIds.length === 0) {\n        return Result.ok([]);\n      }\n\n      const { data, error } = await this.supabase\n        .from('products')\n        .select(`\n          id,\n          name,\n          price,\n          stock,\n          slug,\n          image_url,\n          is_active,\n          created_at,\n          updated_at,\n          description_short,\n          description_long,\n          product_translations (\n            locale,\n            name,\n            description_short,\n            description_long\n          )\n        `)\n        .in('id', productIds)\n        .eq('is_active', true);\n\n      if (error) {\n        logger.error('Failed to find products by IDs', error, { productIds });\n        return Result.error(ErrorUtils.fromSupabaseError(error));\n      }\n\n      if (!data) {\n        return Result.ok([]);\n      }\n\n      // Map all products\n      const products: ProductReference[] = [];\n      for (const productData of data as ProductWithTranslationsRecord[]) {\n        const mappingResult = this.mapProductWithTranslationsFromDatabase(productData);\n        if (mappingResult.isError()) {\n          logger.warn('Failed to map product in findByIds', mappingResult.getError(), { productId: productData.id });\n          continue;\n        }\n        products.push(mappingResult.getValue());\n      }\n\n      return Result.ok(products);\n    } catch (error) {\n      logger.error('Exception in findByIds', error, { productIds });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Update product stock\n   */\n  async updateStock(productId: string, newStock: number): Promise<Result<void, Error>> {\n    try {\n      if (newStock < 0) {\n        return Result.error(new DatabaseError('Stock cannot be negative'));\n      }\n\n      const { error } = await this.supabase\n        .from('products')\n        .update({ \n          stock: newStock,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', productId);\n\n      if (error) {\n        logger.error('Failed to update product stock', error, { productId, newStock });\n        return Result.error(ErrorUtils.fromSupabaseError(error));\n      }\n\n      return Result.ok(undefined);\n    } catch (error) {\n      logger.error('Exception in updateStock', error, { productId, newStock });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Find products with low stock (for inventory management)\n   */\n  async findLowStockProducts(threshold: number = 10): Promise<Result<ProductReference[], Error>> {\n    try {\n      const { data, error } = await this.supabase\n        .from('products')\n        .select(`\n          id,\n          name,\n          price,\n          stock,\n          slug,\n          image_url,\n          is_active,\n          created_at,\n          updated_at,\n          description_short,\n          description_long\n        `)\n        .eq('is_active', true)\n        .lte('stock', threshold)\n        .order('stock', { ascending: true });\n\n      if (error) {\n        logger.error('Failed to find low stock products', error, { threshold });\n        return Result.error(ErrorUtils.fromSupabaseError(error));\n      }\n\n      if (!data) {\n        return Result.ok([]);\n      }\n\n      // Map products\n      const products: ProductReference[] = [];\n      for (const productData of data as ProductRecord[]) {\n        const mappingResult = this.mapFromDatabase(productData);\n        if (mappingResult.isError()) {\n          logger.warn('Failed to map product in findLowStockProducts', mappingResult.getError(), { productId: productData.id });\n          continue;\n        }\n        products.push(mappingResult.getValue());\n      }\n\n      return Result.ok(products);\n    } catch (error) {\n      logger.error('Exception in findLowStockProducts', error, { threshold });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Reserve stock for cart items (atomic operation)\n   */\n  async reserveStock(\n    reservations: Array<{ productId: string; quantity: number }>\n  ): Promise<Result<void, Error>> {\n    try {\n      // Use RPC function for atomic stock reservation\n      const { error } = await this.supabase.rpc('reserve_product_stock', {\n        reservations: reservations.map(r => ({\n          product_id: r.productId,\n          quantity: r.quantity\n        }))\n      });\n\n      if (error) {\n        logger.error('Failed to reserve stock', error, { reservations });\n        return Result.error(ErrorUtils.fromSupabaseError(error));\n      }\n\n      return Result.ok(undefined);\n    } catch (error) {\n      logger.error('Exception in reserveStock', error, { reservations });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Release reserved stock (for cart cleanup or order cancellation)\n   */\n  async releaseStock(\n    releases: Array<{ productId: string; quantity: number }>\n  ): Promise<Result<void, Error>> {\n    try {\n      // Use RPC function for atomic stock release\n      const { error } = await this.supabase.rpc('release_product_stock', {\n        releases: releases.map(r => ({\n          product_id: r.productId,\n          quantity: r.quantity\n        }))\n      });\n\n      if (error) {\n        logger.error('Failed to release stock', error, { releases });\n        return Result.error(ErrorUtils.fromSupabaseError(error));\n      }\n\n      return Result.ok(undefined);\n    } catch (error) {\n      logger.error('Exception in releaseStock', error, { releases });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Search products by name or description\n   */\n  async searchProducts(\n    query: string,\n    options: {\n      limit?: number;\n      offset?: number;\n      categoryId?: string;\n      priceMin?: number;\n      priceMax?: number;\n    } = {}\n  ): Promise<Result<{ products: ProductReference[]; total: number }, Error>> {\n    try {\n      let supabaseQuery = this.supabase\n        .from('products')\n        .select(`\n          id,\n          name,\n          price,\n          stock,\n          slug,\n          image_url,\n          is_active,\n          created_at,\n          updated_at,\n          description_short,\n          description_long\n        `, { count: 'exact' })\n        .eq('is_active', true)\n        .or(`name.ilike.%${query}%,description_short.ilike.%${query}%,description_long.ilike.%${query}%`);\n\n      // Apply filters\n      if (options.categoryId) {\n        supabaseQuery = supabaseQuery.eq('category_id', options.categoryId);\n      }\n      if (options.priceMin !== undefined) {\n        supabaseQuery = supabaseQuery.gte('price', options.priceMin);\n      }\n      if (options.priceMax !== undefined) {\n        supabaseQuery = supabaseQuery.lte('price', options.priceMax);\n      }\n\n      // Apply pagination\n      if (options.limit) {\n        supabaseQuery = supabaseQuery.limit(options.limit);\n      }\n      if (options.offset) {\n        supabaseQuery = supabaseQuery.range(\n          options.offset,\n          options.offset + (options.limit || 20) - 1\n        );\n      }\n\n      // Order by relevance (name matches first, then description matches)\n      supabaseQuery = supabaseQuery.order('name');\n\n      const { data, error, count } = await supabaseQuery;\n\n      if (error) {\n        logger.error('Failed to search products', error, { query, options });\n        return Result.error(ErrorUtils.fromSupabaseError(error));\n      }\n\n      if (!data) {\n        return Result.ok({ products: [], total: count || 0 });\n      }\n\n      // Map products\n      const products: ProductReference[] = [];\n      for (const productData of data as ProductRecord[]) {\n        const mappingResult = this.mapFromDatabase(productData);\n        if (mappingResult.isError()) {\n          logger.warn('Failed to map product in searchProducts', mappingResult.getError(), { productId: productData.id });\n          continue;\n        }\n        products.push(mappingResult.getValue());\n      }\n\n      return Result.ok({ products, total: count || 0 });\n    } catch (error) {\n      logger.error('Exception in searchProducts', error, { query, options });\n      return Result.error(new DatabaseError('Database operation failed', error));\n    }\n  }\n\n  /**\n   * Map product from database record to domain entity\n   */\n  mapFromDatabase(record: ProductRecord): Result<ProductReference, DatabaseError> {\n    try {\n      const productReference: ProductReference = {\n        id: record.id,\n        name: record.name,\n        price: new Money(record.price),\n        stock: new Quantity(record.stock),\n        slug: record.slug,\n        imageUrl: record.image_url,\n        isActive: record.is_active,\n      };\n\n      return Result.ok(productReference);\n    } catch (error) {\n      logger.error('Failed to map product from database', error, { productId: record.id });\n      return Result.error(new DatabaseError('Failed to map product from database', error));\n    }\n  }\n\n  /**\n   * Map product to database record\n   */\n  mapToDatabase(entity: Partial<ProductReference>): any {\n    return {\n      id: entity.id,\n      name: entity.name,\n      price: entity.price?.amount,\n      stock: entity.stock?.value,\n      slug: entity.slug,\n      image_url: entity.imageUrl,\n      is_active: entity.isActive ?? true,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Map product update to database record\n   */\n  mapUpdateToDatabase(entity: Partial<ProductReference>): any {\n    const data: any = {\n      updated_at: new Date().toISOString(),\n    };\n\n    if (entity.name) data.name = entity.name;\n    if (entity.price) data.price = entity.price.amount;\n    if (entity.stock) data.stock = entity.stock.value;\n    if (entity.slug) data.slug = entity.slug;\n    if (entity.imageUrl !== undefined) data.image_url = entity.imageUrl;\n    if (entity.isActive !== undefined) data.is_active = entity.isActive;\n\n    return data;\n  }\n\n  /**\n   * Map product with translations from database record to domain entity\n   */\n  private mapProductWithTranslationsFromDatabase(\n    record: ProductWithTranslationsRecord\n  ): Result<ProductReference, DatabaseError> {\n    try {\n      // For now, we'll use the default language or first translation\n      // In a full implementation, you'd handle locale-specific mapping\n      let productName = record.name;\n      \n      if (record.product_translations && record.product_translations.length > 0) {\n        // Use French translation if available, otherwise first available\n        const frTranslation = record.product_translations.find(t => t.locale === 'fr');\n        const translation = frTranslation || record.product_translations[0];\n        if (translation.name) {\n          productName = translation.name;\n        }\n      }\n\n      const productReference: ProductReference = {\n        id: record.id,\n        name: productName,\n        price: new Money(record.price),\n        stock: new Quantity(record.stock),\n        slug: record.slug,\n        imageUrl: record.image_url,\n        isActive: record.is_active,\n      };\n\n      return Result.ok(productReference);\n    } catch (error) {\n      logger.error('Failed to map product with translations from database', error, { productId: record.id });\n      return Result.error(new DatabaseError('Failed to map product from database', error));\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\infrastructure\\repositories\\user.supabase.repository.ts","messages":[{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\+.","line":470,"column":36,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":470,"endColumn":37,"suggestions":[{"messageId":"removeEscape","fix":{"range":[16880,16881],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[16880,16880],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\(.","line":470,"column":48,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":470,"endColumn":49,"suggestions":[{"messageId":"removeEscape","fix":{"range":[16892,16893],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[16892,16892],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\).","line":470,"column":50,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":470,"endColumn":51,"suggestions":[{"messageId":"removeEscape","fix":{"range":[16894,16895],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[16894,16894],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * User Repository - Implémentation Supabase\n * \n * Implémente IUserRepository en utilisant Supabase comme source de données.\n * Gère les utilisateurs, profils, et opérations admin avec RLS compliance.\n */\n\nimport { createSupabaseServerClient } from '@/lib/supabase/server';\nimport { createSupabaseAdminClient } from '@/lib/supabase/server-admin';\nimport { Result } from '@/lib/core/result';\nimport { DatabaseError, ValidationError, NotFoundError } from '@/lib/core/errors';\nimport { LogUtils } from '@/lib/core/logger';\nimport type { \n  IUserRepository,\n  User,\n  Profile, \n  UserWithProfile,\n  CreateProfileData,\n  UpdateProfileData,\n  AdminUserData\n} from '@/lib/domain/interfaces/user.repository.interface';\nimport type { SupabaseClient } from '@supabase/supabase-js';\n\nexport class UserSupabaseRepository implements IUserRepository {\n  private adminClient: SupabaseClient;\n\n  constructor() {\n    this.adminClient = createSupabaseAdminClient();\n  }\n\n  /**\n   * Helper pour gérer les erreurs\n   */\n  private handleError(error: unknown): Result<never, Error> {\n    if (error instanceof Error) {\n      return Result.failure(new DatabaseError(error.message));\n    }\n    return Result.failure(new DatabaseError('Unknown error occurred'));\n  }\n\n  // === Opérations de base utilisateur ===\n\n  async findByEmail(email: string): Promise<Result<User | null, Error>> {\n    const context = LogUtils.createUserActionContext('system', 'findByEmail');\n    LogUtils.logOperationStart('findByEmail', context);\n\n    try {\n      const { data, error } = await this.adminClient.auth.admin.listUsers({\n        page: 1,\n        perPage: 1\n      });\n\n      if (error) {\n        LogUtils.logOperationError('findByEmail', error, context);\n        return Result.failure(new DatabaseError(`Error finding user by email: ${error.message}`));\n      }\n\n      const user = data.users.find(u => u.email === email);\n      if (!user) {\n        LogUtils.logOperationSuccess('findByEmail', { ...context, found: false });\n        return Result.success(null);\n      }\n\n      const mappedUser: User = {\n        id: user.id,\n        email: user.email || '',\n        created_at: user.created_at,\n        updated_at: user.updated_at,\n        email_confirmed_at: user.email_confirmed_at,\n        last_sign_in_at: user.last_sign_in_at,\n      };\n\n      LogUtils.logOperationSuccess('findByEmail', { ...context, found: true, userId: user.id });\n      return Result.success(mappedUser);\n    } catch (error) {\n      LogUtils.logOperationError('findByEmail', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async findByIdWithProfile(id: string): Promise<Result<UserWithProfile | null, Error>> {\n    const context = LogUtils.createOperationContext('findByIdWithProfile', 'user-repository');\n    LogUtils.logOperationStart('findByIdWithProfile', { ...context, userId: id });\n\n    try {\n      // Récupérer l'utilisateur via auth admin\n      const { data: userData, error: userError } = await this.adminClient.auth.admin.getUserById(id);\n\n      if (userError) {\n        LogUtils.logOperationError('findByIdWithProfile', userError, context);\n        return Result.failure(new DatabaseError(`Error finding user: ${userError.message}`));\n      }\n\n      if (!userData.user) {\n        LogUtils.logOperationSuccess('findByIdWithProfile', { ...context, found: false });\n        return Result.success(null);\n      }\n\n      const user: User = {\n        id: userData.user.id,\n        email: userData.user.email || '',\n        created_at: userData.user.created_at,\n        updated_at: userData.user.updated_at,\n        email_confirmed_at: userData.user.email_confirmed_at,\n        last_sign_in_at: userData.user.last_sign_in_at,\n      };\n\n      // Récupérer le profil\n      const client = await createSupabaseServerClient();\n      const { data: profileData, error: profileError } = await client\n        .from('profiles')\n        .select('*')\n        .eq('user_id', id)\n        .single();\n\n      if (profileError && profileError.code !== 'PGRST116') {\n        LogUtils.logOperationError('findByIdWithProfile', profileError, context);\n        return Result.failure(new DatabaseError(`Error finding profile: ${profileError.message}`));\n      }\n\n      const userWithProfile: UserWithProfile = {\n        ...user,\n        profile: profileData || undefined\n      };\n\n      LogUtils.logOperationSuccess('findByIdWithProfile', { \n        ...context, \n        found: true, \n        hasProfile: !!profileData \n      });\n      return Result.success(userWithProfile);\n    } catch (error) {\n      LogUtils.logOperationError('findByIdWithProfile', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async findAllWithProfiles(page = 1, limit = 20): Promise<Result<{ users: AdminUserData[]; total: number }, Error>> {\n    const context = LogUtils.createOperationContext('findAllWithProfiles', 'user-repository');\n    LogUtils.logOperationStart('findAllWithProfiles', { ...context, page, limit });\n\n    try {\n      // Récupérer les utilisateurs avec pagination\n      const { data: authData, error: authError } = await this.adminClient.auth.admin.listUsers({\n        page,\n        perPage: limit\n      });\n\n      if (authError) {\n        LogUtils.logOperationError('findAllWithProfiles', authError, context);\n        return Result.failure(new DatabaseError(`Error listing users: ${authError.message}`));\n      }\n\n      const userIds = authData.users.map(u => u.id);\n      \n      // Récupérer les profils\n      const client = await createSupabaseServerClient();\n      const { data: profilesData, error: profilesError } = await client\n        .from('profiles')\n        .select('*')\n        .in('user_id', userIds);\n\n      if (profilesError) {\n        LogUtils.logOperationError('findAllWithProfiles', profilesError, context);\n        return Result.failure(new DatabaseError(`Error finding profiles: ${profilesError.message}`));\n      }\n\n      // Créer un map des profils par user_id\n      const profilesMap = new Map(profilesData?.map(p => [p.user_id, p]) || []);\n\n      // Combiner les données\n      const adminUsers: AdminUserData[] = authData.users.map(user => ({\n        id: user.id,\n        email: user.email || '',\n        created_at: user.created_at,\n        last_sign_in_at: user.last_sign_in_at,\n        profile: profilesMap.get(user.id) || {\n          id: '',\n          user_id: user.id,\n          first_name: null,\n          last_name: null,\n          phone: null,\n          avatar_url: null,\n          is_admin: false,\n          marketing_consent: false,\n          created_at: user.created_at,\n          updated_at: user.updated_at,\n        }\n      }));\n\n      LogUtils.logOperationSuccess('findAllWithProfiles', { \n        ...context, \n        usersCount: adminUsers.length,\n        total: authData.total || adminUsers.length\n      });\n\n      return Result.success({ \n        users: adminUsers, \n        total: authData.total || adminUsers.length \n      });\n    } catch (error) {\n      LogUtils.logOperationError('findAllWithProfiles', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations profil ===\n\n  async createProfile(userId: string, profileData: CreateProfileData): Promise<Result<Profile, Error>> {\n    const context = LogUtils.createUserActionContext('system', 'getUserStats');\n    LogUtils.logOperationStart('createProfile', { ...context, userId });\n\n    try {\n      const client = await createSupabaseServerClient();\n      const { data, error } = await client\n        .from('profiles')\n        .insert({\n          user_id: userId,\n          first_name: profileData.first_name || null,\n          last_name: profileData.last_name || null,\n          phone: profileData.phone || null,\n          avatar_url: profileData.avatar_url || null,\n          marketing_consent: profileData.marketing_consent || false,\n          is_admin: false, // Toujours false par défaut\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        })\n        .select()\n        .single();\n\n      if (error) {\n        LogUtils.logOperationError('createProfile', error, context);\n        return Result.failure(new DatabaseError(`Error creating profile: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('createProfile', { ...context, profileId: data.id });\n      return Result.success(data);\n    } catch (error) {\n      LogUtils.logOperationError('createProfile', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async updateProfile(userId: string, profileData: UpdateProfileData): Promise<Result<Profile, Error>> {\n    const context = LogUtils.createUserActionContext(userId, 'updateUserProfile');\n    LogUtils.logOperationStart('updateProfile', { ...context, userId });\n\n    try {\n      const client = await createSupabaseServerClient();\n      const { data, error } = await client\n        .from('profiles')\n        .update({\n          ...profileData,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('user_id', userId)\n        .select()\n        .single();\n\n      if (error) {\n        LogUtils.logOperationError('updateProfile', error, context);\n        if (error.code === 'PGRST116') {\n          return Result.failure(new NotFoundError(`Profile not found for user ${userId}`));\n        }\n        return Result.failure(new DatabaseError(`Error updating profile: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('updateProfile', { ...context, profileId: data.id });\n      return Result.success(data);\n    } catch (error) {\n      LogUtils.logOperationError('updateProfile', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async findProfileByUserId(userId: string): Promise<Result<Profile | null, Error>> {\n    const context = LogUtils.createUserActionContext('system', 'findProfileByUserId');\n    LogUtils.logOperationStart('findProfileByUserId', { ...context, userId });\n\n    try {\n      const client = await createSupabaseServerClient();\n      const { data, error } = await client\n        .from('profiles')\n        .select('*')\n        .eq('user_id', userId)\n        .single();\n\n      if (error && error.code !== 'PGRST116') {\n        LogUtils.logOperationError('findProfileByUserId', error, context);\n        return Result.failure(new DatabaseError(`Error finding profile: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('findProfileByUserId', { \n        ...context, \n        found: !!data \n      });\n      return Result.success(data);\n    } catch (error) {\n      LogUtils.logOperationError('findProfileByUserId', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations admin ===\n\n  async checkAdminRole(userId: string): Promise<Result<boolean, Error>> {\n    const context = LogUtils.createUserActionContext('system', 'checkAdminRole');\n    LogUtils.logOperationStart('checkAdminRole', { ...context, userId });\n\n    try {\n      const client = await createSupabaseServerClient();\n      const { data, error } = await client\n        .from('profiles')\n        .select('is_admin')\n        .eq('user_id', userId)\n        .single();\n\n      if (error && error.code !== 'PGRST116') {\n        LogUtils.logOperationError('checkAdminRole', error, context);\n        return Result.failure(new DatabaseError(`Error checking admin role: ${error.message}`));\n      }\n\n      const isAdmin = data?.is_admin || false;\n      LogUtils.logOperationSuccess('checkAdminRole', { ...context, isAdmin });\n      return Result.success(isAdmin);\n    } catch (error) {\n      LogUtils.logOperationError('checkAdminRole', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async updateAdminStatus(userId: string, isAdmin: boolean): Promise<Result<Profile, Error>> {\n    const context = LogUtils.createUserActionContext('system', 'updateAdminStatus');\n    LogUtils.logOperationStart('updateAdminStatus', { ...context, userId, isAdmin });\n\n    try {\n      const client = await createSupabaseServerClient();\n      const { data, error } = await client\n        .from('profiles')\n        .update({\n          is_admin: isAdmin,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('user_id', userId)\n        .select()\n        .single();\n\n      if (error) {\n        LogUtils.logOperationError('updateAdminStatus', error, context);\n        if (error.code === 'PGRST116') {\n          return Result.failure(new NotFoundError(`Profile not found for user ${userId}`));\n        }\n        return Result.failure(new DatabaseError(`Error updating admin status: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('updateAdminStatus', { ...context, profileId: data.id });\n      return Result.success(data);\n    } catch (error) {\n      LogUtils.logOperationError('updateAdminStatus', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async deleteUser(userId: string): Promise<Result<void, Error>> {\n    const context = LogUtils.createUserActionContext(userId, 'deleteUser');\n    LogUtils.logOperationStart('deleteUser', { ...context, userId });\n\n    try {\n      // Note: Dans une vraie implémentation, on ferait un soft delete\n      // Pour l'instant, on marque juste le profil comme supprimé\n      const client = await createSupabaseServerClient();\n      const { error } = await client\n        .from('profiles')\n        .update({\n          updated_at: new Date().toISOString(),\n          // On pourrait ajouter un champ deleted_at si nécessaire\n        })\n        .eq('user_id', userId);\n\n      if (error) {\n        LogUtils.logOperationError('deleteUser', error, context);\n        return Result.failure(new DatabaseError(`Error deleting user: ${error.message}`));\n      }\n\n      LogUtils.logOperationSuccess('deleteUser', context);\n      return Result.success(undefined);\n    } catch (error) {\n      LogUtils.logOperationError('deleteUser', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations de recherche ===\n\n  async searchUsers(searchTerm: string, page = 1, limit = 20): Promise<Result<{ users: AdminUserData[]; total: number }, Error>> {\n    // Implémentation simplifiée pour maintenant\n    // Dans une vraie implémentation, on ferait une recherche full-text\n    return this.findAllWithProfiles(page, limit);\n  }\n\n  async findAdminUsers(): Promise<Result<AdminUserData[], Error>> {\n    const context = LogUtils.createUserActionContext('system', 'findAdminUsers');\n    LogUtils.logOperationStart('findAdminUsers', context);\n\n    try {\n      const client = await createSupabaseServerClient();\n      const { data: profilesData, error: profilesError } = await client\n        .from('profiles')\n        .select('*')\n        .eq('is_admin', true);\n\n      if (profilesError) {\n        LogUtils.logOperationError('findAdminUsers', profilesError, context);\n        return Result.failure(new DatabaseError(`Error finding admin profiles: ${profilesError.message}`));\n      }\n\n      const adminUserIds = profilesData?.map(p => p.user_id) || [];\n      if (adminUserIds.length === 0) {\n        LogUtils.logOperationSuccess('findAdminUsers', { ...context, adminCount: 0 });\n        return Result.success([]);\n      }\n\n      // Récupérer les données auth pour ces utilisateurs\n      const { data: authData, error: authError } = await this.adminClient.auth.admin.listUsers();\n\n      if (authError) {\n        LogUtils.logOperationError('findAdminUsers', authError, context);\n        return Result.failure(new DatabaseError(`Error listing admin users: ${authError.message}`));\n      }\n\n      const adminUsers = authData.users\n        .filter(user => adminUserIds.includes(user.id))\n        .map(user => {\n          const profile = profilesData?.find(p => p.user_id === user.id);\n          return {\n            id: user.id,\n            email: user.email || '',\n            created_at: user.created_at,\n            last_sign_in_at: user.last_sign_in_at,\n            profile: profile!\n          };\n        });\n\n      LogUtils.logOperationSuccess('findAdminUsers', { \n        ...context, \n        adminCount: adminUsers.length \n      });\n      return Result.success(adminUsers);\n    } catch (error) {\n      LogUtils.logOperationError('findAdminUsers', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  // === Opérations de validation ===\n\n  async validateProfileData(profileData: CreateProfileData | UpdateProfileData): Promise<Result<void, Error>> {\n    const context = LogUtils.createUserActionContext('system', 'validateProfileData');\n\n    try {\n      // Validation basique\n      if (profileData.first_name && profileData.first_name.length > 50) {\n        return Result.failure(new ValidationError('First name too long (max 50 characters)'));\n      }\n\n      if (profileData.last_name && profileData.last_name.length > 50) {\n        return Result.failure(new ValidationError('Last name too long (max 50 characters)'));\n      }\n\n      if (profileData.phone && !/^[\\+]?[0-9\\-\\s\\(\\)]+$/.test(profileData.phone)) {\n        return Result.failure(new ValidationError('Invalid phone number format'));\n      }\n\n      LogUtils.logOperationSuccess('validateProfileData', context);\n      return Result.success(undefined);\n    } catch (error) {\n      LogUtils.logOperationError('validateProfileData', error, context);\n      return this.handleError(error);\n    }\n  }\n\n  async isEmailTaken(email: string, excludeUserId?: string): Promise<Result<boolean, Error>> {\n    const context = LogUtils.createUserActionContext('system', 'searchUsers');\n    LogUtils.logOperationStart('isEmailTaken', { ...context, email, excludeUserId });\n\n    try {\n      const { data, error } = await this.adminClient.auth.admin.listUsers();\n\n      if (error) {\n        LogUtils.logOperationError('isEmailTaken', error, context);\n        return Result.failure(new DatabaseError(`Error checking email: ${error.message}`));\n      }\n\n      const existingUser = data.users.find(u => \n        u.email === email && u.id !== excludeUserId\n      );\n\n      const isTaken = !!existingUser;\n      LogUtils.logOperationSuccess('isEmailTaken', { ...context, isTaken });\n      return Result.success(isTaken);\n    } catch (error) {\n      LogUtils.logOperationError('isEmailTaken', error, context);\n      return this.handleError(error);\n    }\n  }\n\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\market-utils.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getAllMarketInstances' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Market Utilities\n * \n * Utilities for working with market data. This file has been updated to use\n * database data instead of JSON files, while maintaining backward compatibility\n * with the existing API.\n */\n\nimport { MarketInfo } from \"@/types/market\";\nimport { \n  getAllMarketInstances, \n  getUpcomingMarkets, \n  getNextUpcomingMarket as getNextUpcomingMarketFromDb,\n  getAllMarketsSorted as getAllMarketsSortedFromDb\n} from \"@/lib/markets/queries\";\n\n// Legacy imports for backward compatibility (will be removed after migration)\nimport recurringMarketsData from \"@/data/markets.json\";\nimport { RecurringMarketInfo } from \"@/types/market\";\n\n/**\n * Legacy function for generating market instances from JSON data\n * @deprecated Use database queries instead\n */\nfunction generateMarketInstancesLegacy(): MarketInfo[] {\n  const recurringMarkets: RecurringMarketInfo[] = recurringMarketsData;\n  const allInstances: MarketInfo[] = [];\n\n  recurringMarkets.forEach((recurringMarket) => {\n    const startDate = new Date(recurringMarket.startDate);\n    const endDate = new Date(recurringMarket.endDate);\n    const dayOfWeek = recurringMarket.dayOfWeek;\n\n    const currentDate = new Date(startDate);\n\n    while (currentDate <= endDate) {\n      if (currentDate.getUTCDay() === dayOfWeek) {\n        const isoDate = currentDate.toISOString().split(\"T\")[0];\n        allInstances.push({\n          id: `${recurringMarket.id}-${isoDate}`,\n          name: recurringMarket.name,\n          date: isoDate,\n          startTime: recurringMarket.startTime,\n          endTime: recurringMarket.endTime,\n          city: recurringMarket.city,\n          address: recurringMarket.address,\n          description: recurringMarket.description,\n          gpsLink: recurringMarket.gpsLink,\n          heroImage: recurringMarket.heroImage,\n          image: recurringMarket.image,\n        });\n      }\n      currentDate.setUTCDate(currentDate.getUTCDate() + 1);\n    }\n  });\n\n  return allInstances;\n}\n\n// Fallback to legacy data if database is not available\nconst legacyMarketInstances = generateMarketInstancesLegacy();\n\n/**\n * Formats a date string (YYYY-MM-DD) into a more readable format.\n */\nexport function formatDate(dateString: string, locale: string = \"fr-FR\"): string {\n  const date = new Date(dateString);\n  return date.toLocaleDateString(locale, {\n    weekday: \"long\",\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\",\n    timeZone: \"UTC\", // Ensure consistent date interpretation\n  });\n}\n\n/**\n * Retrieves the next upcoming market.\n * Now uses database data with fallback to legacy JSON data.\n * All date comparisons are done in UTC to ensure consistency.\n */\nexport async function getNextUpcomingMarket(): Promise<MarketInfo | null> {\n  try {\n    // Try to get from database first\n    return await getNextUpcomingMarketFromDb();\n  } catch (error) {\n    console.warn(\"Failed to fetch market from database, falling back to legacy data:\", error);\n    \n    // Fallback to legacy logic\n    const now = new Date();\n    const upcomingMarkets = legacyMarketInstances\n      .filter((market) => {\n        const marketDateString = market.date;\n        let marketEndDateTime;\n\n        if (market.endTime === \"00:00\") {\n          const tempDate = new Date(marketDateString + \"T00:00:00Z\");\n          tempDate.setUTCDate(tempDate.getUTCDate() + 1);\n          marketEndDateTime = tempDate;\n        } else {\n          marketEndDateTime = new Date(`${marketDateString}T${market.endTime}:00Z`);\n        }\n        return marketEndDateTime > now;\n      })\n      .sort((a, b) => {\n        const aStartDateTime = new Date(`${a.date}T${a.startTime}:00Z`);\n        const bStartDateTime = new Date(`${b.date}T${b.startTime}:00Z`);\n        return aStartDateTime.getTime() - bStartDateTime.getTime();\n      });\n\n    return upcomingMarkets.length > 0 ? upcomingMarkets[0] : null;\n  }\n}\n\n/**\n * Retrieves all upcoming markets, sorted by date.\n * Now uses database data with fallback to legacy JSON data.\n * All date comparisons are done in UTC to ensure consistency.\n */\nexport async function getAllUpcomingMarkets(): Promise<MarketInfo[]> {\n  try {\n    // Try to get from database first\n    return await getUpcomingMarkets();\n  } catch (error) {\n    console.warn(\"Failed to fetch markets from database, falling back to legacy data:\", error);\n    \n    // Fallback to legacy logic\n    const now = new Date();\n    return legacyMarketInstances\n      .filter((market) => {\n        const marketDateString = market.date;\n        let marketEndDateTime;\n\n        if (market.endTime === \"00:00\") {\n          const tempDate = new Date(marketDateString + \"T00:00:00Z\");\n          tempDate.setUTCDate(tempDate.getUTCDate() + 1);\n          marketEndDateTime = tempDate;\n        } else {\n          marketEndDateTime = new Date(`${marketDateString}T${market.endTime}:00Z`);\n        }\n        return marketEndDateTime > now;\n      })\n      .sort((a, b) => {\n        const aStartDateTime = new Date(`${a.date}T${a.startTime}:00Z`);\n        const bStartDateTime = new Date(`${b.date}T${b.startTime}:00Z`);\n        return aStartDateTime.getTime() - bStartDateTime.getTime();\n      });\n  }\n}\n\n/**\n * Retrieves all market instances, sorted by date (most recent first).\n * Now uses database data with fallback to legacy JSON data.\n */\nexport async function getAllMarketsSorted(): Promise<MarketInfo[]> {\n  try {\n    // Try to get from database first\n    return await getAllMarketsSortedFromDb();\n  } catch (error) {\n    console.warn(\"Failed to fetch markets from database, falling back to legacy data:\", error);\n    \n    // Fallback to legacy logic\n    return [...legacyMarketInstances].sort(\n      (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\microservices\\api-gateway\\gateway.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'routeKey' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":199,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":199,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * API Gateway for Microservices Architecture\n * \n * Provides centralized routing, authentication, rate limiting,\n * and request/response transformation for microservices.\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { Result } from '@/lib/core/result';\nimport { logger } from '@/lib/core/logger';\n\n/**\n * Service route configuration\n */\nexport interface ServiceRoute {\n  readonly path: string;\n  readonly service: string;\n  readonly target: string;\n  readonly methods: string[];\n  readonly requiresAuth: boolean;\n  readonly rateLimit?: {\n    requests: number;\n    window: number; // milliseconds\n  };\n  readonly timeout?: number;\n  readonly retries?: number;\n  readonly circuitBreaker?: {\n    failureThreshold: number;\n    recoveryTimeMs: number;\n  };\n}\n\n/**\n * API Gateway configuration\n */\nexport interface ApiGatewayConfig {\n  readonly services: Record<string, ServiceRoute[]>;\n  readonly defaultTimeout: number;\n  readonly defaultRetries: number;\n  readonly enableLogging: boolean;\n  readonly enableMetrics: boolean;\n}\n\n/**\n * Request context for processing\n */\ninterface RequestContext {\n  requestId: string;\n  userId?: string;\n  service: string;\n  route: ServiceRoute;\n  startTime: number;\n}\n\n/**\n * Circuit breaker state\n */\ninterface CircuitBreakerState {\n  failures: number;\n  lastFailureTime: number;\n  state: 'closed' | 'open' | 'half-open';\n}\n\n/**\n * Rate limiter state\n */\ninterface RateLimiterState {\n  requests: number;\n  windowStart: number;\n}\n\n/**\n * API Gateway implementation\n */\nexport class ApiGateway {\n  private readonly routeMap = new Map<string, ServiceRoute>();\n  private readonly circuitBreakers = new Map<string, CircuitBreakerState>();\n  private readonly rateLimiters = new Map<string, RateLimiterState>();\n\n  constructor(private readonly config: ApiGatewayConfig) {\n    this.initializeRoutes();\n  }\n\n  /**\n   * Initialize route mappings from configuration\n   */\n  private initializeRoutes(): void {\n    for (const [serviceName, routes] of Object.entries(this.config.services)) {\n      for (const route of routes) {\n        const key = this.createRouteKey(route.path, serviceName);\n        this.routeMap.set(key, route);\n        \n        // Initialize circuit breaker\n        if (route.circuitBreaker) {\n          this.circuitBreakers.set(key, {\n            failures: 0,\n            lastFailureTime: 0,\n            state: 'closed'\n          });\n        }\n      }\n    }\n\n    logger.info('ApiGateway.initializeRoutes', {\n      totalRoutes: this.routeMap.size,\n      services: Object.keys(this.config.services),\n    });\n  }\n\n  /**\n   * Process incoming request through the gateway\n   */\n  async processRequest(request: NextRequest): Promise<NextResponse> {\n    const requestId = this.generateRequestId();\n    const startTime = Date.now();\n\n    try {\n      // Find matching route\n      const routeResult = this.findMatchingRoute(request);\n      if (routeResult.isError()) {\n        return this.createErrorResponse(404, 'Route not found', requestId);\n      }\n\n      const route = routeResult.getValue();\n      const context: RequestContext = {\n        requestId,\n        service: route.service,\n        route,\n        startTime,\n      };\n\n      // Extract user context if available\n      context.userId = this.extractUserId(request);\n\n      logger.info('ApiGateway.processRequest', {\n        requestId,\n        method: request.method,\n        path: request.nextUrl.pathname,\n        service: route.service,\n        userId: context.userId,\n      });\n\n      // Validate HTTP method\n      if (!route.methods.includes(request.method)) {\n        return this.createErrorResponse(405, 'Method not allowed', requestId);\n      }\n\n      // Check authentication\n      if (route.requiresAuth) {\n        const authResult = await this.validateAuthentication(request);\n        if (authResult.isError()) {\n          return this.createErrorResponse(401, 'Unauthorized', requestId);\n        }\n      }\n\n      // Check rate limiting\n      if (route.rateLimit) {\n        const rateLimitResult = this.checkRateLimit(route, context.userId || 'anonymous');\n        if (rateLimitResult.isError()) {\n          return this.createErrorResponse(429, 'Rate limit exceeded', requestId);\n        }\n      }\n\n      // Check circuit breaker\n      if (route.circuitBreaker) {\n        const circuitResult = this.checkCircuitBreaker(route);\n        if (circuitResult.isError()) {\n          return this.createErrorResponse(503, 'Service temporarily unavailable', requestId);\n        }\n      }\n\n      // Forward request to target service\n      const response = await this.forwardRequest(request, route, context);\n      \n      // Update circuit breaker on success\n      if (route.circuitBreaker) {\n        this.updateCircuitBreakerSuccess(route);\n      }\n\n      // Log request completion\n      this.logRequestCompletion(context, response.status);\n\n      return response;\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Unknown gateway error');\n      logger.error('ApiGateway.processRequest', err, { requestId });\n      return this.createErrorResponse(500, 'Internal server error', requestId);\n    }\n  }\n\n  /**\n   * Find matching route for request\n   */\n  private findMatchingRoute(request: NextRequest): Result<ServiceRoute, Error> {\n    const path = request.nextUrl.pathname;\n    \n    // Try exact match first\n    for (const [routeKey, route] of this.routeMap.entries()) {\n      if (this.matchesRoute(path, route.path)) {\n        return Result.ok(route);\n      }\n    }\n\n    return Result.error(new Error('No matching route found'));\n  }\n\n  /**\n   * Check if path matches route pattern\n   */\n  private matchesRoute(path: string, routePattern: string): boolean {\n    // Simple pattern matching (could be enhanced with regex)\n    const pathSegments = path.split('/').filter(s => s);\n    const patternSegments = routePattern.split('/').filter(s => s);\n\n    if (pathSegments.length !== patternSegments.length) {\n      return false;\n    }\n\n    for (let i = 0; i < pathSegments.length; i++) {\n      const pathSegment = pathSegments[i];\n      const patternSegment = patternSegments[i];\n\n      // Handle wildcards and parameters\n      if (patternSegment.startsWith(':') || patternSegment === '*') {\n        continue;\n      }\n\n      if (pathSegment !== patternSegment) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Validate authentication\n   */\n  private async validateAuthentication(request: NextRequest): Promise<Result<string, Error>> {\n    // In a real implementation, this would validate JWT tokens,\n    // API keys, or integrate with authentication service\n    const authHeader = request.headers.get('authorization');\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return Result.error(new Error('Missing or invalid authorization header'));\n    }\n\n    // Simulate token validation\n    const token = authHeader.slice(7);\n    if (token.length < 10) {\n      return Result.error(new Error('Invalid token'));\n    }\n\n    return Result.ok(token);\n  }\n\n  /**\n   * Check rate limiting\n   */\n  private checkRateLimit(route: ServiceRoute, identifier: string): Result<void, Error> {\n    if (!route.rateLimit) {\n      return Result.ok(undefined);\n    }\n\n    const key = `${route.service}:${route.path}:${identifier}`;\n    const now = Date.now();\n    const limiter = this.rateLimiters.get(key);\n\n    if (!limiter) {\n      // First request\n      this.rateLimiters.set(key, {\n        requests: 1,\n        windowStart: now,\n      });\n      return Result.ok(undefined);\n    }\n\n    // Check if window has expired\n    if (now - limiter.windowStart > route.rateLimit.window) {\n      // Reset window\n      this.rateLimiters.set(key, {\n        requests: 1,\n        windowStart: now,\n      });\n      return Result.ok(undefined);\n    }\n\n    // Check if limit exceeded\n    if (limiter.requests >= route.rateLimit.requests) {\n      return Result.error(new Error('Rate limit exceeded'));\n    }\n\n    // Increment counter\n    limiter.requests++;\n    return Result.ok(undefined);\n  }\n\n  /**\n   * Check circuit breaker state\n   */\n  private checkCircuitBreaker(route: ServiceRoute): Result<void, Error> {\n    if (!route.circuitBreaker) {\n      return Result.ok(undefined);\n    }\n\n    const key = this.createRouteKey(route.path, route.service);\n    const breaker = this.circuitBreakers.get(key);\n\n    if (!breaker) {\n      return Result.ok(undefined);\n    }\n\n    const now = Date.now();\n\n    switch (breaker.state) {\n      case 'closed':\n        return Result.ok(undefined);\n\n      case 'open':\n        // Check if recovery time has passed\n        if (now - breaker.lastFailureTime > route.circuitBreaker.recoveryTimeMs) {\n          breaker.state = 'half-open';\n          return Result.ok(undefined);\n        }\n        return Result.error(new Error('Circuit breaker is open'));\n\n      case 'half-open':\n        return Result.ok(undefined);\n\n      default:\n        return Result.ok(undefined);\n    }\n  }\n\n  /**\n   * Forward request to target service\n   */\n  private async forwardRequest(\n    request: NextRequest,\n    route: ServiceRoute,\n    context: RequestContext\n  ): Promise<NextResponse> {\n    const timeout = route.timeout || this.config.defaultTimeout;\n    const retries = route.retries || this.config.defaultRetries;\n\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt <= retries; attempt++) {\n      try {\n        const targetUrl = this.buildTargetUrl(request, route);\n        \n        // Clone request for forwarding\n        const forwardedRequest = this.cloneRequest(request, targetUrl);\n        \n        // Add gateway headers\n        forwardedRequest.headers.set('X-Gateway-Request-Id', context.requestId);\n        forwardedRequest.headers.set('X-Gateway-Service', route.service);\n        if (context.userId) {\n          forwardedRequest.headers.set('X-Gateway-User-Id', context.userId);\n        }\n\n        // Make request with timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n        try {\n          const response = await fetch(forwardedRequest, {\n            signal: controller.signal,\n          });\n\n          clearTimeout(timeoutId);\n\n          // Create response with gateway headers\n          const gatewayResponse = new NextResponse(response.body, {\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers,\n          });\n\n          gatewayResponse.headers.set('X-Gateway-Request-Id', context.requestId);\n          gatewayResponse.headers.set('X-Gateway-Service', route.service);\n\n          return gatewayResponse;\n\n        } catch (fetchError) {\n          clearTimeout(timeoutId);\n          throw fetchError;\n        }\n\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error('Request failed');\n        \n        if (attempt < retries) {\n          logger.warn('ApiGateway.forwardRequest', {\n            requestId: context.requestId,\n            service: route.service,\n            attempt: attempt + 1,\n            error: lastError.message,\n          });\n\n          // Exponential backoff\n          await this.delay(Math.pow(2, attempt) * 100);\n        }\n      }\n    }\n\n    // Update circuit breaker on failure\n    if (route.circuitBreaker && lastError) {\n      this.updateCircuitBreakerFailure(route);\n    }\n\n    throw lastError || new Error('All retry attempts failed');\n  }\n\n  /**\n   * Build target URL for service\n   */\n  private buildTargetUrl(request: NextRequest, route: ServiceRoute): string {\n    const baseUrl = route.target.endsWith('/') ? route.target.slice(0, -1) : route.target;\n    const path = request.nextUrl.pathname;\n    const search = request.nextUrl.search;\n    \n    return `${baseUrl}${path}${search}`;\n  }\n\n  /**\n   * Clone request for forwarding\n   */\n  private cloneRequest(request: NextRequest, targetUrl: string): Request {\n    const headers = new Headers();\n    request.headers.forEach((value, key) => {\n      // Skip host header to avoid conflicts\n      if (key.toLowerCase() !== 'host') {\n        headers.set(key, value);\n      }\n    });\n\n    return new Request(targetUrl, {\n      method: request.method,\n      headers,\n      body: request.body,\n    });\n  }\n\n  /**\n   * Update circuit breaker on success\n   */\n  private updateCircuitBreakerSuccess(route: ServiceRoute): void {\n    const key = this.createRouteKey(route.path, route.service);\n    const breaker = this.circuitBreakers.get(key);\n\n    if (breaker) {\n      breaker.failures = 0;\n      breaker.state = 'closed';\n    }\n  }\n\n  /**\n   * Update circuit breaker on failure\n   */\n  private updateCircuitBreakerFailure(route: ServiceRoute): void {\n    if (!route.circuitBreaker) return;\n\n    const key = this.createRouteKey(route.path, route.service);\n    const breaker = this.circuitBreakers.get(key);\n\n    if (breaker) {\n      breaker.failures++;\n      breaker.lastFailureTime = Date.now();\n\n      if (breaker.failures >= route.circuitBreaker.failureThreshold) {\n        breaker.state = 'open';\n        logger.warn('Circuit breaker opened', {\n          service: route.service,\n          path: route.path,\n          failures: breaker.failures,\n        });\n      }\n    }\n  }\n\n  /**\n   * Create error response\n   */\n  private createErrorResponse(status: number, message: string, requestId: string): NextResponse {\n    return NextResponse.json(\n      {\n        error: {\n          message,\n          requestId,\n          timestamp: new Date().toISOString(),\n        },\n      },\n      {\n        status,\n        headers: {\n          'X-Gateway-Request-Id': requestId,\n        },\n      }\n    );\n  }\n\n  /**\n   * Extract user ID from request\n   */\n  private extractUserId(request: NextRequest): string | undefined {\n    // This would typically extract from JWT token or session\n    const authHeader = request.headers.get('authorization');\n    if (authHeader?.startsWith('Bearer ')) {\n      // Simulate user ID extraction from token\n      return 'user-' + authHeader.slice(7, 15);\n    }\n    return undefined;\n  }\n\n  /**\n   * Log request completion\n   */\n  private logRequestCompletion(context: RequestContext, status: number): void {\n    const duration = Date.now() - context.startTime;\n    \n    logger.info('ApiGateway.requestCompleted', {\n      requestId: context.requestId,\n      service: context.service,\n      status,\n      duration,\n      userId: context.userId,\n    });\n  }\n\n  /**\n   * Generate unique request ID\n   */\n  private generateRequestId(): string {\n    return `gw-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Create route key\n   */\n  private createRouteKey(path: string, service: string): string {\n    return `${service}:${path}`;\n  }\n\n  /**\n   * Delay helper for retries\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Get gateway statistics\n   */\n  getStatistics(): {\n    totalRoutes: number;\n    circuitBreakers: { [key: string]: CircuitBreakerState };\n    rateLimiters: number;\n  } {\n    return {\n      totalRoutes: this.routeMap.size,\n      circuitBreakers: Object.fromEntries(this.circuitBreakers),\n      rateLimiters: this.rateLimiters.size,\n    };\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\microservices\\api-gateway\\middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'request' is defined but never used. Allowed unused args must match /^_/u.","line":80,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":80,"endColumn":33},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":134,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3643,3646],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3643,3646],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":165,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4278,4281],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4278,4281],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * API Gateway Middleware\n * \n * Next.js middleware integration for API Gateway routing.\n * Handles request routing, authentication, and pre-processing.\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { ApiGateway } from './gateway';\nimport { getApiGatewayConfig } from './routing-config';\nimport { logger } from '@/lib/core/logger';\n\n/**\n * Gateway middleware instance\n */\nlet gatewayInstance: ApiGateway | null = null;\n\n/**\n * Initialize gateway instance\n */\nfunction getGatewayInstance(): ApiGateway {\n  if (!gatewayInstance) {\n    const config = getApiGatewayConfig();\n    gatewayInstance = new ApiGateway(config);\n    logger.info('ApiGateway initialized', {\n      totalRoutes: Object.values(config.services).flat().length,\n      services: Object.keys(config.services).length,\n    });\n  }\n  return gatewayInstance;\n}\n\n/**\n * Check if request should be handled by gateway\n */\nfunction shouldHandleRequest(request: NextRequest): boolean {\n  const path = request.nextUrl.pathname;\n  \n  // Handle API routes that match microservice patterns\n  const microservicePatterns = [\n    '/api/products',\n    '/api/inventory',\n    '/api/cart',\n    '/api/orders',\n    '/api/payments',\n    '/api/auth',\n    '/api/users',\n    '/api/addresses',\n    '/api/articles',\n    '/api/notifications',\n    '/api/analytics',\n  ];\n\n  return microservicePatterns.some(pattern => path.startsWith(pattern));\n}\n\n/**\n * Handle CORS for microservices\n */\nfunction addCorsHeaders(response: NextResponse): NextResponse {\n  const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'];\n  const origin = 'http://localhost:3000'; // In real app, get from request headers\n  \n  if (allowedOrigins.includes(origin)) {\n    response.headers.set('Access-Control-Allow-Origin', origin);\n  }\n  \n  response.headers.set('Access-Control-Allow-Credentials', 'true');\n  response.headers.set('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');\n  response.headers.set('Access-Control-Allow-Headers', \n    'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version, Authorization'\n  );\n  \n  return response;\n}\n\n/**\n * Handle preflight OPTIONS requests\n */\nfunction handlePreflight(request: NextRequest): NextResponse {\n  const response = new NextResponse(null, { status: 200 });\n  return addCorsHeaders(response);\n}\n\n/**\n * API Gateway Middleware\n */\nexport async function apiGatewayMiddleware(request: NextRequest): Promise<NextResponse | undefined> {\n  try {\n    // Skip non-API routes\n    if (!shouldHandleRequest(request)) {\n      return undefined;\n    }\n\n    // Handle preflight requests\n    if (request.method === 'OPTIONS') {\n      return handlePreflight(request);\n    }\n\n    // Get gateway instance and process request\n    const gateway = getGatewayInstance();\n    const response = await gateway.processRequest(request);\n    \n    // Add CORS headers to response\n    return addCorsHeaders(response);\n\n  } catch (error) {\n    const err = error instanceof Error ? error : new Error('Gateway middleware error');\n    logger.error('apiGatewayMiddleware', err, {\n      method: request.method,\n      path: request.nextUrl.pathname,\n    });\n\n    // Return error response\n    const errorResponse = NextResponse.json(\n      {\n        error: {\n          message: 'Gateway error',\n          timestamp: new Date().toISOString(),\n        },\n      },\n      { status: 500 }\n    );\n\n    return addCorsHeaders(errorResponse);\n  }\n}\n\n/**\n * Health check endpoint for gateway\n */\nexport async function gatewayHealthCheck(): Promise<{\n  status: 'healthy' | 'unhealthy';\n  gateway: any;\n  timestamp: string;\n}> {\n  try {\n    const gateway = getGatewayInstance();\n    const stats = gateway.getStatistics();\n    \n    return {\n      status: 'healthy',\n      gateway: {\n        ...stats,\n        uptime: process.uptime(),\n      },\n      timestamp: new Date().toISOString(),\n    };\n  } catch (error) {\n    logger.error('gatewayHealthCheck', error as Error);\n    \n    return {\n      status: 'unhealthy',\n      gateway: null,\n      timestamp: new Date().toISOString(),\n    };\n  }\n}\n\n/**\n * Gateway metrics endpoint\n */\nexport async function getGatewayMetrics(): Promise<{\n  routes: number;\n  circuitBreakers: Record<string, any>;\n  rateLimiters: number;\n  uptime: number;\n  timestamp: string;\n}> {\n  const gateway = getGatewayInstance();\n  const stats = gateway.getStatistics();\n  \n  return {\n    routes: stats.totalRoutes,\n    circuitBreakers: stats.circuitBreakers,\n    rateLimiters: stats.rateLimiters,\n    uptime: process.uptime(),\n    timestamp: new Date().toISOString(),\n  };\n}\n\n/**\n * Reset gateway instance (for testing)\n */\nexport function resetGatewayInstance(): void {\n  gatewayInstance = null;\n}\n\nexport { getGatewayInstance };","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\microservices\\service-registry\\discovery-client.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1022,1025],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1022,1025],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":148,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4097,4100],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4097,4100],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":313,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":313,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8845,8848],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8845,8848],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Service Discovery Client\n * \n * Client-side service discovery with caching, health monitoring,\n * and automatic failover capabilities.\n */\n\nimport { Result } from '@/lib/core/result';\nimport { logger } from '@/lib/core/logger';\nimport { ServiceInstance, LoadBalancingStrategy } from './registry';\n\n/**\n * Discovery client configuration\n */\nexport interface DiscoveryClientConfig {\n  readonly registryUrl: string;\n  readonly cacheEnabled: boolean;\n  readonly cacheTtl: number; // milliseconds\n  readonly retryAttempts: number;\n  readonly retryDelay: number; // milliseconds\n  readonly healthCheckEnabled: boolean;\n  readonly failoverEnabled: boolean;\n}\n\n/**\n * Cached service information\n */\ninterface CachedService {\n  instances: ServiceInstance[];\n  lastUpdated: number;\n  lastUsedIndex: number;\n}\n\n/**\n * Request options for service discovery\n */\nexport interface DiscoveryOptions {\n  strategy?: LoadBalancingStrategy;\n  forceRefresh?: boolean;\n  timeout?: number;\n  version?: string;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Service Discovery Client\n */\nexport class ServiceDiscoveryClient {\n  private readonly cache = new Map<string, CachedService>();\n  private readonly healthCheckTimers = new Map<string, NodeJS.Timeout>();\n  private readonly connectionCounts = new Map<string, number>();\n\n  constructor(private readonly config: DiscoveryClientConfig) {\n    logger.info('ServiceDiscoveryClient initialized', {\n      registryUrl: config.registryUrl,\n      cacheEnabled: config.cacheEnabled,\n      cacheTtl: config.cacheTtl,\n    });\n  }\n\n  /**\n   * Discover a service instance\n   */\n  async discover(\n    serviceName: string,\n    options: DiscoveryOptions = {}\n  ): Promise<Result<ServiceInstance, Error>> {\n    try {\n      const instances = await this.getServiceInstances(serviceName, options);\n      if (instances.isError()) {\n        return Result.error(instances.getError());\n      }\n\n      const availableInstances = this.filterInstances(instances.getValue(), options);\n      if (availableInstances.length === 0) {\n        return Result.error(new Error(`No suitable instances found for service '${serviceName}'`));\n      }\n\n      const selectedInstance = this.selectInstance(\n        serviceName,\n        availableInstances,\n        options.strategy || 'round-robin'\n      );\n\n      // Track connection for load balancing\n      this.incrementConnections(selectedInstance.id);\n\n      logger.debug('Service discovered', {\n        serviceName,\n        instanceId: selectedInstance.id,\n        endpoint: `${selectedInstance.protocol}://${selectedInstance.host}:${selectedInstance.port}`,\n        strategy: options.strategy || 'round-robin',\n      });\n\n      return Result.ok(selectedInstance);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Service discovery failed');\n      logger.error('ServiceDiscoveryClient.discover', err, {\n        serviceName,\n        options,\n      });\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Get all instances for a service\n   */\n  async discoverAll(\n    serviceName: string,\n    options: DiscoveryOptions = {}\n  ): Promise<Result<ServiceInstance[], Error>> {\n    try {\n      const instances = await this.getServiceInstances(serviceName, options);\n      if (instances.isError()) {\n        return Result.error(instances.getError());\n      }\n\n      const availableInstances = this.filterInstances(instances.getValue(), options);\n      \n      logger.debug('All service instances discovered', {\n        serviceName,\n        instanceCount: availableInstances.length,\n      });\n\n      return Result.ok(availableInstances);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Service discovery failed');\n      logger.error('ServiceDiscoveryClient.discoverAll', err, {\n        serviceName,\n        options,\n      });\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Make HTTP request with automatic service discovery\n   */\n  async request(\n    serviceName: string,\n    path: string,\n    options: {\n      method?: string;\n      headers?: Record<string, string>;\n      body?: any;\n      timeout?: number;\n      retries?: number;\n      discoveryOptions?: DiscoveryOptions;\n    } = {}\n  ): Promise<Result<Response, Error>> {\n    const maxRetries = options.retries ?? this.config.retryAttempts;\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        // Discover service instance\n        const instanceResult = await this.discover(serviceName, options.discoveryOptions);\n        if (instanceResult.isError()) {\n          lastError = instanceResult.getError();\n          continue;\n        }\n\n        const instance = instanceResult.getValue();\n        const url = `${instance.protocol}://${instance.host}:${instance.port}${path}`;\n\n        // Make request\n        const controller = new AbortController();\n        const timeout = options.timeout || 5000;\n        const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n        try {\n          const response = await fetch(url, {\n            method: options.method || 'GET',\n            headers: {\n              'Content-Type': 'application/json',\n              ...options.headers,\n            },\n            body: options.body ? JSON.stringify(options.body) : undefined,\n            signal: controller.signal,\n          });\n\n          clearTimeout(timeoutId);\n\n          // Decrement connection count\n          this.decrementConnections(instance.id);\n\n          // Update instance health based on response\n          if (this.config.healthCheckEnabled) {\n            this.updateInstanceHealth(serviceName, instance.id, response.ok);\n          }\n\n          logger.debug('Service request completed', {\n            serviceName,\n            instanceId: instance.id,\n            method: options.method || 'GET',\n            path,\n            status: response.status,\n            attempt: attempt + 1,\n          });\n\n          return Result.ok(response);\n\n        } catch (fetchError) {\n          clearTimeout(timeoutId);\n          this.decrementConnections(instance.id);\n          \n          if (this.config.healthCheckEnabled) {\n            this.updateInstanceHealth(serviceName, instance.id, false);\n          }\n          \n          throw fetchError;\n        }\n\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error('Request failed');\n        \n        if (attempt < maxRetries) {\n          logger.warn('Service request failed, retrying', {\n            serviceName,\n            path,\n            attempt: attempt + 1,\n            maxRetries,\n            error: lastError.message,\n          });\n\n          // Exponential backoff\n          await this.delay(this.config.retryDelay * Math.pow(2, attempt));\n        }\n      }\n    }\n\n    const finalError = lastError || new Error('All retry attempts failed');\n    logger.error('ServiceDiscoveryClient.request', finalError, {\n      serviceName,\n      path,\n      maxRetries,\n    });\n\n    return Result.error(finalError);\n  }\n\n  /**\n   * Get service health status\n   */\n  async getServiceHealth(serviceName: string): Promise<Result<{\n    total: number;\n    healthy: number;\n    unhealthy: number;\n    instances: Array<{\n      id: string;\n      endpoint: string;\n      status: string;\n      lastCheck: Date;\n    }>;\n  }, Error>> {\n    try {\n      const instancesResult = await this.getServiceInstances(serviceName);\n      if (instancesResult.isError()) {\n        return Result.error(instancesResult.getError());\n      }\n\n      const instances = instancesResult.getValue();\n      const healthy = instances.filter(i => i.status === 'healthy').length;\n      const unhealthy = instances.filter(i => i.status === 'unhealthy').length;\n\n      const health = {\n        total: instances.length,\n        healthy,\n        unhealthy,\n        instances: instances.map(instance => ({\n          id: instance.id,\n          endpoint: `${instance.protocol}://${instance.host}:${instance.port}`,\n          status: instance.status,\n          lastCheck: instance.lastHealthCheck,\n        })),\n      };\n\n      return Result.ok(health);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Health check failed');\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Clear cache for a service\n   */\n  clearCache(serviceName?: string): void {\n    if (serviceName) {\n      this.cache.delete(serviceName);\n      logger.debug('Service cache cleared', { serviceName });\n    } else {\n      this.cache.clear();\n      logger.debug('All service cache cleared');\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStatistics(): {\n    totalEntries: number;\n    services: Record<string, {\n      instanceCount: number;\n      lastUpdated: Date;\n      age: number; // milliseconds\n    }>;\n  } {\n    const services: Record<string, any> = {};\n    const now = Date.now();\n\n    for (const [serviceName, cached] of this.cache.entries()) {\n      services[serviceName] = {\n        instanceCount: cached.instances.length,\n        lastUpdated: new Date(cached.lastUpdated),\n        age: now - cached.lastUpdated,\n      };\n    }\n\n    return {\n      totalEntries: this.cache.size,\n      services,\n    };\n  }\n\n  /**\n   * Shutdown the client\n   */\n  async shutdown(): Promise<void> {\n    logger.info('ServiceDiscoveryClient shutting down');\n\n    // Stop all health check timers\n    for (const timer of this.healthCheckTimers.values()) {\n      clearInterval(timer);\n    }\n    this.healthCheckTimers.clear();\n\n    // Clear cache and connection counts\n    this.cache.clear();\n    this.connectionCounts.clear();\n\n    logger.info('ServiceDiscoveryClient shutdown complete');\n  }\n\n  /**\n   * Get service instances from registry or cache\n   */\n  private async getServiceInstances(\n    serviceName: string,\n    options: DiscoveryOptions = {}\n  ): Promise<Result<ServiceInstance[], Error>> {\n    // Check cache first\n    if (this.config.cacheEnabled && !options.forceRefresh) {\n      const cached = this.cache.get(serviceName);\n      if (cached && (Date.now() - cached.lastUpdated) < this.config.cacheTtl) {\n        logger.debug('Using cached service instances', {\n          serviceName,\n          instanceCount: cached.instances.length,\n          cacheAge: Date.now() - cached.lastUpdated,\n        });\n        return Result.ok(cached.instances);\n      }\n    }\n\n    // Fetch from registry\n    try {\n      const url = `${this.config.registryUrl}/services/${serviceName}/instances`;\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        signal: AbortSignal.timeout(options.timeout || 5000),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Registry request failed: ${response.status} ${response.statusText}`);\n      }\n\n      const instances: ServiceInstance[] = await response.json();\n\n      // Update cache\n      if (this.config.cacheEnabled) {\n        this.cache.set(serviceName, {\n          instances,\n          lastUpdated: Date.now(),\n          lastUsedIndex: 0,\n        });\n      }\n\n      logger.debug('Service instances fetched from registry', {\n        serviceName,\n        instanceCount: instances.length,\n      });\n\n      return Result.ok(instances);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Registry fetch failed');\n      \n      // Fallback to cache if available\n      if (this.config.cacheEnabled) {\n        const cached = this.cache.get(serviceName);\n        if (cached) {\n          logger.warn('Using stale cache due to registry error', {\n            serviceName,\n            error: err.message,\n            cacheAge: Date.now() - cached.lastUpdated,\n          });\n          return Result.ok(cached.instances);\n        }\n      }\n\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Filter instances based on options\n   */\n  private filterInstances(\n    instances: ServiceInstance[],\n    options: DiscoveryOptions\n  ): ServiceInstance[] {\n    let filtered = instances;\n\n    // Filter by health status\n    filtered = filtered.filter(instance => instance.status === 'healthy');\n\n    // Filter by version if specified\n    if (options.version) {\n      filtered = filtered.filter(instance => instance.version === options.version);\n    }\n\n    // Filter by metadata if specified\n    if (options.metadata) {\n      filtered = filtered.filter(instance => {\n        return Object.entries(options.metadata!).every(([key, value]) => \n          instance.metadata[key] === value\n        );\n      });\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Select instance using load balancing strategy\n   */\n  private selectInstance(\n    serviceName: string,\n    instances: ServiceInstance[],\n    strategy: LoadBalancingStrategy\n  ): ServiceInstance {\n    switch (strategy) {\n      case 'round-robin':\n        return this.selectRoundRobin(serviceName, instances);\n      \n      case 'weighted':\n        return this.selectWeighted(instances);\n      \n      case 'least-connections':\n        return this.selectLeastConnections(instances);\n      \n      case 'random':\n        return this.selectRandom(instances);\n      \n      default:\n        return this.selectRoundRobin(serviceName, instances);\n    }\n  }\n\n  /**\n   * Round-robin selection with cache state\n   */\n  private selectRoundRobin(serviceName: string, instances: ServiceInstance[]): ServiceInstance {\n    const cached = this.cache.get(serviceName);\n    if (cached) {\n      const index = cached.lastUsedIndex % instances.length;\n      cached.lastUsedIndex = index + 1;\n      return instances[index];\n    }\n    \n    // Fallback to random if no cache\n    return this.selectRandom(instances);\n  }\n\n  /**\n   * Weighted selection\n   */\n  private selectWeighted(instances: ServiceInstance[]): ServiceInstance {\n    const totalWeight = instances.reduce((sum, instance) => sum + instance.weight, 0);\n    let random = Math.random() * totalWeight;\n    \n    for (const instance of instances) {\n      random -= instance.weight;\n      if (random <= 0) {\n        return instance;\n      }\n    }\n    \n    return instances[instances.length - 1];\n  }\n\n  /**\n   * Least connections selection\n   */\n  private selectLeastConnections(instances: ServiceInstance[]): ServiceInstance {\n    let selectedInstance = instances[0];\n    let minConnections = this.connectionCounts.get(selectedInstance.id) || 0;\n    \n    for (const instance of instances) {\n      const connections = this.connectionCounts.get(instance.id) || 0;\n      if (connections < minConnections) {\n        minConnections = connections;\n        selectedInstance = instance;\n      }\n    }\n    \n    return selectedInstance;\n  }\n\n  /**\n   * Random selection\n   */\n  private selectRandom(instances: ServiceInstance[]): ServiceInstance {\n    const randomIndex = Math.floor(Math.random() * instances.length);\n    return instances[randomIndex];\n  }\n\n  /**\n   * Increment connection count\n   */\n  private incrementConnections(instanceId: string): void {\n    const current = this.connectionCounts.get(instanceId) || 0;\n    this.connectionCounts.set(instanceId, current + 1);\n  }\n\n  /**\n   * Decrement connection count\n   */\n  private decrementConnections(instanceId: string): void {\n    const current = this.connectionCounts.get(instanceId) || 0;\n    this.connectionCounts.set(instanceId, Math.max(0, current - 1));\n  }\n\n  /**\n   * Update instance health in cache\n   */\n  private updateInstanceHealth(serviceName: string, instanceId: string, isHealthy: boolean): void {\n    const cached = this.cache.get(serviceName);\n    if (!cached) return;\n\n    const instance = cached.instances.find(i => i.id === instanceId);\n    if (!instance) return;\n\n    const newStatus = isHealthy ? 'healthy' : 'unhealthy';\n    if (instance.status !== newStatus) {\n      instance.status = newStatus;\n      instance.lastHealthCheck = new Date();\n      \n      logger.debug('Instance health status updated in cache', {\n        serviceName,\n        instanceId,\n        status: newStatus,\n      });\n    }\n  }\n\n  /**\n   * Delay helper for retries\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\microservices\\service-registry\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":169,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4702,4705],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4702,4705],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":170,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":170,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4744,4747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4744,4747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":177,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":177,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":214,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5972,5975],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5972,5975],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":214,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5982,5985],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5982,5985],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":215,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6029,6032],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6029,6032],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":215,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6039,6042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6039,6042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":230,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":230,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":258,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":258,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":284,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":284,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Service Registry Module\n * \n * Centralized exports for service registry and discovery functionality.\n * Provides unified access to registration, discovery, and configuration.\n */\n\n// Core registry functionality\nexport { ServiceRegistry } from './registry';\nexport type { \n  ServiceInstance, \n  ServiceRegistration, \n  HealthCheckConfig,\n  ServiceRegistryConfig,\n  LoadBalancingStrategy,\n} from './registry';\n\n// Discovery client\nexport { ServiceDiscoveryClient } from './discovery-client';\nexport type { \n  DiscoveryClientConfig, \n  DiscoveryOptions,\n} from './discovery-client';\n\n// Configuration and utilities\nexport {\n  DEFAULT_HEALTH_CHECK_CONFIG,\n  DEFAULT_REGISTRY_CONFIG,\n  DEFAULT_DISCOVERY_CLIENT_CONFIG,\n  ENVIRONMENT_CONFIGS,\n  SERVICE_CONFIGS,\n  LOAD_BALANCING_CONFIGS,\n  getRegistryConfig,\n  getDiscoveryClientConfig,\n  getServiceHealthConfig,\n  createRegistryConfig,\n  createDiscoveryClientConfig,\n  validateRegistryConfig,\n  validateDiscoveryClientConfig,\n  ENV_UTILS,\n} from './config';\n\n/**\n * Quick setup utilities\n */\nexport class ServiceRegistrySetup {\n  /**\n   * Create a development registry instance\n   */\n  static createDevelopmentRegistry(): ServiceRegistry {\n    const config = getRegistryConfig('development');\n    return new ServiceRegistry(config);\n  }\n\n  /**\n   * Create a production registry instance\n   */\n  static createProductionRegistry(): ServiceRegistry {\n    const config = getRegistryConfig('production');\n    return new ServiceRegistry(config);\n  }\n\n  /**\n   * Create a development discovery client\n   */\n  static createDevelopmentDiscoveryClient(): ServiceDiscoveryClient {\n    const config = getDiscoveryClientConfig('development');\n    return new ServiceDiscoveryClient(config);\n  }\n\n  /**\n   * Create a production discovery client\n   */\n  static createProductionDiscoveryClient(): ServiceDiscoveryClient {\n    const config = getDiscoveryClientConfig('production');\n    return new ServiceDiscoveryClient(config);\n  }\n\n  /**\n   * Create registry with custom configuration\n   */\n  static createCustomRegistry(overrides: Partial<ServiceRegistryConfig>): ServiceRegistry {\n    const config = createRegistryConfig(overrides);\n    const errors = validateRegistryConfig(config);\n    \n    if (errors.length > 0) {\n      throw new Error(`Invalid registry configuration: ${errors.join(', ')}`);\n    }\n    \n    return new ServiceRegistry(config);\n  }\n\n  /**\n   * Create discovery client with custom configuration\n   */\n  static createCustomDiscoveryClient(overrides: Partial<DiscoveryClientConfig>): ServiceDiscoveryClient {\n    const config = createDiscoveryClientConfig(overrides);\n    const errors = validateDiscoveryClientConfig(config);\n    \n    if (errors.length > 0) {\n      throw new Error(`Invalid discovery client configuration: ${errors.join(', ')}`);\n    }\n    \n    return new ServiceDiscoveryClient(config);\n  }\n}\n\n/**\n * Service registration helpers\n */\nexport class ServiceRegistrationHelpers {\n  /**\n   * Create service registration from current process\n   */\n  static createFromProcess(\n    serviceName: string,\n    version: string,\n    port: number,\n    overrides: Partial<ServiceRegistration> = {}\n  ): ServiceRegistration {\n    return {\n      name: serviceName,\n      version,\n      host: process.env.SERVICE_HOST || 'localhost',\n      port,\n      protocol: (process.env.SERVICE_PROTOCOL as 'http' | 'https') || 'http',\n      healthCheckPath: '/health',\n      metadata: {\n        nodeVersion: process.version,\n        platform: process.platform,\n        pid: process.pid,\n        startTime: new Date().toISOString(),\n        ...overrides.metadata,\n      },\n      ...overrides,\n    };\n  }\n\n  /**\n   * Create service registration from environment variables\n   */\n  static createFromEnvironment(serviceName: string): ServiceRegistration {\n    const version = process.env.SERVICE_VERSION || '1.0.0';\n    const host = process.env.SERVICE_HOST || 'localhost';\n    const port = parseInt(process.env.SERVICE_PORT || '3000', 10);\n    const protocol = (process.env.SERVICE_PROTOCOL as 'http' | 'https') || 'http';\n    const healthCheckPath = process.env.HEALTH_CHECK_PATH || '/health';\n\n    return {\n      name: serviceName,\n      version,\n      host,\n      port,\n      protocol,\n      healthCheckPath,\n      metadata: {\n        environment: process.env.NODE_ENV || 'development',\n        region: process.env.AWS_REGION || process.env.GOOGLE_CLOUD_REGION || 'local',\n        zone: process.env.AVAILABILITY_ZONE || 'local',\n        instance: process.env.INSTANCE_ID || 'local',\n        ...this.parseMetadataFromEnv(),\n      },\n    };\n  }\n\n  /**\n   * Parse metadata from environment variables\n   */\n  private static parseMetadataFromEnv(): Record<string, any> {\n    const metadata: Record<string, any> = {};\n    \n    // Parse SERVICE_METADATA environment variable\n    const metadataEnv = process.env.SERVICE_METADATA;\n    if (metadataEnv) {\n      try {\n        Object.assign(metadata, JSON.parse(metadataEnv));\n      } catch (error) {\n        console.warn('Failed to parse SERVICE_METADATA environment variable');\n      }\n    }\n\n    // Add common cloud metadata\n    if (process.env.KUBERNETES_SERVICE_HOST) {\n      metadata.platform = 'kubernetes';\n      metadata.namespace = process.env.KUBERNETES_NAMESPACE || 'default';\n      metadata.podName = process.env.HOSTNAME;\n    }\n\n    if (process.env.AWS_REGION) {\n      metadata.cloud = 'aws';\n      metadata.instanceId = process.env.AWS_INSTANCE_ID;\n      metadata.availabilityZone = process.env.AWS_AVAILABILITY_ZONE;\n    }\n\n    if (process.env.GOOGLE_CLOUD_PROJECT) {\n      metadata.cloud = 'gcp';\n      metadata.projectId = process.env.GOOGLE_CLOUD_PROJECT;\n      metadata.zone = process.env.GOOGLE_CLOUD_ZONE;\n    }\n\n    return metadata;\n  }\n}\n\n/**\n * Health check utilities\n */\nexport class HealthCheckUtils {\n  /**\n   * Create a simple health check endpoint handler\n   */\n  static createHealthCheckHandler(\n    customChecks: Array<() => Promise<boolean>> = []\n  ): (req: any, res: any) => Promise<void> {\n    return async (req: any, res: any) => {\n      try {\n        const health = {\n          status: 'healthy',\n          timestamp: new Date().toISOString(),\n          uptime: process.uptime(),\n          memory: process.memoryUsage(),\n          version: process.env.SERVICE_VERSION || '1.0.0',\n          checks: {} as Record<string, boolean>,\n        };\n\n        // Run custom health checks\n        for (let i = 0; i < customChecks.length; i++) {\n          try {\n            health.checks[`custom_${i}`] = await customChecks[i]();\n          } catch (error) {\n            health.checks[`custom_${i}`] = false;\n            health.status = 'unhealthy';\n          }\n        }\n\n        const statusCode = health.status === 'healthy' ? 200 : 503;\n        res.status(statusCode).json(health);\n\n      } catch (error) {\n        res.status(503).json({\n          status: 'unhealthy',\n          timestamp: new Date().toISOString(),\n          error: error instanceof Error ? error.message : 'Unknown error',\n        });\n      }\n    };\n  }\n\n  /**\n   * Create database health check\n   */\n  static createDatabaseHealthCheck(\n    checkConnection: () => Promise<boolean>\n  ): () => Promise<boolean> {\n    return async () => {\n      try {\n        return await checkConnection();\n      } catch (error) {\n        return false;\n      }\n    };\n  }\n\n  /**\n   * Create external service health check\n   */\n  static createExternalServiceHealthCheck(\n    serviceUrl: string,\n    timeout = 5000\n  ): () => Promise<boolean> {\n    return async () => {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n        const response = await fetch(serviceUrl, {\n          method: 'GET',\n          signal: controller.signal,\n        });\n\n        clearTimeout(timeoutId);\n        return response.ok;\n\n      } catch (error) {\n        return false;\n      }\n    };\n  }\n}\n\n// Re-export configuration helpers\nimport { \n  getRegistryConfig, \n  getDiscoveryClientConfig, \n  createRegistryConfig, \n  createDiscoveryClientConfig,\n  validateRegistryConfig,\n  validateDiscoveryClientConfig,\n} from './config';","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\microservices\\service-registry\\registry.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[596,599],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[596,599],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1071,1074],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1071,1074],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Service Registry Implementation\n * \n * Provides service discovery and registration for microservices architecture.\n * Handles service health monitoring, load balancing, and failover.\n */\n\nimport { Result } from '@/lib/core/result';\nimport { logger } from '@/lib/core/logger';\n\n/**\n * Service instance information\n */\nexport interface ServiceInstance {\n  readonly id: string;\n  readonly name: string;\n  readonly version: string;\n  readonly host: string;\n  readonly port: number;\n  readonly protocol: 'http' | 'https';\n  readonly healthCheckPath: string;\n  readonly metadata: Record<string, any>;\n  readonly registeredAt: Date;\n  readonly lastHealthCheck: Date;\n  readonly status: 'healthy' | 'unhealthy' | 'unknown';\n  readonly weight: number; // For load balancing\n}\n\n/**\n * Service registration request\n */\nexport interface ServiceRegistration {\n  readonly name: string;\n  readonly version: string;\n  readonly host: string;\n  readonly port: number;\n  readonly protocol?: 'http' | 'https';\n  readonly healthCheckPath?: string;\n  readonly metadata?: Record<string, any>;\n  readonly weight?: number;\n}\n\n/**\n * Health check configuration\n */\nexport interface HealthCheckConfig {\n  readonly interval: number; // milliseconds\n  readonly timeout: number; // milliseconds\n  readonly retries: number;\n  readonly failureThreshold: number;\n  readonly successThreshold: number;\n}\n\n/**\n * Service registry configuration\n */\nexport interface ServiceRegistryConfig {\n  readonly healthCheck: HealthCheckConfig;\n  readonly cleanupInterval: number; // milliseconds\n  readonly instanceTtl: number; // milliseconds\n  readonly enableAutoCleanup: boolean;\n}\n\n/**\n * Load balancing strategies\n */\nexport type LoadBalancingStrategy = 'round-robin' | 'weighted' | 'least-connections' | 'random';\n\n/**\n * Service Registry Implementation\n */\nexport class ServiceRegistry {\n  private readonly services = new Map<string, Map<string, ServiceInstance>>();\n  private readonly healthCheckTimers = new Map<string, NodeJS.Timeout>();\n  private cleanupTimer?: NodeJS.Timeout;\n  private readonly roundRobinCounters = new Map<string, number>();\n  private readonly connectionCounts = new Map<string, number>();\n\n  constructor(private readonly config: ServiceRegistryConfig) {\n    if (config.enableAutoCleanup) {\n      this.startCleanupTimer();\n    }\n    \n    logger.info('ServiceRegistry initialized', {\n      healthCheckInterval: config.healthCheck.interval,\n      cleanupInterval: config.cleanupInterval,\n      instanceTtl: config.instanceTtl,\n    });\n  }\n\n  /**\n   * Register a service instance\n   */\n  async register(registration: ServiceRegistration): Promise<Result<ServiceInstance, Error>> {\n    try {\n      const instance: ServiceInstance = {\n        id: this.generateInstanceId(registration),\n        name: registration.name,\n        version: registration.version,\n        host: registration.host,\n        port: registration.port,\n        protocol: registration.protocol || 'http',\n        healthCheckPath: registration.healthCheckPath || '/health',\n        metadata: registration.metadata || {},\n        registeredAt: new Date(),\n        lastHealthCheck: new Date(),\n        status: 'unknown',\n        weight: registration.weight || 100,\n      };\n\n      // Add to services map\n      if (!this.services.has(registration.name)) {\n        this.services.set(registration.name, new Map());\n      }\n      \n      const serviceInstances = this.services.get(registration.name)!;\n      serviceInstances.set(instance.id, instance);\n\n      // Start health checking\n      await this.startHealthCheck(instance);\n\n      logger.info('Service registered', {\n        serviceId: instance.id,\n        serviceName: instance.name,\n        endpoint: `${instance.protocol}://${instance.host}:${instance.port}`,\n        version: instance.version,\n      });\n\n      return Result.ok(instance);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Service registration failed');\n      logger.error('ServiceRegistry.register', err, {\n        serviceName: registration.name,\n        host: registration.host,\n        port: registration.port,\n      });\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Deregister a service instance\n   */\n  async deregister(serviceName: string, instanceId: string): Promise<Result<void, Error>> {\n    try {\n      const serviceInstances = this.services.get(serviceName);\n      if (!serviceInstances) {\n        return Result.error(new Error(`Service '${serviceName}' not found`));\n      }\n\n      const instance = serviceInstances.get(instanceId);\n      if (!instance) {\n        return Result.error(new Error(`Instance '${instanceId}' not found`));\n      }\n\n      // Stop health checking\n      this.stopHealthCheck(instanceId);\n\n      // Remove instance\n      serviceInstances.delete(instanceId);\n      \n      // Remove service if no instances left\n      if (serviceInstances.size === 0) {\n        this.services.delete(serviceName);\n        this.roundRobinCounters.delete(serviceName);\n      }\n\n      // Clean up connection tracking\n      this.connectionCounts.delete(instanceId);\n\n      logger.info('Service deregistered', {\n        serviceId: instanceId,\n        serviceName,\n      });\n\n      return Result.ok(undefined);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Service deregistration failed');\n      logger.error('ServiceRegistry.deregister', err, {\n        serviceName,\n        instanceId,\n      });\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Discover service instances\n   */\n  async discover(\n    serviceName: string,\n    strategy: LoadBalancingStrategy = 'round-robin'\n  ): Promise<Result<ServiceInstance, Error>> {\n    try {\n      const serviceInstances = this.services.get(serviceName);\n      if (!serviceInstances || serviceInstances.size === 0) {\n        return Result.error(new Error(`No instances found for service '${serviceName}'`));\n      }\n\n      // Filter healthy instances\n      const healthyInstances = Array.from(serviceInstances.values())\n        .filter(instance => instance.status === 'healthy');\n\n      if (healthyInstances.length === 0) {\n        return Result.error(new Error(`No healthy instances found for service '${serviceName}'`));\n      }\n\n      // Apply load balancing strategy\n      const selectedInstance = this.selectInstance(serviceName, healthyInstances, strategy);\n      \n      logger.debug('Service discovered', {\n        serviceName,\n        selectedInstance: selectedInstance.id,\n        strategy,\n        availableInstances: healthyInstances.length,\n      });\n\n      return Result.ok(selectedInstance);\n\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Service discovery failed');\n      logger.error('ServiceRegistry.discover', err, {\n        serviceName,\n        strategy,\n      });\n      return Result.error(err);\n    }\n  }\n\n  /**\n   * Get all service instances for a service\n   */\n  getServiceInstances(serviceName: string): ServiceInstance[] {\n    const serviceInstances = this.services.get(serviceName);\n    return serviceInstances ? Array.from(serviceInstances.values()) : [];\n  }\n\n  /**\n   * Get all registered services\n   */\n  getAllServices(): Record<string, ServiceInstance[]> {\n    const result: Record<string, ServiceInstance[]> = {};\n    \n    for (const [serviceName, instances] of this.services.entries()) {\n      result[serviceName] = Array.from(instances.values());\n    }\n    \n    return result;\n  }\n\n  /**\n   * Get healthy service instances count\n   */\n  getHealthyInstancesCount(serviceName: string): number {\n    const instances = this.getServiceInstances(serviceName);\n    return instances.filter(instance => instance.status === 'healthy').length;\n  }\n\n  /**\n   * Update connection count for load balancing\n   */\n  incrementConnections(instanceId: string): void {\n    const current = this.connectionCounts.get(instanceId) || 0;\n    this.connectionCounts.set(instanceId, current + 1);\n  }\n\n  /**\n   * Decrement connection count\n   */\n  decrementConnections(instanceId: string): void {\n    const current = this.connectionCounts.get(instanceId) || 0;\n    this.connectionCounts.set(instanceId, Math.max(0, current - 1));\n  }\n\n  /**\n   * Get registry statistics\n   */\n  getStatistics(): {\n    totalServices: number;\n    totalInstances: number;\n    healthyInstances: number;\n    unhealthyInstances: number;\n    instancesByService: Record<string, number>;\n    healthCheckStats: {\n      activeChecks: number;\n      totalChecks: number;\n    };\n  } {\n    let totalInstances = 0;\n    let healthyInstances = 0;\n    let unhealthyInstances = 0;\n    const instancesByService: Record<string, number> = {};\n\n    for (const [serviceName, instances] of this.services.entries()) {\n      const instanceArray = Array.from(instances.values());\n      const serviceInstanceCount = instanceArray.length;\n      const serviceHealthyCount = instanceArray.filter(i => i.status === 'healthy').length;\n      const serviceUnhealthyCount = instanceArray.filter(i => i.status === 'unhealthy').length;\n\n      totalInstances += serviceInstanceCount;\n      healthyInstances += serviceHealthyCount;\n      unhealthyInstances += serviceUnhealthyCount;\n      instancesByService[serviceName] = serviceInstanceCount;\n    }\n\n    return {\n      totalServices: this.services.size,\n      totalInstances,\n      healthyInstances,\n      unhealthyInstances,\n      instancesByService,\n      healthCheckStats: {\n        activeChecks: this.healthCheckTimers.size,\n        totalChecks: totalInstances,\n      },\n    };\n  }\n\n  /**\n   * Shutdown the registry\n   */\n  async shutdown(): Promise<void> {\n    logger.info('ServiceRegistry shutting down');\n\n    // Stop all health checks\n    for (const timer of this.healthCheckTimers.values()) {\n      clearInterval(timer);\n    }\n    this.healthCheckTimers.clear();\n\n    // Stop cleanup timer\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = undefined;\n    }\n\n    // Clear all data\n    this.services.clear();\n    this.roundRobinCounters.clear();\n    this.connectionCounts.clear();\n\n    logger.info('ServiceRegistry shutdown complete');\n  }\n\n  /**\n   * Generate unique instance ID\n   */\n  private generateInstanceId(registration: ServiceRegistration): string {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substr(2, 8);\n    return `${registration.name}-${registration.host}-${registration.port}-${timestamp}-${random}`;\n  }\n\n  /**\n   * Select instance using load balancing strategy\n   */\n  private selectInstance(\n    serviceName: string,\n    instances: ServiceInstance[],\n    strategy: LoadBalancingStrategy\n  ): ServiceInstance {\n    switch (strategy) {\n      case 'round-robin':\n        return this.selectRoundRobin(serviceName, instances);\n      \n      case 'weighted':\n        return this.selectWeighted(instances);\n      \n      case 'least-connections':\n        return this.selectLeastConnections(instances);\n      \n      case 'random':\n        return this.selectRandom(instances);\n      \n      default:\n        return this.selectRoundRobin(serviceName, instances);\n    }\n  }\n\n  /**\n   * Round-robin selection\n   */\n  private selectRoundRobin(serviceName: string, instances: ServiceInstance[]): ServiceInstance {\n    const counter = (this.roundRobinCounters.get(serviceName) || 0) % instances.length;\n    this.roundRobinCounters.set(serviceName, counter + 1);\n    return instances[counter];\n  }\n\n  /**\n   * Weighted selection\n   */\n  private selectWeighted(instances: ServiceInstance[]): ServiceInstance {\n    const totalWeight = instances.reduce((sum, instance) => sum + instance.weight, 0);\n    let random = Math.random() * totalWeight;\n    \n    for (const instance of instances) {\n      random -= instance.weight;\n      if (random <= 0) {\n        return instance;\n      }\n    }\n    \n    return instances[instances.length - 1];\n  }\n\n  /**\n   * Least connections selection\n   */\n  private selectLeastConnections(instances: ServiceInstance[]): ServiceInstance {\n    let selectedInstance = instances[0];\n    let minConnections = this.connectionCounts.get(selectedInstance.id) || 0;\n    \n    for (const instance of instances) {\n      const connections = this.connectionCounts.get(instance.id) || 0;\n      if (connections < minConnections) {\n        minConnections = connections;\n        selectedInstance = instance;\n      }\n    }\n    \n    return selectedInstance;\n  }\n\n  /**\n   * Random selection\n   */\n  private selectRandom(instances: ServiceInstance[]): ServiceInstance {\n    const randomIndex = Math.floor(Math.random() * instances.length);\n    return instances[randomIndex];\n  }\n\n  /**\n   * Start health check for an instance\n   */\n  private async startHealthCheck(instance: ServiceInstance): Promise<void> {\n    // Perform initial health check\n    await this.performHealthCheck(instance);\n\n    // Schedule periodic health checks\n    const timer = setInterval(async () => {\n      await this.performHealthCheck(instance);\n    }, this.config.healthCheck.interval);\n\n    this.healthCheckTimers.set(instance.id, timer);\n  }\n\n  /**\n   * Stop health check for an instance\n   */\n  private stopHealthCheck(instanceId: string): void {\n    const timer = this.healthCheckTimers.get(instanceId);\n    if (timer) {\n      clearInterval(timer);\n      this.healthCheckTimers.delete(instanceId);\n    }\n  }\n\n  /**\n   * Perform health check on an instance\n   */\n  private async performHealthCheck(instance: ServiceInstance): Promise<void> {\n    const healthUrl = `${instance.protocol}://${instance.host}:${instance.port}${instance.healthCheckPath}`;\n    \n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.config.healthCheck.timeout);\n\n      const response = await fetch(healthUrl, {\n        method: 'GET',\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      const isHealthy = response.ok;\n      this.updateInstanceHealth(instance, isHealthy);\n\n    } catch (error) {\n      logger.debug('Health check failed', {\n        instanceId: instance.id,\n        healthUrl,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n      \n      this.updateInstanceHealth(instance, false);\n    }\n  }\n\n  /**\n   * Update instance health status\n   */\n  private updateInstanceHealth(instance: ServiceInstance, isHealthy: boolean): void {\n    const serviceInstances = this.services.get(instance.name);\n    if (!serviceInstances) return;\n\n    const currentInstance = serviceInstances.get(instance.id);\n    if (!currentInstance) return;\n\n    const newStatus = isHealthy ? 'healthy' : 'unhealthy';\n    const statusChanged = currentInstance.status !== newStatus;\n\n    // Update instance\n    const updatedInstance: ServiceInstance = {\n      ...currentInstance,\n      status: newStatus,\n      lastHealthCheck: new Date(),\n    };\n\n    serviceInstances.set(instance.id, updatedInstance);\n\n    if (statusChanged) {\n      logger.info('Instance health status changed', {\n        instanceId: instance.id,\n        serviceName: instance.name,\n        status: newStatus,\n        endpoint: `${instance.protocol}://${instance.host}:${instance.port}`,\n      });\n    }\n  }\n\n  /**\n   * Start cleanup timer for stale instances\n   */\n  private startCleanupTimer(): void {\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupStaleInstances();\n    }, this.config.cleanupInterval);\n  }\n\n  /**\n   * Clean up stale instances that haven't been health checked recently\n   */\n  private cleanupStaleInstances(): void {\n    const now = Date.now();\n    const staleThreshold = now - this.config.instanceTtl;\n    let cleanedCount = 0;\n\n    for (const [serviceName, instances] of this.services.entries()) {\n      const instancesToRemove: string[] = [];\n\n      for (const [instanceId, instance] of instances.entries()) {\n        if (instance.lastHealthCheck.getTime() < staleThreshold) {\n          instancesToRemove.push(instanceId);\n        }\n      }\n\n      // Remove stale instances\n      for (const instanceId of instancesToRemove) {\n        this.stopHealthCheck(instanceId);\n        instances.delete(instanceId);\n        this.connectionCounts.delete(instanceId);\n        cleanedCount++;\n      }\n\n      // Remove service if no instances left\n      if (instances.size === 0) {\n        this.services.delete(serviceName);\n        this.roundRobinCounters.delete(serviceName);\n      }\n    }\n\n    if (cleanedCount > 0) {\n      logger.info('Cleaned up stale instances', {\n        cleanedCount,\n        remainingServices: this.services.size,\n      });\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\services\\product.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":195,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7828,7831],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7828,7831],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":487,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":487,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19266,19269],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19266,19269],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Product Service - Couche d'intégration avec migration progressive\n * \n * Cette couche utilise les feature flags pour décider entre l'ancien système\n * (productActions) et le nouveau ProductRepository.\n * \n * Pattern \"Strangler Fig\" : remplace progressivement l'ancien code.\n */\n\nimport { Result } from '@/lib/core/result';\nimport { LogUtils } from '@/lib/core/logger';\nimport { isRepositoryEnabled } from '@/lib/config/feature-flags';\nimport { ProductSupabaseRepository } from '@/lib/infrastructure/repositories/product.supabase.repository';\nimport type { \n  IProductRepository,\n  Product,\n  ProductWithTranslations,\n  ProductWithCurrentTranslation,\n  ProductSearchParams,\n  PaginatedProducts,\n  CreateProductData,\n  UpdateProductData,\n  ProductStatus,\n  StockUpdate\n} from '@/lib/domain/interfaces/product.repository.interface';\n\n// Import des anciennes fonctions (fallback)\nimport { \n  createProduct as createProductLegacy, \n  updateProduct as updateProductLegacy,\n  deleteProduct as deleteProductLegacy,\n  updateProductStatus as updateProductStatusLegacy\n} from '@/actions/productActions';\nimport type { ProductFormValues } from '@/lib/validators/product-validator';\n\nexport class ProductService {\n  private repository: IProductRepository;\n\n  constructor() {\n    this.repository = new ProductSupabaseRepository();\n  }\n\n  // === Opérations CRUD principales ===\n\n  /**\n   * Obtenir un produit par slug\n   */\n  async getProductBySlug(slug: string, locale?: string): Promise<Result<ProductWithCurrentTranslation | null, Error>> {\n    const context = LogUtils.createOperationContext('getProductBySlug', 'product-service');\n    LogUtils.logOperationStart('getProductBySlug', { ...context, slug, locale });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('getProductBySlug', 'Using new ProductRepository', context);\n        const result = await this.repository.findBySlug(slug, locale);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('getProductBySlug', { \n            ...context, \n            source: 'repository', \n            found: !!result.getValue() \n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('getProductBySlug', 'Repository failed, falling back to legacy', context);\n      }\n\n      // Fallback vers l'ancien système\n      LogUtils.logOperationInfo('getProductBySlug', 'Using legacy system (not implemented)', context);\n      \n      // TODO: Implémenter fallback vers l'ancien système\n      // Pour l'instant, on retourne une erreur si le repository n'est pas disponible\n      LogUtils.logOperationError('getProductBySlug', 'Legacy fallback not implemented', context);\n      return Result.failure(new Error('Legacy fallback not implemented for getProductBySlug'));\n\n    } catch (error) {\n      LogUtils.logOperationError('getProductBySlug', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Obtenir un produit avec toutes ses traductions\n   */\n  async getProductWithTranslations(productId: string): Promise<Result<ProductWithTranslations | null, Error>> {\n    const context = LogUtils.createOperationContext('getProductWithTranslations', 'product-service');\n    LogUtils.logOperationStart('getProductWithTranslations', { ...context, productId });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('getProductWithTranslations', 'Using new ProductRepository', context);\n        const result = await this.repository.findByIdWithTranslations(productId);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('getProductWithTranslations', { \n            ...context, \n            source: 'repository', \n            found: !!result.getValue(),\n            translationsCount: result.getValue()?.translations?.length || 0\n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('getProductWithTranslations', 'Repository failed, falling back to legacy', context);\n      }\n\n      // Fallback: pas d'équivalent dans l'ancien système\n      LogUtils.logOperationError('getProductWithTranslations', 'Legacy fallback not available', context);\n      return Result.failure(new Error('Legacy fallback not available for getProductWithTranslations'));\n\n    } catch (error) {\n      LogUtils.logOperationError('getProductWithTranslations', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Obtenir les produits actifs avec pagination\n   */\n  async getActiveProducts(params: ProductSearchParams): Promise<Result<PaginatedProducts, Error>> {\n    const context = LogUtils.createOperationContext('getActiveProducts', 'product-service');\n    LogUtils.logOperationStart('getActiveProducts', { ...context, params });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('getActiveProducts', 'Using new ProductRepository', context);\n        const result = await this.repository.findActiveProducts(params);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('getActiveProducts', { \n            ...context, \n            source: 'repository', \n            productsCount: result.getValue()!.products.length,\n            total: result.getValue()!.total\n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('getActiveProducts', 'Repository failed, falling back to legacy', context);\n      }\n\n      // Fallback vers l'ancien système\n      LogUtils.logOperationInfo('getActiveProducts', 'Using legacy system (not implemented)', context);\n      \n      // TODO: Implémenter fallback vers l'ancien système de requête produits\n      LogUtils.logOperationError('getActiveProducts', 'Legacy fallback not implemented', context);\n      return Result.failure(new Error('Legacy fallback not implemented for getActiveProducts'));\n\n    } catch (error) {\n      LogUtils.logOperationError('getActiveProducts', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Obtenir tous les produits (admin)\n   */\n  async getAllProducts(params: ProductSearchParams): Promise<Result<PaginatedProducts, Error>> {\n    const context = LogUtils.createOperationContext('getAllProducts', 'product-service');\n    LogUtils.logOperationStart('getAllProducts', { ...context, params });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('getAllProducts', 'Using new ProductRepository', context);\n        const result = await this.repository.findAllProducts(params);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('getAllProducts', { \n            ...context, \n            source: 'repository', \n            productsCount: result.getValue()!.products.length,\n            total: result.getValue()!.total\n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('getAllProducts', 'Repository failed, falling back to legacy', context);\n      }\n\n      // Fallback vers l'ancien système\n      LogUtils.logOperationInfo('getAllProducts', 'Using legacy system (not implemented)', context);\n      LogUtils.logOperationError('getAllProducts', 'Legacy fallback not implemented', context);\n      return Result.failure(new Error('Legacy fallback not implemented for getAllProducts'));\n\n    } catch (error) {\n      LogUtils.logOperationError('getAllProducts', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Créer un nouveau produit\n   */\n  async createProduct(productData: CreateProductData, translationData?: any): Promise<Result<Product, Error>> {\n    const context = LogUtils.createOperationContext('createProduct', 'product-service');\n    LogUtils.logOperationStart('createProduct', { ...context, slug: productData.slug });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('createProduct', 'Using new ProductRepository', context);\n        \n        // Validation via repository\n        const validationResult = await this.repository.validateProductData(productData);\n        if (!validationResult.isSuccess()) {\n          LogUtils.logOperationError('createProduct', validationResult.getError(), context);\n          return validationResult;\n        }\n\n        const result = await this.repository.createProduct(productData);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('createProduct', { \n            ...context, \n            source: 'repository',\n            productId: result.getValue()!.id\n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('createProduct', 'Repository failed, falling back to legacy', context);\n      }\n\n      // Fallback vers l'ancien système\n      LogUtils.logOperationInfo('createProduct', 'Using legacy productActions', context);\n      \n      // Conversion des données pour le format legacy\n      const legacyData: ProductFormValues = {\n        id: crypto.randomUUID(),\n        slug: productData.slug,\n        price: productData.price,\n        stock: productData.stock,\n        unit: productData.unit,\n        image_url: productData.image_url,\n        inci_list: productData.inci_list,\n        status: productData.status,\n        is_active: productData.is_active,\n        is_new: productData.is_new,\n        is_on_promotion: productData.is_on_promotion,\n        translations: translationData || []\n      };\n\n      const legacyResult = await createProductLegacy(legacyData);\n      \n      if (legacyResult.success && legacyResult.data) {\n        LogUtils.logOperationSuccess('createProduct', { \n          ...context, \n          source: 'legacy' \n        });\n        return Result.success(legacyResult.data as Product);\n      }\n\n      LogUtils.logOperationError('createProduct', 'Legacy createProduct failed', context);\n      return Result.failure(new Error(legacyResult.error || 'Failed to create product via legacy system'));\n\n    } catch (error) {\n      LogUtils.logOperationError('createProduct', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Mettre à jour un produit existant\n   */\n  async updateProduct(productId: string, productData: UpdateProductData): Promise<Result<Product, Error>> {\n    const context = LogUtils.createOperationContext('updateProduct', 'product-service');\n    LogUtils.logOperationStart('updateProduct', { ...context, productId });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('updateProduct', 'Using new ProductRepository', context);\n        \n        // Validation via repository\n        const validationResult = await this.repository.validateProductData(productData);\n        if (!validationResult.isSuccess()) {\n          return validationResult;\n        }\n\n        const result = await this.repository.updateProduct(productId, productData);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('updateProduct', { \n            ...context, \n            source: 'repository' \n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('updateProduct', 'Repository failed, falling back to legacy', context);\n      }\n\n      // Fallback vers l'ancien système\n      LogUtils.logOperationInfo('updateProduct', 'Using legacy productActions', context);\n      \n      // Conversion pour format legacy (partiel)\n      const legacyData: Partial<ProductFormValues> = {\n        slug: productData.slug,\n        price: productData.price,\n        stock: productData.stock,\n        unit: productData.unit,\n        image_url: productData.image_url,\n        inci_list: productData.inci_list,\n        status: productData.status,\n        is_active: productData.is_active,\n        is_new: productData.is_new,\n        is_on_promotion: productData.is_on_promotion,\n      };\n\n      const legacyResult = await updateProductLegacy(productId, legacyData as ProductFormValues);\n      \n      if (legacyResult.success && legacyResult.data) {\n        LogUtils.logOperationSuccess('updateProduct', { \n          ...context, \n          source: 'legacy' \n        });\n        return Result.success(legacyResult.data as Product);\n      }\n\n      LogUtils.logOperationError('updateProduct', 'Legacy updateProduct failed', context);\n      return Result.failure(new Error(legacyResult.error || 'Failed to update product via legacy system'));\n\n    } catch (error) {\n      LogUtils.logOperationError('updateProduct', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Supprimer un produit\n   */\n  async deleteProduct(productId: string): Promise<Result<void, Error>> {\n    const context = LogUtils.createOperationContext('deleteProduct', 'product-service');\n    LogUtils.logOperationStart('deleteProduct', { ...context, productId });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('deleteProduct', 'Using new ProductRepository', context);\n        const result = await this.repository.deleteProduct(productId);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('deleteProduct', { \n            ...context, \n            source: 'repository' \n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('deleteProduct', 'Repository failed, falling back to legacy', context);\n      }\n\n      // Fallback vers l'ancien système\n      LogUtils.logOperationInfo('deleteProduct', 'Using legacy productActions', context);\n      const legacyResult = await deleteProductLegacy({ id: productId });\n      \n      if (legacyResult.success) {\n        LogUtils.logOperationSuccess('deleteProduct', { \n          ...context, \n          source: 'legacy' \n        });\n        return Result.success(undefined);\n      }\n\n      LogUtils.logOperationError('deleteProduct', 'Legacy deleteProduct failed', context);\n      return Result.failure(new Error(legacyResult.error || 'Failed to delete product via legacy system'));\n\n    } catch (error) {\n      LogUtils.logOperationError('deleteProduct', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Mettre à jour le statut d'un produit\n   */\n  async updateProductStatus(productId: string, status: ProductStatus): Promise<Result<Product, Error>> {\n    const context = LogUtils.createOperationContext('updateProductStatus', 'product-service');\n    LogUtils.logOperationStart('updateProductStatus', { ...context, productId, status });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('updateProductStatus', 'Using new ProductRepository', context);\n        const result = await this.repository.updateProductStatus(productId, status);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('updateProductStatus', { \n            ...context, \n            source: 'repository' \n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('updateProductStatus', 'Repository failed, falling back to legacy', context);\n      }\n\n      // Fallback vers l'ancien système\n      LogUtils.logOperationInfo('updateProductStatus', 'Using legacy productActions', context);\n      const legacyResult = await updateProductStatusLegacy({ productId, status });\n      \n      if (legacyResult.success && legacyResult.data) {\n        LogUtils.logOperationSuccess('updateProductStatus', { \n          ...context, \n          source: 'legacy' \n        });\n        return Result.success(legacyResult.data as Product);\n      }\n\n      LogUtils.logOperationError('updateProductStatus', 'Legacy updateProductStatus failed', context);\n      return Result.failure(new Error(legacyResult.error || 'Failed to update product status via legacy system'));\n\n    } catch (error) {\n      LogUtils.logOperationError('updateProductStatus', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  // === Opérations de gestion du stock ===\n\n  /**\n   * Vérifier la disponibilité en stock\n   */\n  async checkStockAvailability(productId: string, requestedQuantity: number): Promise<Result<boolean, Error>> {\n    const context = LogUtils.createOperationContext('checkStockAvailability', 'product-service');\n    LogUtils.logOperationStart('checkStockAvailability', { ...context, productId, requested: requestedQuantity });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('checkStockAvailability', 'Using new ProductRepository', context);\n        const result = await this.repository.checkStockAvailability(productId, requestedQuantity);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('checkStockAvailability', { \n            ...context, \n            source: 'repository',\n            available: result.getValue()\n          });\n          return result;\n        }\n      }\n\n      // Fallback: récupérer le produit et vérifier manuellement\n      LogUtils.logOperationInfo('checkStockAvailability', 'Using fallback check', context);\n      \n      // TODO: Implémenter fallback via récupération produit\n      LogUtils.logOperationError('checkStockAvailability', 'Fallback not implemented', context);\n      return Result.failure(new Error('Fallback not implemented for checkStockAvailability'));\n\n    } catch (error) {\n      LogUtils.logOperationError('checkStockAvailability', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Mettre à jour le stock d'un produit\n   */\n  async updateStock(productId: string, newStock: number): Promise<Result<Product, Error>> {\n    const context = LogUtils.createOperationContext('updateStock', 'product-service');\n    LogUtils.logOperationStart('updateStock', { ...context, productId, newStock });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('updateStock', 'Using new ProductRepository', context);\n        const result = await this.repository.updateStock(productId, newStock);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('updateStock', { \n            ...context, \n            source: 'repository' \n          });\n          return result;\n        }\n      }\n\n      // Fallback: utiliser updateProduct avec seulement le stock\n      LogUtils.logOperationInfo('updateStock', 'Using fallback updateProduct', context);\n      return await this.updateProduct(productId, { stock: newStock });\n\n    } catch (error) {\n      LogUtils.logOperationError('updateStock', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Ajuster le stock avec traçabilité\n   */\n  async adjustStock(update: StockUpdate): Promise<Result<{ product: Product; movement: any }, Error>> {\n    const context = LogUtils.createOperationContext('adjustStock', 'product-service');\n    LogUtils.logOperationStart('adjustStock', { ...context, productId: update.product_id, delta: update.quantity_delta });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('adjustStock', 'Using new ProductRepository', context);\n        const result = await this.repository.adjustStock(update);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('adjustStock', { \n            ...context, \n            source: 'repository' \n          });\n          return result;\n        }\n      }\n\n      // Fallback: ajustement simple sans traçabilité\n      LogUtils.logOperationInfo('adjustStock', 'Using fallback simple adjustment', context);\n      \n      // D'abord récupérer le stock actuel (pas d'équivalent direct dans l'ancien système)\n      LogUtils.logOperationError('adjustStock', 'Fallback not available - complex operation', context);\n      return Result.failure(new Error('Fallback not available for adjustStock - requires repository'));\n\n    } catch (error) {\n      LogUtils.logOperationError('adjustStock', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Réserver du stock\n   */\n  async reserveStock(productId: string, quantity: number, reference: string): Promise<Result<Product, Error>> {\n    const context = LogUtils.createOperationContext('reserveStock', 'product-service');\n    LogUtils.logOperationStart('reserveStock', { ...context, productId, quantity, reference });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('reserveStock', 'Using new ProductRepository', context);\n        const result = await this.repository.reserveStock(productId, quantity, reference);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('reserveStock', { \n            ...context, \n            source: 'repository' \n          });\n          return result;\n        }\n      }\n\n      // Fallback: utiliser adjustStock\n      LogUtils.logOperationInfo('reserveStock', 'Using fallback adjustStock', context);\n      const adjustResult = await this.adjustStock({\n        product_id: productId,\n        quantity_delta: -quantity,\n        reason: 'sale',\n        reference,\n      });\n\n      if (adjustResult.isSuccess()) {\n        return Result.success(adjustResult.getValue()!.product);\n      }\n\n      return adjustResult;\n\n    } catch (error) {\n      LogUtils.logOperationError('reserveStock', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Libérer du stock réservé\n   */\n  async releaseStock(productId: string, quantity: number, reference: string): Promise<Result<Product, Error>> {\n    const context = LogUtils.createOperationContext('releaseStock', 'product-service');\n    LogUtils.logOperationStart('releaseStock', { ...context, productId, quantity, reference });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('releaseStock', 'Using new ProductRepository', context);\n        const result = await this.repository.releaseStock(productId, quantity, reference);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('releaseStock', { \n            ...context, \n            source: 'repository' \n          });\n          return result;\n        }\n      }\n\n      // Fallback: utiliser adjustStock\n      LogUtils.logOperationInfo('releaseStock', 'Using fallback adjustStock', context);\n      const adjustResult = await this.adjustStock({\n        product_id: productId,\n        quantity_delta: quantity,\n        reason: 'return',\n        reference,\n      });\n\n      if (adjustResult.isSuccess()) {\n        return Result.success(adjustResult.getValue()!.product);\n      }\n\n      return adjustResult;\n\n    } catch (error) {\n      LogUtils.logOperationError('releaseStock', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  // === Opérations de validation ===\n\n  /**\n   * Valider les données d'un produit\n   */\n  async validateProduct(productData: CreateProductData | UpdateProductData): Promise<Result<void, Error>> {\n    const context = LogUtils.createOperationContext('validateProduct', 'product-service');\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('validateProduct', 'Using new ProductRepository', context);\n        return await this.repository.validateProductData(productData);\n      }\n\n      // Fallback: validation basique\n      LogUtils.logOperationInfo('validateProduct', 'Using basic validation', context);\n      \n      if ('price' in productData && productData.price !== undefined && productData.price < 0) {\n        return Result.failure(new Error('Price cannot be negative'));\n      }\n\n      if ('stock' in productData && productData.stock !== undefined && productData.stock < 0) {\n        return Result.failure(new Error('Stock cannot be negative'));\n      }\n\n      LogUtils.logOperationSuccess('validateProduct', { ...context, source: 'basic' });\n      return Result.success(undefined);\n\n    } catch (error) {\n      LogUtils.logOperationError('validateProduct', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Vérifier la disponibilité d'un slug\n   */\n  async isSlugAvailable(slug: string, excludeProductId?: string): Promise<Result<boolean, Error>> {\n    const context = LogUtils.createOperationContext('isSlugAvailable', 'product-service');\n    LogUtils.logOperationStart('isSlugAvailable', { ...context, slug, excludeProductId });\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('isSlugAvailable', 'Using new ProductRepository', context);\n        return await this.repository.isSlugAvailable(slug, excludeProductId);\n      }\n\n      // Fallback: pas d'équivalent simple dans l'ancien système\n      LogUtils.logOperationError('isSlugAvailable', 'Fallback not available', context);\n      return Result.failure(new Error('Fallback not available for isSlugAvailable'));\n\n    } catch (error) {\n      LogUtils.logOperationError('isSlugAvailable', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  // === Opérations de cache ===\n\n  /**\n   * Précharger les produits populaires en cache\n   */\n  async cachePopularProducts(locale?: string): Promise<Result<void, Error>> {\n    const context = LogUtils.createOperationContext('cachePopularProducts', 'product-service');\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('cachePopularProducts', 'Using new ProductRepository', context);\n        return await this.repository.cachePopularProducts(locale);\n      }\n\n      // Fallback: pas de cache dans l'ancien système\n      LogUtils.logOperationSuccess('cachePopularProducts', { ...context, source: 'noop' });\n      return Result.success(undefined);\n\n    } catch (error) {\n      LogUtils.logOperationError('cachePopularProducts', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Invalider le cache pour un produit\n   */\n  async invalidateProductCache(productId: string): Promise<Result<void, Error>> {\n    const context = LogUtils.createOperationContext('invalidateProductCache', 'product-service');\n\n    try {\n      if (isRepositoryEnabled('USE_PRODUCT_REPOSITORY')) {\n        LogUtils.logOperationInfo('invalidateProductCache', 'Using new ProductRepository', context);\n        return await this.repository.invalidateProductCache(productId);\n      }\n\n      // Fallback: pas de cache dans l'ancien système\n      LogUtils.logOperationSuccess('invalidateProductCache', { ...context, source: 'noop' });\n      return Result.success(undefined);\n\n    } catch (error) {\n      LogUtils.logOperationError('invalidateProductCache', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n}\n\n// Instance singleton pour utilisation dans l'application\nexport const productService = new ProductService();","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\services\\user.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'User' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UserWithProfile' is defined but never used. Allowed unused vars must match /^_/u.","line":18,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":187,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":187,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6993,6996],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6993,6996],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'total' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":332,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":332,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * User Service - Couche d'intégration avec migration progressive\n * \n * Cette couche utilise les feature flags pour décider entre l'ancien système\n * (profileActions/userActions) et le nouveau UserRepository.\n * \n * Pattern \"Strangler Fig\" : remplace progressivement l'ancien code.\n */\n\nimport { Result } from '@/lib/core/result';\nimport { LogUtils } from '@/lib/core/logger';\nimport { isRepositoryEnabled } from '@/lib/config/feature-flags';\nimport { UserSupabaseRepository } from '@/lib/infrastructure/repositories/user.supabase.repository';\nimport type { \n  IUserRepository,\n  User,\n  Profile,\n  UserWithProfile,\n  CreateProfileData,\n  UpdateProfileData,\n  AdminUserData\n} from '@/lib/domain/interfaces/user.repository.interface';\n\n// Import des anciennes fonctions (fallback)\nimport { getProfile } from '@/actions/profileActions';\nimport { getAllUsers, updateUserRole } from '@/actions/userActions';\n\nexport class UserService {\n  private repository: IUserRepository;\n\n  constructor() {\n    this.repository = new UserSupabaseRepository();\n  }\n\n  // === Opérations Profile ===\n\n  /**\n   * Obtenir le profil d'un utilisateur\n   * Utilise le nouveau repository si activé, sinon fallback vers profileActions\n   */\n  async getUserProfile(userId: string): Promise<Result<Profile | null, Error>> {\n    const context = LogUtils.createOperationContext('getUserProfile', 'user-service');\n    LogUtils.logOperationStart('getUserProfile', { ...context, userId });\n\n    try {\n      if (isRepositoryEnabled('USE_USER_REPOSITORY')) {\n        LogUtils.logOperationInfo('getUserProfile', 'Using new UserRepository', context);\n        const result = await this.repository.findProfileByUserId(userId);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('getUserProfile', { \n            ...context, \n            source: 'repository', \n            found: !!result.getValue() \n          });\n          return result;\n        }\n\n        // Si le repository échoue, fallback vers l'ancien système\n        LogUtils.logOperationWarning('getUserProfile', 'Repository failed, falling back to legacy', context);\n      }\n\n      // Fallback vers l'ancien système\n      LogUtils.logOperationInfo('getUserProfile', 'Using legacy profileActions', context);\n      const legacyResult = await getProfile();\n      \n      if (legacyResult.success && legacyResult.data) {\n        LogUtils.logOperationSuccess('getUserProfile', { \n          ...context, \n          source: 'legacy', \n          found: true \n        });\n        return Result.success(legacyResult.data);\n      }\n\n      LogUtils.logOperationSuccess('getUserProfile', { \n        ...context, \n        source: 'legacy', \n        found: false \n      });\n      return Result.success(null);\n\n    } catch (error) {\n      LogUtils.logOperationError('getUserProfile', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Mettre à jour le profil d'un utilisateur\n   */\n  async updateUserProfile(userId: string, profileData: UpdateProfileData): Promise<Result<Profile, Error>> {\n    const context = LogUtils.createOperationContext('updateUserProfile', 'user-service');\n    LogUtils.logOperationStart('updateUserProfile', { ...context, userId });\n\n    try {\n      if (isRepositoryEnabled('USE_USER_REPOSITORY')) {\n        LogUtils.logOperationInfo('updateUserProfile', 'Using new UserRepository', context);\n        const result = await this.repository.updateProfile(userId, profileData);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('updateUserProfile', { \n            ...context, \n            source: 'repository' \n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('updateUserProfile', 'Repository failed, falling back to legacy', context);\n      }\n\n      // TODO: Implémenter fallback vers profileActions\n      // Pour l'instant, on retourne une erreur si le repository n'est pas disponible\n      LogUtils.logOperationError('updateUserProfile', 'Legacy fallback not implemented', context);\n      return Result.failure(new Error('Legacy fallback not implemented for updateUserProfile'));\n\n    } catch (error) {\n      LogUtils.logOperationError('updateUserProfile', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Créer un profil pour un utilisateur\n   */\n  async createUserProfile(userId: string, profileData: CreateProfileData): Promise<Result<Profile, Error>> {\n    const context = LogUtils.createOperationContext('createUserProfile', 'user-service');\n    LogUtils.logOperationStart('createUserProfile', { ...context, userId });\n\n    try {\n      if (isRepositoryEnabled('USE_USER_REPOSITORY')) {\n        LogUtils.logOperationInfo('createUserProfile', 'Using new UserRepository', context);\n        const result = await this.repository.createProfile(userId, profileData);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('createUserProfile', { \n            ...context, \n            source: 'repository' \n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('createUserProfile', 'Repository failed, falling back to legacy', context);\n      }\n\n      // TODO: Implémenter fallback vers profileActions\n      LogUtils.logOperationError('createUserProfile', 'Legacy fallback not implemented', context);\n      return Result.failure(new Error('Legacy fallback not implemented for createUserProfile'));\n\n    } catch (error) {\n      LogUtils.logOperationError('createUserProfile', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  // === Opérations Admin ===\n\n  /**\n   * Obtenir tous les utilisateurs (pour admin)\n   */\n  async getAllUsers(page = 1, limit = 20): Promise<Result<{ users: AdminUserData[]; total: number }, Error>> {\n    const context = LogUtils.createOperationContext('getAllUsers', 'user-service');\n    LogUtils.logOperationStart('getAllUsers', { ...context, page, limit });\n\n    try {\n      if (isRepositoryEnabled('USE_USER_REPOSITORY')) {\n        LogUtils.logOperationInfo('getAllUsers', 'Using new UserRepository', context);\n        const result = await this.repository.findAllWithProfiles(page, limit);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('getAllUsers', { \n            ...context, \n            source: 'repository',\n            count: result.getValue()!.users.length\n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('getAllUsers', 'Repository failed, falling back to legacy', context);\n      }\n\n      // Fallback vers l'ancien système\n      LogUtils.logOperationInfo('getAllUsers', 'Using legacy userActions', context);\n      const legacyResult = await getAllUsers();\n      \n      if (legacyResult.success && legacyResult.data) {\n        const users = legacyResult.data.map((user: any) => ({\n          id: user.id,\n          email: user.email,\n          created_at: user.created_at,\n          last_sign_in_at: user.last_sign_in_at,\n          profile: user.profile || {\n            id: '',\n            user_id: user.id,\n            first_name: null,\n            last_name: null,\n            phone: null,\n            avatar_url: null,\n            is_admin: false,\n            marketing_consent: false,\n            created_at: user.created_at,\n            updated_at: user.created_at,\n          }\n        }));\n\n        LogUtils.logOperationSuccess('getAllUsers', { \n          ...context, \n          source: 'legacy',\n          count: users.length\n        });\n        return Result.success({ users, total: users.length });\n      }\n\n      LogUtils.logOperationError('getAllUsers', 'Legacy getAllUsers failed', context);\n      return Result.failure(new Error('Failed to get users from legacy system'));\n\n    } catch (error) {\n      LogUtils.logOperationError('getAllUsers', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Vérifier les droits admin d'un utilisateur\n   */\n  async checkAdminRole(userId: string): Promise<Result<boolean, Error>> {\n    const context = LogUtils.createOperationContext('checkAdminRole', 'user-service');\n    LogUtils.logOperationStart('checkAdminRole', { ...context, userId });\n\n    try {\n      if (isRepositoryEnabled('USE_USER_REPOSITORY')) {\n        LogUtils.logOperationInfo('checkAdminRole', 'Using new UserRepository', context);\n        const result = await this.repository.checkAdminRole(userId);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('checkAdminRole', { \n            ...context, \n            source: 'repository',\n            isAdmin: result.getValue()\n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('checkAdminRole', 'Repository failed, falling back to legacy', context);\n      }\n\n      // TODO: Implémenter fallback vers userActions/checkAdminRole\n      LogUtils.logOperationError('checkAdminRole', 'Legacy fallback not implemented', context);\n      return Result.failure(new Error('Legacy fallback not implemented for checkAdminRole'));\n\n    } catch (error) {\n      LogUtils.logOperationError('checkAdminRole', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  /**\n   * Mettre à jour le statut admin d'un utilisateur\n   */\n  async updateAdminStatus(userId: string, isAdmin: boolean): Promise<Result<Profile, Error>> {\n    const context = LogUtils.createOperationContext('updateAdminStatus', 'user-service');\n    LogUtils.logOperationStart('updateAdminStatus', { ...context, userId, isAdmin });\n\n    try {\n      if (isRepositoryEnabled('USE_USER_REPOSITORY')) {\n        LogUtils.logOperationInfo('updateAdminStatus', 'Using new UserRepository', context);\n        const result = await this.repository.updateAdminStatus(userId, isAdmin);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('updateAdminStatus', { \n            ...context, \n            source: 'repository' \n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('updateAdminStatus', 'Repository failed, falling back to legacy', context);\n      }\n\n      // Fallback vers l'ancien système\n      LogUtils.logOperationInfo('updateAdminStatus', 'Using legacy userActions', context);\n      const legacyResult = await updateUserRole(userId, isAdmin);\n      \n      if (legacyResult.success && legacyResult.data) {\n        LogUtils.logOperationSuccess('updateAdminStatus', { \n          ...context, \n          source: 'legacy' \n        });\n        return Result.success(legacyResult.data);\n      }\n\n      LogUtils.logOperationError('updateAdminStatus', 'Legacy updateUserRole failed', context);\n      return Result.failure(new Error('Failed to update admin status via legacy system'));\n\n    } catch (error) {\n      LogUtils.logOperationError('updateAdminStatus', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n\n  // === Opérations de recherche ===\n\n  /**\n   * Rechercher des utilisateurs\n   */\n  async searchUsers(searchTerm: string, page = 1, limit = 20): Promise<Result<{ users: AdminUserData[]; total: number }, Error>> {\n    const context = LogUtils.createOperationContext('searchUsers', 'user-service');\n    LogUtils.logOperationStart('searchUsers', { ...context, searchTerm, page, limit });\n\n    try {\n      if (isRepositoryEnabled('USE_USER_REPOSITORY')) {\n        LogUtils.logOperationInfo('searchUsers', 'Using new UserRepository', context);\n        const result = await this.repository.searchUsers(searchTerm, page, limit);\n        \n        if (result.isSuccess()) {\n          LogUtils.logOperationSuccess('searchUsers', { \n            ...context, \n            source: 'repository',\n            count: result.getValue()!.users.length\n          });\n          return result;\n        }\n\n        LogUtils.logOperationWarning('searchUsers', 'Repository failed, falling back to legacy', context);\n      }\n\n      // Fallback: utiliser getAllUsers et filtrer côté client (simple)\n      LogUtils.logOperationInfo('searchUsers', 'Using legacy fallback with client-side filtering', context);\n      const allUsersResult = await this.getAllUsers(page, limit);\n      \n      if (allUsersResult.isSuccess()) {\n        const { users, total } = allUsersResult.getValue()!;\n        const filteredUsers = users.filter(user => \n          user.email.toLowerCase().includes(searchTerm.toLowerCase()) ||\n          user.profile.first_name?.toLowerCase().includes(searchTerm.toLowerCase()) ||\n          user.profile.last_name?.toLowerCase().includes(searchTerm.toLowerCase())\n        );\n\n        LogUtils.logOperationSuccess('searchUsers', { \n          ...context, \n          source: 'legacy-filtered',\n          count: filteredUsers.length\n        });\n        return Result.success({ users: filteredUsers, total: filteredUsers.length });\n      }\n\n      return allUsersResult;\n\n    } catch (error) {\n      LogUtils.logOperationError('searchUsers', error, context);\n      return Result.failure(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n}\n\n// Instance singleton pour utilisation dans l'application\nexport const userService = new UserService();","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\validators\\cart-validation-coordinator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AddToCartFormData' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AddToCartJson' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RemoveFromCartFormData' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UpdateQuantityFormData' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MigrateCartJson' is defined but never used. Allowed unused vars must match /^_/u.","line":18,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userContext' is defined but never used. Allowed unused args must match /^_/u.","line":241,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":241,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":242,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6951,6954],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6951,6954],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":243,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6997,7000],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6997,7000],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":246,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":246,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7108,7111],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7108,7111],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'maxOperationsPerMinute' is assigned a value but never used. Allowed unused args must match /^_/u.","line":317,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":317,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Cart Validation Coordinator\n * \n * This module coordinates between API-level and Domain-level validation,\n * providing a unified interface for cart operations validation.\n */\n\nimport { Result } from \"@/lib/core/result\";\nimport { ValidationError, BusinessError } from \"@/lib/core/errors\";\n\n// API Layer\nimport {\n  CartApiValidator,\n  type AddToCartFormData,\n  type AddToCartJson,\n  type RemoveFromCartFormData,\n  type UpdateQuantityFormData,\n  type MigrateCartJson,\n} from \"./api/cart-api.validator\";\n\n// Domain Layer\nimport {\n  CartDomainValidator,\n  type AddItemToCartDomain,\n  type RemoveItemFromCartDomain,\n  type UpdateCartItemQuantityDomain,\n  type MigrateCartDomain,\n} from \"./domain/cart-domain.validator\";\n\n/**\n * Validation pipeline result\n */\nexport type ValidationPipelineResult<T> = Result<T, ValidationError | BusinessError>;\n\n/**\n * Product details interface for enriching validation\n */\nexport interface ProductDetails {\n  id: string;\n  name: string;\n  price: number;\n  stock: number;\n  image?: string;\n  slug?: string;\n  isActive: boolean;\n}\n\n/**\n * User context for validation\n */\nexport interface UserContext {\n  id: string;\n  role: string;\n  isAuthenticated: boolean;\n}\n\n/**\n * Cart validation coordinator\n */\nexport class CartValidationCoordinator {\n  /**\n   * Validates add to cart operation through full pipeline\n   */\n  static async validateAddToCart(\n    formData: FormData,\n    userContext: UserContext,\n    productDetails: ProductDetails\n  ): Promise<ValidationPipelineResult<AddItemToCartDomain>> {\n    // Step 1: API-level validation\n    const apiValidationResult = CartApiValidator.validateAddToCartFormData(formData);\n    if (apiValidationResult.isError()) {\n      return Result.error(apiValidationResult.getError());\n    }\n    \n    const apiData = apiValidationResult.getValue();\n\n    // Step 2: Enrich with domain context\n    const domainData: AddItemToCartDomain = {\n      userId: userContext.id,\n      productId: apiData.productId,\n      quantity: apiData.quantity,\n      productDetails: {\n        name: productDetails.name,\n        price: productDetails.price,\n        stock: productDetails.stock,\n        image: productDetails.image,\n        slug: productDetails.slug,\n      },\n    };\n\n    // Step 3: Business rules validation\n    if (!productDetails.isActive) {\n      return Result.error(new BusinessError('Produit non disponible à la vente'));\n    }\n\n    // Step 4: Domain-level validation\n    const domainValidationResult = CartDomainValidator.validateAddItem(domainData);\n    if (domainValidationResult.isError()) {\n      return Result.error(domainValidationResult.getError());\n    }\n\n    return Result.ok(domainValidationResult.getValue());\n  }\n\n  /**\n   * Validates add to cart from JSON input\n   */\n  static async validateAddToCartJson(\n    jsonData: unknown,\n    userContext: UserContext,\n    productDetails: ProductDetails\n  ): Promise<ValidationPipelineResult<AddItemToCartDomain>> {\n    // Step 1: API-level validation\n    const apiValidationResult = CartApiValidator.validateAddToCartJson(jsonData);\n    if (apiValidationResult.isError()) {\n      return Result.error(apiValidationResult.getError());\n    }\n    \n    const apiData = apiValidationResult.getValue();\n\n    // Step 2: Enrich with domain context\n    const domainData: AddItemToCartDomain = {\n      userId: userContext.id,\n      productId: apiData.productId,\n      quantity: apiData.quantity,\n      productDetails: {\n        name: productDetails.name,\n        price: productDetails.price,\n        stock: productDetails.stock,\n        image: productDetails.image,\n        slug: productDetails.slug,\n      },\n    };\n\n    // Step 3: Business rules validation\n    if (!productDetails.isActive) {\n      return Result.error(new BusinessError('Produit non disponible à la vente'));\n    }\n\n    // Step 4: Domain-level validation\n    return CartDomainValidator.validateAddItem(domainData);\n  }\n\n  /**\n   * Validates remove from cart operation\n   */\n  static async validateRemoveFromCart(\n    formData: FormData,\n    userContext: UserContext\n  ): Promise<ValidationPipelineResult<RemoveItemFromCartDomain>> {\n    // Step 1: API-level validation\n    const apiValidationResult = CartApiValidator.validateRemoveFromCartFormData(formData);\n    if (apiValidationResult.isError()) {\n      return Result.error(apiValidationResult.getError());\n    }\n    \n    const apiData = apiValidationResult.getValue();\n\n    // Step 2: Create domain data\n    const domainData: RemoveItemFromCartDomain = {\n      userId: userContext.id,\n      cartItemId: apiData.cartItemId,\n    };\n\n    // Step 3: Domain-level validation\n    return CartDomainValidator.validateRemoveItem(domainData);\n  }\n\n  /**\n   * Validates update quantity operation\n   */\n  static async validateUpdateQuantity(\n    formData: FormData,\n    userContext: UserContext,\n    availableStock?: number\n  ): Promise<ValidationPipelineResult<UpdateCartItemQuantityDomain>> {\n    // Step 1: API-level validation\n    const apiValidationResult = CartApiValidator.validateUpdateQuantityFormData(formData);\n    if (apiValidationResult.isError()) {\n      return Result.error(apiValidationResult.getError());\n    }\n    \n    const apiData = apiValidationResult.getValue();\n\n    // Step 2: Create domain data\n    const domainData: UpdateCartItemQuantityDomain = {\n      userId: userContext.id,\n      cartItemId: apiData.cartItemId,\n      quantity: apiData.quantity,\n    };\n\n    // Step 3: Stock validation if provided\n    if (availableStock !== undefined) {\n      const stockValidationResult = CartDomainValidator.validateQuantityUpdate(\n        0, // We don't have current quantity in this context\n        apiData.quantity,\n        availableStock\n      );\n      if (stockValidationResult.isError()) {\n        return Result.error(stockValidationResult.getError());\n      }\n    }\n\n    // Step 4: Domain-level validation\n    return CartDomainValidator.validateUpdateQuantity(domainData);\n  }\n\n  /**\n   * Validates cart migration operation\n   */\n  static async validateMigrateCart(\n    jsonData: unknown,\n    authenticatedUserId: string\n  ): Promise<ValidationPipelineResult<MigrateCartDomain>> {\n    // Step 1: API-level validation\n    const apiValidationResult = CartApiValidator.validateMigrateCartJson(jsonData);\n    if (apiValidationResult.isError()) {\n      return Result.error(apiValidationResult.getError());\n    }\n    \n    const apiData = apiValidationResult.getValue();\n\n    // Step 2: Create domain data\n    const domainData: MigrateCartDomain = {\n      fromUserId: apiData.guestUserId,\n      toUserId: authenticatedUserId,\n    };\n\n    // Step 3: Domain-level validation\n    return CartDomainValidator.validateMigration(domainData);\n  }\n\n  /**\n   * Validates batch operations (for future use)\n   */\n  static async validateBatchCartOperations(\n    operations: Array<{\n      type: 'add' | 'remove' | 'update';\n      data: unknown;\n    }>,\n    userContext: UserContext\n  ): Promise<ValidationPipelineResult<Array<any>>> {\n    const validatedOperations: Array<any> = [];\n    \n    for (const operation of operations) {\n      let validationResult: ValidationPipelineResult<any>;\n      \n      switch (operation.type) {\n        case 'add':\n          // Would need product details - simplified for now\n          validationResult = Result.error(new BusinessError('Batch add not implemented'));\n          break;\n        case 'remove':\n          // Would need to convert data to FormData - simplified for now\n          validationResult = Result.error(new BusinessError('Batch remove not implemented'));\n          break;\n        case 'update':\n          // Would need to convert data to FormData - simplified for now\n          validationResult = Result.error(new BusinessError('Batch update not implemented'));\n          break;\n        default:\n          validationResult = Result.error(new ValidationError('Type d\\'opération inconnue'));\n      }\n      \n      if (validationResult.isError()) {\n        return Result.error(validationResult.getError());\n      }\n      \n      validatedOperations.push(validationResult.getValue());\n    }\n    \n    return Result.ok(validatedOperations);\n  }\n}\n\n/**\n * Utility functions for common validation scenarios\n */\nexport const CartValidationUtils = {\n  /**\n   * Validates user permission for cart operation\n   */\n  validateUserPermission: (\n    userContext: UserContext,\n    requiredRole?: string\n  ): Result<boolean, ValidationError> => {\n    if (!userContext.isAuthenticated) {\n      return Result.error(new ValidationError('Authentification requise'));\n    }\n    \n    if (requiredRole && userContext.role !== requiredRole) {\n      return Result.error(new ValidationError(`Rôle ${requiredRole} requis`));\n    }\n    \n    return Result.ok(true);\n  },\n\n  /**\n   * Creates user context from session data\n   */\n  createUserContext: (\n    userId: string | null,\n    userRole: string | null,\n    isAuthenticated: boolean\n  ): UserContext => ({\n    id: userId || '',\n    role: userRole || 'user',\n    isAuthenticated,\n  }),\n\n  /**\n   * Validates operation rate limiting\n   */\n  validateRateLimit: (\n    userContext: UserContext,\n    operation: string,\n    maxOperationsPerMinute: number = 60\n  ): Result<boolean, ValidationError> => {\n    // This would integrate with a rate limiting service\n    // For now, we'll return OK\n    return Result.ok(true);\n  },\n\n  /**\n   * Validates cart state constraints\n   */\n  validateCartConstraints: (\n    currentItemCount: number,\n    currentTotalQuantity: number,\n    operation: 'add' | 'update',\n    quantityChange: number = 0\n  ): Result<boolean, BusinessError> => {\n    const MAX_ITEMS = 50;\n    const MAX_TOTAL_QUANTITY = 500;\n    \n    if (operation === 'add' && currentItemCount >= MAX_ITEMS) {\n      return Result.error(new BusinessError(`Maximum ${MAX_ITEMS} articles différents autorisés`));\n    }\n    \n    const newTotalQuantity = currentTotalQuantity + quantityChange;\n    if (newTotalQuantity > MAX_TOTAL_QUANTITY) {\n      return Result.error(new BusinessError(`Quantité totale maximum: ${MAX_TOTAL_QUANTITY}`));\n    }\n    \n    return Result.ok(true);\n  },\n};","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\lib\\validators\\market.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":257,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8782,8785],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8782,8785],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Market Validation Schemas\n * \n * Zod schemas for validating market data in forms and server actions.\n */\n\nimport { z } from \"zod\";\n\n// Time format validation (HH:MM or HH:MM:SS)\nconst timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/;\n\n// Date format validation (YYYY-MM-DD)\nconst dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n\n// URL validation that allows empty strings\nconst optionalUrlSchema = z.string()\n  .optional()\n  .refine((val) => !val || z.string().url().safeParse(val).success, {\n    message: \"URL invalide\"\n  });\n\n// Base market object schema (without validation refines)\nconst baseMarketSchema = z.object({\n  name: z.string()\n    .min(1, \"Le nom est requis\")\n    .max(100, \"Le nom ne peut pas dépasser 100 caractères\"),\n  \n  start_date: z.string()\n    .regex(dateRegex, \"Format de date invalide (YYYY-MM-DD requis)\")\n    .refine((date) => {\n      const parsed = new Date(date);\n      return !isNaN(parsed.getTime());\n    }, \"Date de début invalide\"),\n  \n  end_date: z.string()\n    .regex(dateRegex, \"Format de date invalide (YYYY-MM-DD requis)\"),\n  \n  day_of_week: z.number()\n    .int(\"Le jour de la semaine doit être un entier\")\n    .min(0, \"Le jour de la semaine doit être entre 0 et 6\")\n    .max(6, \"Le jour de la semaine doit être entre 0 et 6\"),\n  \n  start_time: z.string()\n    .regex(timeRegex, \"Format d'heure invalide (HH:MM requis)\")\n    .transform((time) => time.substring(0, 5)), // Convert HH:MM:SS to HH:MM\n  \n  end_time: z.string()\n    .regex(timeRegex, \"Format d'heure invalide (HH:MM requis)\")\n    .transform((time) => time.substring(0, 5)), // Convert HH:MM:SS to HH:MM\n  \n  city: z.string()\n    .min(1, \"La ville est requise\")\n    .max(100, \"La ville ne peut pas dépasser 100 caractères\"),\n  \n  address: z.string()\n    .min(1, \"L'adresse est requise\")\n    .max(200, \"L'adresse ne peut pas dépasser 200 caractères\"),\n  \n  description: z.string()\n    .max(500, \"La description ne peut pas dépasser 500 caractères\")\n    .optional(),\n  \n  gps_link: optionalUrlSchema,\n  \n  hero_image_url: z.string()\n    .max(500, \"L'URL de l'image hero ne peut pas dépasser 500 caractères\")\n    .optional(),\n  \n  image_url: z.string()\n    .max(500, \"L'URL de l'image ne peut pas dépasser 500 caractères\")\n    .optional(),\n\n  is_active: z.boolean()\n    .optional()\n    .default(true),\n});\n\n// Schema for creating markets (server actions) - includes future date validation\nexport const createMarketSchema = baseMarketSchema.refine((data) => {\n  // Validate that start_date is in the future for new markets\n  const startDate = new Date(data.start_date);\n  const today = new Date(new Date().setHours(0, 0, 0, 0));\n  return startDate >= today;\n}, {\n  message: \"La date de début doit être dans le futur\",\n  path: [\"start_date\"]\n}).refine((data) => {\n  // Validate that end_date is after start_date\n  const startDate = new Date(data.start_date);\n  const endDate = new Date(data.end_date);\n  return endDate >= startDate;\n}, {\n  message: \"La date de fin doit être postérieure ou égale à la date de début\",\n  path: [\"end_date\"]\n}).refine((data) => {\n  // Validate that end_time is after start_time (handle overnight markets)\n  const [startHour, startMinute] = data.start_time.split(':').map(Number);\n  const [endHour, endMinute] = data.end_time.split(':').map(Number);\n  const startMinutes = startHour * 60 + startMinute;\n  let endMinutes = endHour * 60 + endMinute;\n  \n  // Handle overnight markets: if end_time is before start_time, assume next day\n  if (endMinutes <= startMinutes) {\n    endMinutes += 24 * 60; // Add 24 hours (next day)\n  }\n  \n  return endMinutes > startMinutes;\n}, {\n  message: \"L'heure de fin doit être postérieure à l'heure de début\",\n  path: [\"end_time\"]\n});\n\n// Base market schema for general use (legacy compatibility)\nexport const marketSchema = createMarketSchema;\n\n// Schema for updating markets (all fields optional, with ID required)\nexport const updateMarketSchema = z.object({\n  id: z.string().uuid(\"ID de marché invalide\"),\n  \n  name: z.string()\n    .min(1, \"Le nom est requis\")\n    .max(100, \"Le nom ne peut pas dépasser 100 caractères\")\n    .optional(),\n  \n  start_date: z.string()\n    .regex(dateRegex, \"Format de date invalide (YYYY-MM-DD requis)\")\n    .refine((date) => {\n      const parsed = new Date(date);\n      return !isNaN(parsed.getTime());\n    }, \"Date de début invalide\")\n    .optional(),\n  \n  end_date: z.string()\n    .regex(dateRegex, \"Format de date invalide (YYYY-MM-DD requis)\")\n    .optional(),\n  \n  day_of_week: z.number()\n    .int(\"Le jour de la semaine doit être un entier\")\n    .min(0, \"Le jour de la semaine doit être entre 0 et 6\")\n    .max(6, \"Le jour de la semaine doit être entre 0 et 6\")\n    .optional(),\n  \n  start_time: z.string()\n    .regex(timeRegex, \"Format d'heure invalide (HH:MM requis)\")\n    .transform((time) => time.substring(0, 5)) // Convert HH:MM:SS to HH:MM\n    .optional(),\n  \n  end_time: z.string()\n    .regex(timeRegex, \"Format d'heure invalide (HH:MM requis)\")\n    .transform((time) => time.substring(0, 5)) // Convert HH:MM:SS to HH:MM\n    .optional(),\n  \n  city: z.string()\n    .min(1, \"La ville est requise\")\n    .max(100, \"La ville ne peut pas dépasser 100 caractères\")\n    .optional(),\n  \n  address: z.string()\n    .min(1, \"L'adresse est requise\")\n    .max(200, \"L'adresse ne peut pas dépasser 200 caractères\")\n    .optional(),\n  \n  description: z.string()\n    .max(500, \"La description ne peut pas dépasser 500 caractères\")\n    .optional(),\n  \n  gps_link: optionalUrlSchema,\n  \n  hero_image_url: z.string()\n    .max(500, \"L'URL de l'image hero ne peut pas dépasser 500 caractères\")\n    .optional(),\n  \n  image_url: z.string()\n    .max(500, \"L'URL de l'image ne peut pas dépasser 500 caractères\")\n    .optional(),\n\n  is_active: z.boolean()\n    .optional(),\n}).refine((data) => {\n  // Only validate dates if both are provided\n  if (data.start_date && data.end_date) {\n    const startDate = new Date(data.start_date);\n    const endDate = new Date(data.end_date);\n    return endDate >= startDate;\n  }\n  return true;\n}, {\n  message: \"La date de fin doit être postérieure ou égale à la date de début\",\n  path: [\"end_date\"]\n}).refine((data) => {\n  // Only validate times if both are provided\n  if (data.start_time && data.end_time) {\n    const [startHour, startMinute] = data.start_time.split(':').map(Number);\n    const [endHour, endMinute] = data.end_time.split(':').map(Number);\n    const startMinutes = startHour * 60 + startMinute;\n    let endMinutes = endHour * 60 + endMinute;\n    \n    // Handle overnight markets: if end_time is before start_time, assume next day\n    if (endMinutes <= startMinutes) {\n      endMinutes += 24 * 60; // Add 24 hours (next day)\n    }\n    \n    return endMinutes > startMinutes;\n  }\n  return true;\n}, {\n  message: \"L'heure de fin doit être postérieure à l'heure de début\",\n  path: [\"end_time\"]\n});\n\n// Schema for market form data (handles string inputs from forms) - for creation\nexport const marketFormSchema = z.object({\n  name: z.string().min(1, \"Le nom est requis\"),\n  start_date: z.string().min(1, \"La date de début est requise\"),\n  end_date: z.string().min(1, \"La date de fin est requise\"),\n  day_of_week: z.string().transform((val) => parseInt(val, 10)),\n  start_time: z.string().min(1, \"L'heure de début est requise\"),\n  end_time: z.string().min(1, \"L'heure de fin est requise\"),\n  city: z.string().min(1, \"La ville est requise\"),\n  address: z.string().min(1, \"L'adresse est requise\"),\n  description: z.string().optional(),\n  gps_link: z.string().optional(),\n  hero_image_url: z.string().optional(),\n  image_url: z.string().optional(),\n  is_active: z.string()\n    .optional()\n    .default('true')\n    .transform((val) => val === 'true' || val === 'on'),\n}).transform((data) => ({\n  ...data,\n  // Clean up optional string fields (convert empty strings to undefined)\n  address: data.address?.trim(), // Required field, don't convert to undefined\n  description: data.description?.trim() || undefined,\n  gps_link: data.gps_link?.trim() || undefined,\n  hero_image_url: data.hero_image_url?.trim() || undefined,\n  image_url: data.image_url?.trim() || undefined,\n}));\n\n// Schema for market update form data (handles string inputs from forms) - for updates\nexport const updateMarketFormSchema = z.object({\n  name: z.string().optional(),\n  start_date: z.string().optional(),\n  end_date: z.string().optional(),\n  day_of_week: z.string().optional(),\n  start_time: z.string().optional(),\n  end_time: z.string().optional(),\n  city: z.string().optional(),\n  address: z.string().optional(),\n  description: z.string().optional(),\n  gps_link: z.string().optional(),\n  hero_image_url: z.string().optional(),\n  image_url: z.string().optional(),\n  is_active: z.string()\n    .optional()\n    .default('true'),\n}).transform((data) => {\n  const result: Record<string, any> = {};\n  \n  // Only include non-empty fields\n  if (data.name && data.name.trim()) result.name = data.name.trim();\n  if (data.start_date && data.start_date.trim()) result.start_date = data.start_date.trim();\n  if (data.end_date && data.end_date.trim()) result.end_date = data.end_date.trim();\n  if (data.day_of_week && data.day_of_week.trim()) result.day_of_week = parseInt(data.day_of_week, 10);\n  if (data.start_time && data.start_time.trim()) result.start_time = data.start_time.trim();\n  if (data.end_time && data.end_time.trim()) result.end_time = data.end_time.trim();\n  if (data.city && data.city.trim()) result.city = data.city.trim();\n  if (data.address && data.address.trim()) result.address = data.address.trim();\n  if (data.description && data.description.trim()) result.description = data.description.trim();\n  if (data.gps_link && data.gps_link.trim()) result.gps_link = data.gps_link.trim();\n  if (data.hero_image_url && data.hero_image_url.trim()) result.hero_image_url = data.hero_image_url.trim();\n  if (data.image_url && data.image_url.trim()) result.image_url = data.image_url.trim();\n  \n  // Always include is_active\n  result.is_active = data.is_active === 'true' || data.is_active === 'on';\n  \n  return result;\n});\n\n// Type inference\nexport type MarketFormValues = z.infer<typeof marketFormSchema>;\nexport type UpdateMarketFormValues = z.infer<typeof updateMarketFormSchema>;\nexport type CreateMarketInput = z.infer<typeof createMarketSchema>;\nexport type UpdateMarketInput = z.infer<typeof updateMarketSchema>;\n\n// Validation helper functions\nexport function validateMarketData(data: unknown): CreateMarketInput | null {\n  const result = createMarketSchema.safeParse(data);\n  return result.success ? result.data : null;\n}\n\nexport function validateMarketForm(formData: FormData): MarketFormValues | null {\n  const data = Object.fromEntries(formData.entries());\n  const result = marketFormSchema.safeParse(data);\n  return result.success ? result.data : null;\n}\n\nexport function validateUpdateMarketForm(formData: FormData): UpdateMarketFormValues | null {\n  const data = Object.fromEntries(formData.entries());\n  const result = updateMarketFormSchema.safeParse(data);\n  return result.success ? result.data : null;\n}","usedDeprecatedRules":[]},{"filePath":"C:\\herbisveritas\\src\\types\\supabase.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TipTapContent' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Types Supabase générés automatiquement - NE PAS MODIFIER MANUELLEMENT\n// Généré le: 2025-01-08\n\nimport { TipTapContent } from \"./magazine\";\n\nexport type Json =\n  | string\n  | number\n  | boolean\n  | null\n  | { [key: string]: Json | undefined }\n  | Json[]\n\nexport type Database = {\n  // Allows to automatically instanciate createClient with right options\n  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)\n  __InternalSupabase: {\n    PostgrestVersion: \"12.2.3 (519615d)\"\n  }\n  public: {\n    Tables: {\n      addresses: {\n        Row: {\n          address_line1: string\n          address_line2: string | null\n          address_type: string\n          city: string\n          company_name: string | null\n          country_code: string\n          created_at: string\n          email: string | null\n          first_name: string | null\n          full_name: string | null\n          id: string\n          is_default: boolean\n          last_name: string | null\n          phone_number: string | null\n          postal_code: string\n          state_province_region: string | null\n          street_number: string | null\n          updated_at: string\n          user_id: string\n        }\n        Insert: {\n          address_line1: string\n          address_line2?: string | null\n          address_type: string\n          city: string\n          company_name?: string | null\n          country_code: string\n          created_at?: string\n          email?: string | null\n          first_name?: string | null\n          full_name?: string | null\n          id?: string\n          is_default?: boolean\n          last_name?: string | null\n          phone_number?: string | null\n          postal_code: string\n          state_province_region?: string | null\n          street_number?: string | null\n          updated_at?: string\n          user_id: string\n        }\n        Update: {\n          address_line1?: string\n          address_line2?: string | null\n          address_type?: string\n          city?: string\n          company_name?: string | null\n          country_code?: string\n          created_at?: string\n          email?: string | null\n          first_name?: string | null\n          full_name?: string | null\n          id?: string\n          is_default?: boolean\n          last_name?: string | null\n          phone_number?: string | null\n          postal_code?: string\n          state_province_region?: string | null\n          street_number?: string | null\n          updated_at?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      article_tags: {\n        Row: {\n          article_id: string\n          tag_id: string\n        }\n        Insert: {\n          article_id: string\n          tag_id: string\n        }\n        Update: {\n          article_id?: string\n          tag_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: \"article_tags_article_id_fkey\"\n            columns: [\"article_id\"]\n            isOneToOne: false\n            referencedRelation: \"articles\"\n            referencedColumns: [\"id\"]\n          },\n          {\n            foreignKeyName: \"article_tags_tag_id_fkey\"\n            columns: [\"tag_id\"]\n            isOneToOne: false\n            referencedRelation: \"tags\"\n            referencedColumns: [\"id\"]\n          },\n        ]\n      }\n      articles: {\n        Row: {\n          author_id: string\n          category_id: string | null\n          content: Json\n          content_html: string | null\n          created_at: string | null\n          excerpt: string | null\n          featured_image: string | null\n          id: string\n          published_at: string | null\n          reading_time: number | null\n          seo_description: string | null\n          seo_title: string | null\n          slug: string\n          status: string | null\n          title: string\n          updated_at: string | null\n          view_count: number | null\n        }\n        Insert: {\n          author_id: string\n          category_id?: string | null\n          content: Json\n          content_html?: string | null\n          created_at?: string | null\n          excerpt?: string | null\n          featured_image?: string | null\n          id?: string\n          published_at?: string | null\n          reading_time?: number | null\n          seo_description?: string | null\n          seo_title?: string | null\n          slug: string\n          status?: string | null\n          title: string\n          updated_at?: string | null\n          view_count?: number | null\n        }\n        Update: {\n          author_id?: string\n          category_id?: string | null\n          content?: Json\n          content_html?: string | null\n          created_at?: string | null\n          excerpt?: string | null\n          featured_image?: string | null\n          id?: string\n          published_at?: string | null\n          reading_time?: number | null\n          seo_description?: string | null\n          seo_title?: string | null\n          slug?: string\n          status?: string | null\n          title?: string\n          updated_at?: string | null\n          view_count?: number | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: \"articles_author_id_fkey\"\n            columns: [\"author_id\"]\n            isOneToOne: false\n            referencedRelation: \"profiles\"\n            referencedColumns: [\"id\"]\n          },\n          {\n            foreignKeyName: \"articles_category_id_fkey\"\n            columns: [\"category_id\"]\n            isOneToOne: false\n            referencedRelation: \"categories\"\n            referencedColumns: [\"id\"]\n          },\n        ]\n      }\n      audit_logs: {\n        Row: {\n          created_at: string\n          data: Json | null\n          event_type: string\n          id: string\n          severity: Database[\"public\"][\"Enums\"][\"event_severity\"]\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          data?: Json | null\n          event_type: string\n          id?: string\n          severity?: Database[\"public\"][\"Enums\"][\"event_severity\"]\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          data?: Json | null\n          event_type?: string\n          id?: string\n          severity?: Database[\"public\"][\"Enums\"][\"event_severity\"]\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      cart_items: {\n        Row: {\n          added_at: string\n          cart_id: string\n          created_at: string\n          id: string\n          product_id: string\n          quantity: number\n          updated_at: string\n        }\n        Insert: {\n          added_at?: string\n          cart_id: string\n          created_at?: string\n          id?: string\n          product_id: string\n          quantity: number\n          updated_at?: string\n        }\n        Update: {\n          added_at?: string\n          cart_id?: string\n          created_at?: string\n          id?: string\n          product_id?: string\n          quantity?: number\n          updated_at?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: \"cart_items_cart_id_fkey\"\n            columns: [\"cart_id\"]\n            isOneToOne: false\n            referencedRelation: \"carts\"\n            referencedColumns: [\"id\"]\n          },\n          {\n            foreignKeyName: \"cart_items_product_id_fkey\"\n            columns: [\"product_id\"]\n            isOneToOne: false\n            referencedRelation: \"cart_product_details\"\n            referencedColumns: [\"id\"]\n          },\n          {\n            foreignKeyName: \"cart_items_product_id_fkey\"\n            columns: [\"product_id\"]\n            isOneToOne: false\n            referencedRelation: \"products\"\n            referencedColumns: [\"id\"]\n          },\n        ]\n      }\n      carts: {\n        Row: {\n          created_at: string\n          guest_id: string | null\n          id: string\n          metadata: Json | null\n          status: string\n          updated_at: string\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          guest_id?: string | null\n          id?: string\n          metadata?: Json | null\n          status?: string\n          updated_at?: string\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          guest_id?: string | null\n          id?: string\n          metadata?: Json | null\n          status?: string\n          updated_at?: string\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      categories: {\n        Row: {\n          color: string | null\n          created_at: string | null\n          description: string | null\n          id: string\n          name: string\n          slug: string\n          updated_at: string | null\n        }\n        Insert: {\n          color?: string | null\n          created_at?: string | null\n          description?: string | null\n          id?: string\n          name: string\n          slug: string\n          updated_at?: string | null\n        }\n        Update: {\n          color?: string | null\n          created_at?: string | null\n          description?: string | null\n          id?: string\n          name?: string\n          slug?: string\n          updated_at?: string | null\n        }\n        Relationships: []\n      }\n      featured_hero_items: {\n        Row: {\n          created_at: string\n          custom_subtitle: string\n          id: string\n          image_hero_url: string | null\n          is_active: boolean\n          product_id: string\n          updated_at: string\n        }\n        Insert: {\n          created_at?: string\n          custom_subtitle: string\n          id?: string\n          image_hero_url?: string | null\n          is_active?: boolean\n          product_id: string\n          updated_at?: string\n        }\n        Update: {\n          created_at?: string\n          custom_subtitle?: string\n          id?: string\n          image_hero_url?: string | null\n          is_active?: boolean\n          product_id?: string\n          updated_at?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: \"featured_hero_items_product_id_fkey\"\n            columns: [\"product_id\"]\n            isOneToOne: false\n            referencedRelation: \"cart_product_details\"\n            referencedColumns: [\"id\"]\n          },\n          {\n            foreignKeyName: \"featured_hero_items_product_id_fkey\"\n            columns: [\"product_id\"]\n            isOneToOne: false\n            referencedRelation: \"products\"\n            referencedColumns: [\"id\"]\n          },\n        ]\n      }\n      legal_documents: {\n        Row: {\n          content: string | null\n          created_at: string | null\n          id: number\n          slug: string\n          title: string\n          updated_at: string | null\n        }\n        Insert: {\n          content?: string | null\n          created_at?: string | null\n          id?: number\n          slug: string\n          title: string\n          updated_at?: string | null\n        }\n        Update: {\n          content?: string | null\n          created_at?: string | null\n          id?: number\n          slug?: string\n          title?: string\n          updated_at?: string | null\n        }\n        Relationships: []\n      }\n      login_attempts: {\n        Row: {\n          created_at: string\n          id: string\n          ip_address: string\n          key: string\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          ip_address: string\n          key: string\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          ip_address?: string\n          key?: string\n        }\n        Relationships: []\n      }\n      markets: {\n        Row: {\n          address: string\n          city: string\n          created_at: string | null\n          day_of_week: number\n          description: string | null\n          end_date: string\n          end_time: string\n          gps_link: string | null\n          hero_image_url: string | null\n          id: string\n          image_url: string | null\n          is_active: boolean | null\n          name: string\n          start_date: string\n          start_time: string\n          updated_at: string | null\n        }\n        Insert: {\n          address: string\n          city: string\n          created_at?: string | null\n          day_of_week: number\n          description?: string | null\n          end_date: string\n          end_time: string\n          gps_link?: string | null\n          hero_image_url?: string | null\n          id?: string\n          image_url?: string | null\n          is_active?: boolean | null\n          name: string\n          start_date: string\n          start_time: string\n          updated_at?: string | null\n        }\n        Update: {\n          address?: string\n          city?: string\n          created_at?: string | null\n          day_of_week?: number\n          description?: string | null\n          end_date?: string\n          end_time?: string\n          gps_link?: string | null\n          hero_image_url?: string | null\n          id?: string\n          image_url?: string | null\n          is_active?: boolean | null\n          name?: string\n          start_date?: string\n          start_time?: string\n          updated_at?: string | null\n        }\n        Relationships: []\n      }\n      order_items: {\n        Row: {\n          created_at: string\n          id: string\n          order_id: string\n          price_at_purchase: number\n          product_id: string\n          product_image_url_at_purchase: string | null\n          product_name_at_purchase: string | null\n          product_sku_at_purchase: string | null\n          quantity: number\n          updated_at: string\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          order_id: string\n          price_at_purchase: number\n          product_id: string\n          product_image_url_at_purchase?: string | null\n          product_name_at_purchase?: string | null\n          product_sku_at_purchase?: string | null\n          quantity: number\n          updated_at?: string\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          order_id?: string\n          price_at_purchase?: number\n          product_id?: string\n          product_image_url_at_purchase?: string | null\n          product_name_at_purchase?: string | null\n          product_sku_at_purchase?: string | null\n          quantity?: number\n          updated_at?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: \"order_items_order_id_fkey\"\n            columns: [\"order_id\"]\n            isOneToOne: false\n            referencedRelation: \"orders\"\n            referencedColumns: [\"id\"]\n          },\n          {\n            foreignKeyName: \"order_items_product_id_fkey\"\n            columns: [\"product_id\"]\n            isOneToOne: false\n            referencedRelation: \"cart_product_details\"\n            referencedColumns: [\"id\"]\n          },\n          {\n            foreignKeyName: \"order_items_product_id_fkey\"\n            columns: [\"product_id\"]\n            isOneToOne: false\n            referencedRelation: \"products\"\n            referencedColumns: [\"id\"]\n          },\n        ]\n      }\n      orders: {\n        Row: {\n          billing_address_id: string | null\n          created_at: string\n          currency: string\n          id: string\n          notes: string | null\n          order_number: string | null\n          payment_intent_id: string | null\n          payment_method: string | null\n          payment_status: Database[\"public\"][\"Enums\"][\"payment_status_type\"]\n          pickup_point_id: string | null\n          shipping_address_id: string | null\n          shipping_fee: number | null\n          status: Database[\"public\"][\"Enums\"][\"order_status_type\"]\n          stripe_checkout_id: string | null\n          stripe_checkout_session_id: string | null\n          total_amount: number\n          updated_at: string\n          user_id: string\n        }\n        Insert: {\n          billing_address_id?: string | null\n          created_at?: string\n          currency?: string\n          id?: string\n          notes?: string | null\n          order_number?: string | null\n          payment_intent_id?: string | null\n          payment_method?: string | null\n          payment_status?: Database[\"public\"][\"Enums\"][\"payment_status_type\"]\n          pickup_point_id?: string | null\n          shipping_address_id?: string | null\n          shipping_fee?: number | null\n          status?: Database[\"public\"][\"Enums\"][\"order_status_type\"]\n          stripe_checkout_id?: string | null\n          stripe_checkout_session_id?: string | null\n          total_amount: number\n          updated_at?: string\n          user_id: string\n        }\n        Update: {\n          billing_address_id?: string | null\n          created_at?: string\n          currency?: string\n          id?: string\n          notes?: string | null\n          order_number?: string | null\n          payment_intent_id?: string | null\n          payment_method?: string | null\n          payment_status?: Database[\"public\"][\"Enums\"][\"payment_status_type\"]\n          pickup_point_id?: string | null\n          shipping_address_id?: string | null\n          shipping_fee?: number | null\n          status?: Database[\"public\"][\"Enums\"][\"order_status_type\"]\n          stripe_checkout_id?: string | null\n          stripe_checkout_session_id?: string | null\n          total_amount?: number\n          updated_at?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: \"orders_billing_address_id_fkey\"\n            columns: [\"billing_address_id\"]\n            isOneToOne: false\n            referencedRelation: \"addresses\"\n            referencedColumns: [\"id\"]\n          },\n          {\n            foreignKeyName: \"orders_pickup_point_id_fkey\"\n            columns: [\"pickup_point_id\"]\n            isOneToOne: false\n            referencedRelation: \"pickup_points\"\n            referencedColumns: [\"id\"]\n          },\n          {\n            foreignKeyName: \"orders_shipping_address_id_fkey\"\n            columns: [\"shipping_address_id\"]\n            isOneToOne: false\n            referencedRelation: \"addresses\"\n            referencedColumns: [\"id\"]\n          },\n        ]\n      }\n      partners: {\n        Row: {\n          address: string\n          created_at: string | null\n          description: string\n          display_order: number | null\n          facebook_url: string | null\n          id: string\n          image_url: string\n          is_active: boolean | null\n          name: string\n          updated_at: string | null\n        }\n        Insert: {\n          address: string\n          created_at?: string | null\n          description: string\n          display_order?: number | null\n          facebook_url?: string | null\n          id?: string\n          image_url: string\n          is_active?: boolean | null\n          name: string\n          updated_at?: string | null\n        }\n        Update: {\n          address?: string\n          created_at?: string | null\n          description?: string\n          display_order?: number | null\n          facebook_url?: string | null\n          id?: string\n          image_url?: string\n          is_active?: boolean | null\n          name?: string\n          updated_at?: string | null\n        }\n        Relationships: []\n      }\n      pickup_points: {\n        Row: {\n          address: string\n          city: string\n          created_at: string | null\n          distance: number | null\n          id: string\n          latitude: number | null\n          longitude: number | null\n          name: string\n          order_id: string | null\n          point_id: string\n          zip_code: string\n        }\n        Insert: {\n          address: string\n          city: string\n          created_at?: string | null\n          distance?: number | null\n          id?: string\n          latitude?: number | null\n          longitude?: number | null\n          name: string\n          order_id?: string | null\n          point_id: string\n          zip_code: string\n        }\n        Update: {\n          address?: string\n          city?: string\n          created_at?: string | null\n          distance?: number | null\n          id?: string\n          latitude?: number | null\n          longitude?: number | null\n          name?: string\n          order_id?: string | null\n          point_id?: string\n          zip_code?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: \"pickup_points_order_id_fkey\"\n            columns: [\"order_id\"]\n            isOneToOne: false\n            referencedRelation: \"orders\"\n            referencedColumns: [\"id\"]\n          },\n        ]\n      }\n      product_translations: {\n        Row: {\n          composition_text: string | null\n          created_at: string\n          description_long: string | null\n          id: string\n          locale: string\n          name: string\n          product_id: string\n          properties: string | null\n          short_description: string | null\n          updated_at: string\n          usage_instructions: string | null\n        }\n        Insert: {\n          composition_text?: string | null\n          created_at?: string\n          description_long?: string | null\n          id?: string\n          locale: string\n          name: string\n          product_id: string\n          properties?: string | null\n          short_description?: string | null\n          updated_at?: string\n          usage_instructions?: string | null\n        }\n        Update: {\n          composition_text?: string | null\n          created_at?: string\n          description_long?: string | null\n          id?: string\n          locale?: string\n          name?: string\n          product_id?: string\n          properties?: string | null\n          short_description?: string | null\n          updated_at?: string\n          usage_instructions?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: \"product_translations_product_id_fkey\"\n            columns: [\"product_id\"]\n            isOneToOne: false\n            referencedRelation: \"cart_product_details\"\n            referencedColumns: [\"id\"]\n          },\n          {\n            foreignKeyName: \"product_translations_product_id_fkey\"\n            columns: [\"product_id\"]\n            isOneToOne: false\n            referencedRelation: \"products\"\n            referencedColumns: [\"id\"]\n          },\n        ]\n      }\n      products: {\n        Row: {\n          category: string | null\n          created_at: string\n          currency: string\n          description_long: string | null\n          description_short: string | null\n          id: string\n          image_url: string | null\n          inci_list: string[] | null\n          is_active: boolean\n          is_new: boolean\n          is_on_promotion: boolean\n          labels: string[] | null\n          name: string\n          price: number\n          slug: string\n          status: string | null\n          stock: number\n          unit: string | null\n          updated_at: string\n        }\n        Insert: {\n          category?: string | null\n          created_at?: string\n          currency?: string\n          description_long?: string | null\n          description_short?: string | null\n          id: string\n          image_url?: string | null\n          inci_list?: string[] | null\n          is_active?: boolean\n          is_new?: boolean\n          is_on_promotion?: boolean\n          labels?: string[] | null\n          name: string\n          price: number\n          slug: string\n          status?: string | null\n          stock?: number\n          unit?: string | null\n          updated_at?: string\n        }\n        Update: {\n          category?: string | null\n          created_at?: string\n          currency?: string\n          description_long?: string | null\n          description_short?: string | null\n          id?: string\n          image_url?: string | null\n          inci_list?: string[] | null\n          is_active?: boolean\n          is_new?: boolean\n          is_on_promotion?: boolean\n          labels?: string[] | null\n          name?: string\n          price?: number\n          slug?: string\n          status?: string | null\n          stock?: number\n          unit?: string | null\n          updated_at?: string\n        }\n        Relationships: []\n      }\n      profiles: {\n        Row: {\n          billing_address_is_different: boolean | null\n          billing_address_line1: string | null\n          billing_address_line2: string | null\n          billing_city: string | null\n          billing_country: string | null\n          billing_country_code: string | null\n          billing_phone_number: string | null\n          billing_postal_code: string | null\n          billing_state_province_region: string | null\n          created_at: string\n          first_name: string | null\n          id: string\n          last_name: string | null\n          newsletter_subscribed: boolean | null\n          phone_number: string | null\n          role: Database[\"public\"][\"Enums\"][\"app_role\"]\n          salutation: string | null\n          shipping_address_line1: string | null\n          shipping_address_line2: string | null\n          shipping_city: string | null\n          shipping_country: string | null\n          shipping_postal_code: string | null\n          terms_accepted_at: string | null\n          updated_at: string | null\n          use_shipping_for_billing: boolean | null\n        }\n        Insert: {\n          billing_address_is_different?: boolean | null\n          billing_address_line1?: string | null\n          billing_address_line2?: string | null\n          billing_city?: string | null\n          billing_country?: string | null\n          billing_country_code?: string | null\n          billing_phone_number?: string | null\n          billing_postal_code?: string | null\n          billing_state_province_region?: string | null\n          created_at?: string\n          first_name?: string | null\n          id: string\n          last_name?: string | null\n          newsletter_subscribed?: boolean | null\n          phone_number?: string | null\n          role?: Database[\"public\"][\"Enums\"][\"app_role\"]\n          salutation?: string | null\n          shipping_address_line1?: string | null\n          shipping_address_line2?: string | null\n          shipping_city?: string | null\n          shipping_country?: string | null\n          shipping_postal_code?: string | null\n          terms_accepted_at?: string | null\n          updated_at?: string | null\n          use_shipping_for_billing?: boolean | null\n        }\n        Update: {\n          billing_address_is_different?: boolean | null\n          billing_address_line1?: string | null\n          billing_address_line2?: string | null\n          billing_city?: string | null\n          billing_country?: string | null\n          billing_country_code?: string | null\n          billing_phone_number?: string | null\n          billing_postal_code?: string | null\n          billing_state_province_region?: string | null\n          created_at?: string\n          first_name?: string | null\n          id?: string\n          last_name?: string | null\n          newsletter_subscribed?: boolean | null\n          phone_number?: string | null\n          role?: Database[\"public\"][\"Enums\"][\"app_role\"]\n          salutation?: string | null\n          shipping_address_line1?: string | null\n          shipping_address_line2?: string | null\n          shipping_city?: string | null\n          shipping_country?: string | null\n          shipping_postal_code?: string | null\n          terms_accepted_at?: string | null\n          updated_at?: string | null\n          use_shipping_for_billing?: boolean | null\n        }\n        Relationships: []\n      }\n      shipping_methods: {\n        Row: {\n          carrier: string | null\n          created_at: string\n          description: string | null\n          id: string\n          is_active: boolean\n          name: string\n          price: number\n        }\n        Insert: {\n          carrier?: string | null\n          created_at?: string\n          description?: string | null\n          id: string\n          is_active?: boolean\n          name: string\n          price: number\n        }\n        Update: {\n          carrier?: string | null\n          created_at?: string\n          description?: string | null\n          id?: string\n          is_active?: boolean\n          name?: string\n          price?: number\n        }\n        Relationships: []\n      }\n      tags: {\n        Row: {\n          created_at: string | null\n          id: string\n          name: string\n          slug: string\n        }\n        Insert: {\n          created_at?: string | null\n          id?: string\n          name: string\n          slug: string\n        }\n        Update: {\n          created_at?: string | null\n          id?: string\n          name?: string\n          slug?: string\n        }\n        Relationships: []\n      }\n    }\n    Views: {\n      cart_product_details: {\n        Row: {\n          created_at: string | null\n          description_long: string | null\n          description_short: string | null\n          id: string | null\n          image_url: string | null\n          is_active: boolean | null\n          name: string | null\n          price: number | null\n          product_translations: Json | null\n          slug: string | null\n          stock: number | null\n          updated_at: string | null\n        }\n        Relationships: []\n      }\n      cleanup_monitoring: {\n        Row: {\n          created_at: string | null\n          event_type: string | null\n          full_details: Json | null\n          operation_type: Json | null\n          severity: Database[\"public\"][\"Enums\"][\"event_severity\"] | null\n          threshold_days: number | null\n          users_deleted: number | null\n          users_preserved: number | null\n        }\n        Insert: {\n          created_at?: string | null\n          event_type?: string | null\n          full_details?: Json | null\n          operation_type?: never\n          severity?: Database[\"public\"][\"Enums\"][\"event_severity\"] | null\n          threshold_days?: never\n          users_deleted?: never\n          users_preserved?: never\n        }\n        Update: {\n          created_at?: string | null\n          event_type?: string | null\n          full_details?: Json | null\n          operation_type?: never\n          severity?: Database[\"public\"][\"Enums\"][\"event_severity\"] | null\n          threshold_days?: never\n          users_deleted?: never\n          users_preserved?: never\n        }\n        Relationships: []\n      }\n    }\n    Functions: {\n      add_or_update_cart_item: {\n        Args: {\n          p_cart_id: string\n          p_product_id?: string\n          p_quantity_to_add?: number\n        }\n        Returns: {\n          added_at: string\n          cart_id: string\n          created_at: string\n          id: string\n          product_id: string\n          quantity: number\n          updated_at: string\n        }[]\n      }\n      check_email_exists: {\n        Args: { email_to_check: string }\n        Returns: boolean\n      }\n      cleanup_old_anonymous_users: {\n        Args: { days_threshold?: number; dry_run?: boolean }\n        Returns: {\n          action_type: string\n          user_count: number\n          details: Json\n        }[]\n      }\n      create_missing_profiles: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          user_id: string\n          email: string\n          action_taken: string\n        }[]\n      }\n      create_product_with_translations: {\n        Args: { product_data: Json; translations_data: Json }\n        Returns: string\n      }\n      create_product_with_translations_v2: {\n        Args: { product_data: Json; translations_data: Json }\n        Returns: Json\n      }\n      current_user_id: {\n        Args: Record<PropertyKey, never>\n        Returns: string\n      }\n      custom_access_token_hook: {\n        Args: { event: Json }\n        Returns: Json\n      }\n      get_cleanup_report: {\n        Args: { days_back?: number }\n        Returns: {\n          report_date: string\n          anonymous_users_count: number\n          users_growth_rate: number\n          last_cleanup_date: string\n          users_cleaned_last_month: number\n          recommendation: string\n        }[]\n      }\n      get_cleanup_stats: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          stat_name: string\n          stat_value: number\n          description: string\n        }[]\n      }\n      get_guest_id_from_jwt: {\n        Args: Record<PropertyKey, never>\n        Returns: string\n      }\n      get_my_custom_role: {\n        Args: Record<PropertyKey, never>\n        Returns: string\n      }\n      is_current_user_a_user: {\n        Args: Record<PropertyKey, never>\n        Returns: boolean\n      }\n      is_current_user_admin: {\n        Args: Record<PropertyKey, never>\n        Returns: boolean\n      }\n      is_current_user_dev: {\n        Args: Record<PropertyKey, never>\n        Returns: boolean\n      }\n      is_service_context: {\n        Args: Record<PropertyKey, never>\n        Returns: boolean\n      }\n      log_auth_event: {\n        Args: {\n          p_event_type: string\n          p_user_id: string\n          p_email?: string\n          p_metadata?: Json\n        }\n        Returns: string\n      }\n      log_event: {\n        Args: {\n          p_event_type: string\n          p_user_id?: string\n          p_data?: Json\n          p_severity?: Database[\"public\"][\"Enums\"][\"event_severity\"]\n        }\n        Returns: string\n      }\n      merge_carts: {\n        Args: { p_guest_cart_id: string; p_auth_cart_id: string }\n        Returns: undefined\n      }\n      merge_guest_cart_to_user: {\n        Args: { p_user_id: string; p_guest_id: string }\n        Returns: string\n      }\n      monitor_missing_profiles: {\n        Args: Record<PropertyKey, never>\n        Returns: number\n      }\n      run_weekly_anonymous_cleanup: {\n        Args: Record<PropertyKey, never>\n        Returns: Json\n      }\n      safe_cast_to_jsonb: {\n        Args: { p_text: string }\n        Returns: Json\n      }\n      update_product_with_translations: {\n        Args: {\n          p_id: string\n          p_slug: string\n          p_price: number\n          p_stock: number\n          p_unit: string\n          p_image_url: string\n          p_inci_list: string[]\n          p_status: string\n          p_is_active: boolean\n          p_is_new: boolean\n          p_is_on_promotion: boolean\n          p_translations: Json\n        }\n        Returns: undefined\n      }\n    }\n    Enums: {\n      app_role: \"user\" | \"editor\" | \"admin\" | \"dev\"\n      event_severity: \"INFO\" | \"WARNING\" | \"ERROR\" | \"CRITICAL\"\n      order_status_type:\n        | \"pending_payment\"\n        | \"processing\"\n        | \"shipped\"\n        | \"delivered\"\n        | \"cancelled\"\n        | \"refunded\"\n      payment_status_type: \"pending\" | \"succeeded\" | \"failed\" | \"refunded\"\n    }\n    CompositeTypes: {\n      cart_operation_result: {\n        success: boolean | null\n        message: string | null\n        cart_id: string | null\n        total_items: number | null\n      }\n    }\n  }\n}\n\ntype DatabaseWithoutInternals = Omit<Database, \"__InternalSupabase\">\n\ntype DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, \"public\">]\n\nexport type Tables<\n  DefaultSchemaTableNameOrOptions extends\n    | keyof (DefaultSchema[\"Tables\"] & DefaultSchema[\"Views\"])\n    | { schema: keyof DatabaseWithoutInternals },\n  TableName extends DefaultSchemaTableNameOrOptions extends {\n    schema: keyof DatabaseWithoutInternals\n  }\n    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions[\"schema\"]][\"Tables\"] &\n        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions[\"schema\"]][\"Views\"])\n    : never = never,\n> = DefaultSchemaTableNameOrOptions extends {\n  schema: keyof DatabaseWithoutInternals\n}\n  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions[\"schema\"]][\"Tables\"] &\n      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions[\"schema\"]][\"Views\"])[TableName] extends {\n      Row: infer R\n    }\n    ? R\n    : never\n  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema[\"Tables\"] &\n        DefaultSchema[\"Views\"])\n    ? (DefaultSchema[\"Tables\"] &\n        DefaultSchema[\"Views\"])[DefaultSchemaTableNameOrOptions] extends {\n        Row: infer R\n      }\n      ? R\n      : never\n    : never\n\nexport type TablesInsert<\n  DefaultSchemaTableNameOrOptions extends\n    | keyof DefaultSchema[\"Tables\"]\n    | { schema: keyof DatabaseWithoutInternals },\n  TableName extends DefaultSchemaTableNameOrOptions extends {\n    schema: keyof DatabaseWithoutInternals\n  }\n    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions[\"schema\"]][\"Tables\"]\n    : never = never,\n> = DefaultSchemaTableNameOrOptions extends {\n  schema: keyof DatabaseWithoutInternals\n}\n  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions[\"schema\"]][\"Tables\"][TableName] extends {\n      Insert: infer I\n    }\n    ? I\n    : never\n  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema[\"Tables\"]\n    ? DefaultSchema[\"Tables\"][DefaultSchemaTableNameOrOptions] extends {\n        Insert: infer I\n      }\n      ? I\n      : never\n    : never\n\nexport type TablesUpdate<\n  DefaultSchemaTableNameOrOptions extends\n    | keyof DefaultSchema[\"Tables\"]\n    | { schema: keyof DatabaseWithoutInternals },\n  TableName extends DefaultSchemaTableNameOrOptions extends {\n    schema: keyof DatabaseWithoutInternals\n  }\n    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions[\"schema\"]][\"Tables\"]\n    : never = never,\n> = DefaultSchemaTableNameOrOptions extends {\n  schema: keyof DatabaseWithoutInternals\n}\n  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions[\"schema\"]][\"Tables\"][TableName] extends {\n      Update: infer U\n    }\n    ? U\n    : never\n  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema[\"Tables\"]\n    ? DefaultSchema[\"Tables\"][DefaultSchemaTableNameOrOptions] extends {\n        Update: infer U\n      }\n      ? U\n      : never\n    : never\n\nexport type Enums<\n  DefaultSchemaEnumNameOrOptions extends\n    | keyof DefaultSchema[\"Enums\"]\n    | { schema: keyof DatabaseWithoutInternals },\n  EnumName extends DefaultSchemaEnumNameOrOptions extends {\n    schema: keyof DatabaseWithoutInternals\n  }\n    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions[\"schema\"]][\"Enums\"]\n    : never = never,\n> = DefaultSchemaEnumNameOrOptions extends {\n  schema: keyof DatabaseWithoutInternals\n}\n  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions[\"schema\"]][\"Enums\"][EnumName]\n  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema[\"Enums\"]\n    ? DefaultSchema[\"Enums\"][DefaultSchemaEnumNameOrOptions]\n    : never\n\nexport type CompositeTypes<\n  PublicCompositeTypeNameOrOptions extends\n    | keyof DefaultSchema[\"CompositeTypes\"]\n    | { schema: keyof DatabaseWithoutInternals },\n  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {\n    schema: keyof DatabaseWithoutInternals\n  }\n    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions[\"schema\"]][\"CompositeTypes\"]\n    : never = never,\n> = PublicCompositeTypeNameOrOptions extends {\n  schema: keyof DatabaseWithoutInternals\n}\n  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions[\"schema\"]][\"CompositeTypes\"][CompositeTypeName]\n  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema[\"CompositeTypes\"]\n    ? DefaultSchema[\"CompositeTypes\"][PublicCompositeTypeNameOrOptions]\n    : never\n\nexport const Constants = {\n  public: {\n    Enums: {\n      app_role: [\"user\", \"editor\", \"admin\", \"dev\"],\n      event_severity: [\"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"],\n      order_status_type: [\n        \"pending_payment\",\n        \"processing\",\n        \"shipped\",\n        \"delivered\",\n        \"cancelled\",\n        \"refunded\",\n      ],\n      payment_status_type: [\"pending\", \"succeeded\", \"failed\", \"refunded\"],\n    },\n  },\n} as const","usedDeprecatedRules":[]}]

info  - Need to disable some ESLint rules? Learn more here: https://nextjs.org/docs/app/api-reference/config/eslint#disabling-rules
