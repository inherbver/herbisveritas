# Documentation : Internationalisation (i18n)

Ce document est le guide de référence pour l'internationalisation (i18n) du projet HerbisVeritas. Il explique l'architecture, les conventions et les procédures pour ajouter et gérer les traductions.

**Bibliothèque principale :** [`next-intl`](https://next-intl.dev/)

---

## 1. Guide Rapide : Ajouter une Traduction

Pour un développeur souhaitant ajouter ou modifier une traduction, voici le processus en 3 étapes :

1.  **Identifier ou Créer le Fichier de "Namespace" :**
    - Les traductions sont dans `src/i18n/messages/[locale]/`.
    - Chaque fichier (ex: `HomePage.json`, `Global.json`) est un "namespace".
    - Choisissez le namespace le plus pertinent.
    - **Si vous créez un nouveau namespace** (ex: `NewFeature.json`), vous devez l'ajouter dans les dossiers de chaque locale (`en`, `fr`, etc.) ET **l'enregistrer dans le tableau `namespaces` du fichier `src/i18n.ts`**.

2.  **Ajouter la clé de traduction :**
    - Utilisez la convention `camelCase` pour la clé.
    - Ajoutez la paire `"maNouvelleCle": "Ma traduction"` dans les fichiers JSON de **toutes les langues**.
    - **Exemple dans `.../fr/Global.json`**: `"seeDetails": "Voir les détails"`
    - **Exemple dans `.../en/Global.json`**: `"seeDetails": "See details"`

3.  **Utiliser la traduction dans le code :**
    - **Server Component**:

      ```tsx
      import { getTranslations } from "next-intl/server";

      export default async function MyComponent() {
        const t = await getTranslations("Global"); // Charger le namespace
        return <p>{t("seeDetails")}</p>;
      }
      ```

    - **Client Component**:

      ```tsx
      "use client";
      import { useTranslations } from "next-intl";

      export default function MyComponent() {
        const t = useTranslations("Global"); // Le namespace doit être chargé par un parent
        return <p>{t("seeDetails")}</p>;
      }
      ```

    - **Server Actions avec locale spécifique**:

      ```tsx
      import { getTranslations } from "next-intl/server";

      export async function myServerAction(locale: string) {
        const t = await getTranslations({ locale, namespace: "Global" });
        return { message: t("success") };
      }
      ```

---

## 2. Architecture Détaillée

### a. Structure des Fichiers

L'organisation des fichiers est la pierre angulaire de notre système i18n.

- **Répertoire principal :** `src/i18n/messages/`
- **Structure :** `[locale]/[NamespaceName].json`
  - `[locale]`: Code de la langue (ex: `en`, `fr`).
  - `[NamespaceName].json`: Fichier contenant les traductions pour un contexte spécifique (ex: `ProductPage.json`). Le nom du fichier, en `PascalCase`, définit le nom du namespace.

Chaque fichier JSON contient un objet de paires clé-valeur. Les objets peuvent être imbriqués pour une meilleure organisation (ex: `"Header": { "login": "Connexion" }`).

_Exemple : `src/i18n/messages/fr/Global.json`_

```json
{
  "home": "Accueil",
  "shop": "Boutique",
  "Header": {
    "login": "Connexion",
    "register": "S'inscrire",
    "logoAriaLabel": "In Herbis Veritas - Retour à la page d'accueil"
  },
  "Cart": {
    "title": "Panier",
    "addToCart": "Ajouter au Panier",
    "itemCount": "{count, plural, =0 {aucun article} one {# article} other {# articles}}"
  }
}
```

### b. Configuration et Chargement

L'architecture de chargement est conçue pour être maintenable, performante et compatible avec l'Edge Runtime de Next.js.

- **`src/i18n.ts` (Le Cœur du Système) :**
  - **Source de vérité :** Un tableau `namespaces` liste tous les namespaces utilisés dans l'application.
  - **Chargement Dynamique et Parallèle :** Pour une locale donnée, ce fichier charge en parallèle tous les fichiers JSON correspondants listés dans le tableau `namespaces`.
  - **Robustesse :** Une gestion d'erreurs intégrée logue les problèmes de chargement (fichier manquant, JSON invalide) sans faire planter l'application en production.
  - **Pour ajouter un namespace, c'est la seule modification nécessaire (en plus de créer les fichiers JSON).**

- **`src/i18n-config.ts` (Configuration du Routage) :**
  - Ce fichier léger définit les locales supportées (`locales`) et la configuration des `pathnames`.
  - Il mappe les chemins canoniques de l'application (ex: `/products/[slug]`) aux URLs localisées visibles par l'utilisateur (ex: `/fr/produits/[slug]`).
  - **C'est ici qu'il faut intervenir pour traduire les URLs.**

- **`src/middleware.ts` :**
  - Le middleware `next-intl` utilise **uniquement** `i18n-config.ts` pour gérer la détection de la locale et le routage, ce qui garantit sa compatibilité avec l'Edge Runtime.
  - Il gère également la sécurité des routes (voir [ADMIN_AND_ROUTES.md](./ADMIN_AND_ROUTES.md)).

- **`src/app/[locale]/layout.tsx` :**
  - Le layout racine charge les messages pour la locale courante et les passe au `ClientLayout`.

- **`src/components/layout/client-layout.tsx` :**
  - Ce composant enveloppe l'application dans le `<NextIntlClientProvider>`, fournissant les messages de traduction à tous les Client Components.
  - Il gère également l'authentification Supabase et la synchronisation du panier utilisateur.

### c. Conventions

- **Noms de Fichiers (Namespaces) :** `PascalCase` (ex: `CheckoutFlow.json`).
- **Clés de Traduction :** `camelCase` (ex: `billingAddress`).
- **Objets Imbriqués :** `PascalCase` pour les groupes logiques (ex: `"Header"`, `"Cart"`).
- **Traductions avec Variables :** Support ICU MessageFormat (ex: `"{count, plural, =0 {aucun article} one {# article} other {# articles}}"`).
- **Traductions avec Sélecteurs :** Support des sélecteurs conditionnels (ex: `"{isEditing, select, true {Modifier} false {Ajouter} other {Action}}"`)

### d. Internationalisation des Données (Base de Données)

En plus des chaînes de l'interface utilisateur, le contenu de la base de données (comme les noms et descriptions de produits) est également internationalisé. La stratégie consiste à utiliser des tables de traduction dédiées.

- **Exemple :** La table `products` contient les données non traduisibles (prix, stock). La table `product_translations` contient les champs traduisibles (`name`, `description`) avec une colonne `language_code` qui la lie à une langue spécifique et une clé étrangère vers la table `products`.

Pour plus de détails, consultez la documentation [DATABASE.md](./DATABASE.md).

---

## 3. Dépannage et Points d'Attention

Cette section, tirée de l'expérience, liste les problèmes courants et leurs solutions.

- **Erreur `FORMATTING_ERROR`**:
  - **Cause :** Une traduction attend une variable (ex: `"Bonjour {name}"`) mais elle n'est pas fournie à l'appel `t()`.
  - **Solution :** Toujours passer les variables attendues. `t('welcomeMessage', { name: 'Omar' })`.

- **Clés dupliquées dans un JSON**:
  - **Cause :** Un même fichier JSON contient deux fois la même clé.
  - **Solution :** Les linters JSON devraient détecter cela. Assurez une unicité stricte.

- **Confusion de portée avec `useTranslations`**:
  - **Cause :** `const t = useTranslations('Global.Header')` puis `t('Header.login')`.
  - **Solution :** Le préfixe est déjà appliqué. Utilisez `t('login')` directement.

- **Namespace avec sous-objets**:
  - **Utilisation correcte :** `const t = useTranslations('Global')` puis `t('Header.login')` pour accéder à `Global.Header.login`.
  - **Ou bien :** `const t = useTranslations('Global.Header')` puis `t('login')` pour le même résultat.

- **Server Actions et locale**:
  - **Problème :** Oublier de passer la locale dans les Server Actions.
  - **Solution :** Toujours utiliser `getTranslations({ locale, namespace })` dans les actions serveur.

---

## 4. Bonnes Pratiques et Exemples Avancés

### a. Gestion des Traductions Complexes

- **Messages avec pluralisation :**

  ```json
  {
    "itemCount": "{count, plural, =0 {aucun article} one {# article} other {# articles}}"
  }
  ```

  Utilisation : `t('itemCount', { count: 5 })` → "5 articles"

- **Messages avec sélecteurs conditionnels :**
  ```json
  {
    "formTitle": "{isEditing, select, true {Modifier l'} false {Ajouter une }} adresse"
  }
  ```
  Utilisation : `t('formTitle', { isEditing: true })` → "Modifier l'adresse"

### b. Organisation des Namespaces

- **Namespace par contexte métier :** `AddressForm`, `CheckoutPage`, `ProductDetail`
- **Namespace pour composants réutilisables :** `Global`, `CartDisplay`, `Header`
- **Namespace pour les messages système :** `Auth`, `Errors`, `Validation`

### c. Composants Avec Traductions Optionnelles

Pour les composants réutilisables qui peuvent recevoir des traductions externes :

```tsx
interface ComponentProps {
  translations?: ReturnType<typeof useTranslations>;
}

function Component({ translations }: ComponentProps) {
  const defaultT = useTranslations("ComponentNamespace");
  const t = translations || defaultT;
  return <div>{t("someKey")}</div>;
}
```

---

## 5. Évolutions Futures

- **Validation en CI :** Un script pour vérifier que toutes les clés existent dans toutes les langues.
- **Typage Fort :** Génération de types TypeScript à partir des JSON pour l'autocomplétion et la détection d'erreurs à la compilation.
