# Note Technique : Système d'Internationalisation (i18n)

Ce document décrit l'architecture et le fonctionnement du système d'internationalisation (i18n) utilisé dans ce projet Next.js. L'objectif est de fournir une expérience utilisateur localisée en plusieurs langues (actuellement français et anglais, avec une possible extension à l'allemand et l'espagnol).

## 1. Bibliothèque Utilisée

Nous utilisons la bibliothèque [`next-intl`](https://next-intl.dev/) pour gérer l'i18n. Elle est spécifiquement conçue pour Next.js et s'intègre bien avec l'App Router et les Server Components.

## 2. Structure des Fichiers de Traduction

Les messages de traduction sont stockés dans des fichiers JSON, organisés par locale et par namespace :

- **Fichiers de Namespace :**
  - Chemin : `src/i18n/messages/[locale]/[NamespaceName].json` (par exemple, `src/i18n/messages/fr/HomePage.json`, `src/i18n/messages/en/Global.json`).
  - Usage : Chaque fichier représente un "namespace" (une portée logique) pour les traductions. Par exemple, `HomePage.json` contient toutes les traductions spécifiques à la page d'accueil. Le fichier `Global.json` est un de ces namespaces, dédié aux traductions partagées à travers l'application (éléments du Header, Footer, boutons communs, etc.).
  - Structure interne : Chaque fichier `[NamespaceName].json` contient directement les paires clé-valeur pour ce namespace. Il n'y a PAS de clé de premier niveau portant le nom du namespace à l'intérieur du fichier JSON lui-même.
    _Exemple de structure pour `src/i18n/messages/fr/ProductDetail.json` :_
    ```json
    {
      "addToCart": "Ajouter au panier",
      "productDescription": "Description du produit",
      "relatedProducts": "Produits similaires"
    }
    ```
    _Exemple de structure pour `src/i18n/messages/fr/Global.json` (un autre fichier de namespace) :_
    ```json
    {
      "LocaleSwitcher": {
        "switchLocale": "Passer en {locale, select, fr {français} en {anglais} other {inconnu}}"
      },
      "Header": {
        "home": "Accueil",
        "cartAriaLabel": "Panier d'achats"
      },
      "openCart": "Ouvrir le Panier",
      "saveChanges": "Enregistrer les modifications"
    }
    ```
  - **Note sur `root.json` :** Les anciens fichiers `root.json` (ou `src/messages/[locale].json`) qui agissaient comme conteneurs principaux pour plusieurs namespaces ont été supprimés. Toutes les traductions résident maintenant dans des fichiers de namespace spécifiques.

## 3. Mécanisme de Chargement et Fusion des Messages

Le chargement et la fusion des messages sont gérés dans `src/i18n.ts` en utilisant la fonction `getRequestConfig` de `next-intl/server`.

Le processus pour une locale donnée (par exemple, `fr`) est le suivant :

1.  **Importation Dynamique des Namespaces :**

    - Tous les fichiers `*.json` présents dans le répertoire `src/i18n/messages/[locale]/` (par exemple, `src/i18n/messages/fr/`) sont importés dynamiquement. Chaque nom de fichier (sans l'extension `.json`) devient le nom d'un namespace.
    - Par exemple, `HomePage.json` deviendra le namespace `HomePage`, `Global.json` deviendra `Global`, etc.

2.  **Construction de l'Objet `messages` Final :**

    - Le contenu de chaque fichier JSON importé est assigné comme valeur à une clé portant le nom du namespace correspondant dans l'objet `messages` final.
    - Il n'y a plus de fichier "racine" (`root.json`) ; tous les messages proviennent de fichiers de namespace dédiés.

    _Exemple de structure de l'objet `messages` final pour la locale `fr`, assemblé à partir de `HomePage.json`, `ProductDetail.json`, `Global.json`, etc. :_

    ```javascript
    {
      // Provenant de src/i18n/messages/fr/HomePage.json
      "HomePage": {
        "title": "Bienvenue...",
        "description": "..."
      },
      // Provenant de src/i18n/messages/fr/ProductDetail.json
      "ProductDetail": {
        "addToCart": "Ajouter au panier",
        "productDescription": "Description du produit"
      },
      // Provenant de src/i18n/messages/fr/Global.json
      "Global": {
        "LocaleSwitcher": { /* ... */ },
        "Header": { /* ... */ },
        "openCart": "Ouvrir le Panier"
      }
      // ... autres namespaces chargés dynamiquement
    }
    ```

    Des logs dans `src/i18n.ts` peuvent aider à tracer ce processus si nécessaire.

## 4. Utilisation des Traductions dans les Composants

`next-intl` fournit des hooks et des fonctions pour accéder aux traductions :

- **Server Components :**

  - Utilisez `await getTranslations()` pour charger les messages.
  - On peut passer l'objet `t` ou des messages spécifiques aux Client Components si nécessaire.

- **Client Components (`'use client'`) :**

  - Utilisez le hook `useTranslations()` de `next-intl`.

- **Accès aux Clés :**
  - Les traductions sont accessibles en utilisant une chaîne de caractères qui représente le chemin vers la clé, en utilisant le namespace comme préfixe.
    - `const t = useTranslations('HomePage'); const title = t('title');`
    - `const tGlobal = useTranslations('Global'); const openCartLabel = tGlobal('openCart');`
    - `const tHeader = useTranslations('Global.Header'); const homeLink = tHeader('home');`
  - Si aucun namespace n'est fourni à `useTranslations()` ou `getTranslations()`, vous pouvez accéder à n'importe quelle clé de premier niveau (comme `HomePage` ou `Global` directement, bien que ce soit moins courant pour les traductions finales).

## 5. Internationalisation du Routage

- **Routes Localisées :** Les routes de l'application sont préfixées par la locale, par exemple : `/fr/produits`, `/en/products`. Ceci est géré par la structure de dossiers `/app/[locale]/...`.
- **Middleware (`src/middleware.ts`) :** Un middleware `next-intl` est configuré pour :
  - Détecter la locale préférée de l'utilisateur (depuis l'URL, les cookies, ou l'en-tête `Accept-Language`).
  - Rediriger vers la route localisée appropriée si nécessaire.
  - Gérer les locales par défaut.
- **Navigation :** Les composants `Link` et les fonctions de navigation (comme `useRouter`, `redirect`) fournis par `next-intl/navigation` doivent être utilisés pour assurer une navigation correcte qui préserve la locale.

## 6. Fournisseur de Contexte (`NextIntlClientProvider`)

Dans le layout racine (`src/app/[locale]/layout.tsx`), le composant `<NextIntlClientProvider messages={messages}>` est utilisé pour mettre les messages chargés à disposition des Client Components dans l'arbre de composants. Les `messages` ici sont ceux récupérés via `getRequestConfig` (et donc déjà fusionnés).

## 7. Conventions de Nommage

- **Noms des fichiers de Namespace :** `PascalCase` (par exemple, `HomePage.json`, `ProductDetail.json`, `Global.json`). Ces noms de fichiers deviennent les clés de namespace de premier niveau dans l'objet messages fusionné.
- **Clés de traduction (dans les namespaces) :** `camelCase` (par exemple, `pageTitle`, `addToCart`, `validationError`).

## 8. Améliorations Futures Envisagées (Non Implémentées)

- **Validation en CI :** Un script pour valider le format JSON des fichiers de traduction et vérifier l'exhaustivité des clés entre les différentes locales (en se basant sur une locale de référence) avant chaque déploiement.
- **Typage Fort des Traductions :** Génération automatique de types TypeScript à partir des fichiers JSON pour fournir une autocomplétion et une vérification des types lors de l'utilisation de `useTranslations()` et `t()`, afin de détecter les clés manquantes ou incorrectes au moment de la compilation.

---

## 9. Points d'Attention et Dépannage Courant

Lors de l'utilisation de `next-intl`, certains problèmes courants peuvent survenir. Voici quelques points à vérifier :

- **Unicité des Clés de Namespace (JSON) :**

  - **Problème :** Des erreurs de lint JSON (comme "Duplicate object key") ou des traductions manquantes/incorrectes peuvent survenir si une clé de premier niveau (un "namespace" comme `HomePage`, `PasswordPage`) est accidentellement dupliquée dans un fichier de traduction (par exemple, `src/messages/fr.json`).
  - **Solution :** Assurez-vous que chaque clé de namespace est strictement unique dans chaque fichier de traduction. Inspectez attentivement les fichiers pour toute duplication.

- **Fourniture des Variables pour les Chaînes Formatées (`FORMATTING_ERROR`) :**

  - **Problème :** Une erreur `FORMATTING_ERROR: The intl string context variable "nomVariable" was not provided...` se produit si une chaîne de traduction attend une variable (par exemple, `"Message avec {nomVariable}"`) mais que cette variable n'est pas fournie lors de l'appel à `t()`.
  - **Solution :** Toujours fournir les variables attendues à la fonction `t()`. Exemple : `t("maCleAvecVariable", { nomVariable: "valeur" })`.

- **Portée des Clés avec `useTranslations` / `getTranslations` :**

  - **Problème :** Confusion sur la manière d'accéder aux clés lorsque `useTranslations("MonNamespace.MonSousNamespace")` est utilisé.
  - **Solution :** Si vous initialisez `t` avec un namespace complet (par exemple, `const t = useTranslations("PasswordPage.validation");`), alors pour accéder à une clé comme `PasswordPage.validation.maCle`, vous devez appeler `t("maCle")`. Le préfixe est déjà pris en compte. Appeler `t("validation.maCle")` chercherait `PasswordPage.validation.validation.maCle`, ce qui est incorrect.

- **Accès Asynchrone aux Paramètres de Route (Next.js 15+) :**
  - **Problème :** Dans les Server Components avec Next.js 15+, un accès direct comme `props.params.locale` pour récupérer la locale dans des fonctions comme `generateMetadata` ou le composant de page lui-même peut entraîner une erreur (`Route "..." used params.locale. params should be awaited...`).
  - **Solution :** Toujours utiliser `await` pour accéder aux propriétés de `props.params`. Exemple : `const { locale } = await props.params;`.
