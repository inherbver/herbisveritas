# Note Technique : Système d'Internationalisation (i18n)

Ce document décrit l'architecture et le fonctionnement du système d'internationalisation (i18n) utilisé dans ce projet Next.js. L'objectif est de fournir une expérience utilisateur localisée en plusieurs langues (actuellement français et anglais, avec une possible extension à l'allemand et l'espagnol).

## 1. Bibliothèque Utilisée

Nous utilisons la bibliothèque [`next-intl`](https://next-intl.dev/) pour gérer l'i18n. Elle est spécifiquement conçue pour Next.js et s'intègre bien avec l'App Router et les Server Components.

## 2. Structure des Fichiers de Traduction

Les messages de traduction sont stockés dans des fichiers JSON, organisés par locale et par portée :

- **Messages Spécifiques aux Pages/Modules :**

  - Chemin : `src/messages/[locale].json` (par exemple, `src/messages/fr.json`, `src/messages/en.json`)
  - Usage : Contient les traductions pour des pages entières ou des modules/composants spécifiques qui ne sont pas réutilisés globalement. Les clés dans ces fichiers sont généralement organisées en "namespaces" (objets JSON imbriqués) correspondant à la page ou au composant.
    _Exemple de structure dans `fr.json` :_
    ```json
    {
      "HomePage": {
        "title": "Bienvenue...",
        "description": "..."
      },
      "ProductPage": {
        "addToCart": "Ajouter au panier"
      }
    }
    ```

- **Messages Globaux/Partagés :**
  - Chemin : `src/i18n/messages/[locale]/Global.json` (par exemple, `src/i18n/messages/fr/Global.json`)
  - Usage : Contient les traductions pour les éléments d'interface utilisateur (UI) partagés à travers toute l'application, tels que les éléments du `Header`, `Footer`, les boutons communs (`Sauvegarder`, `Annuler`), les labels de `LocaleSwitcher`, etc.
    _Exemple de structure dans `fr/Global.json` :_
    ```json
    {
      "LocaleSwitcher": {
        "switchLocale": "Passer en {locale, select, fr {français} en {anglais} other {inconnu}}"
      },
      "Header": {
        "home": "Accueil",
        "cartAriaLabel": "Panier d'achats"
      },
      "openCart": "Ouvrir le Panier",
      "saveChanges": "Enregistrer les modifications"
    }
    ```

## 3. Mécanisme de Chargement et Fusion des Messages

Le chargement et la fusion des messages sont gérés dans `src/i18n.ts` en utilisant la fonction `getRequestConfig` de `next-intl/server`.

Le processus pour une locale donnée (par exemple, `fr`) est le suivant :

1.  **Importation Dynamique :**

    - Le fichier principal de la locale (`src/messages/fr.json`) est importé dynamiquement.
    - Le fichier global de la locale (`src/i18n/messages/fr/Global.json`) est également importé dynamiquement.

2.  **Fusion des Messages :**

    - Les messages du fichier principal (`fr.json`) forment la base de l'objet `messages`.
    - Le contenu entier de `Global.json` est ensuite niché sous une clé de premier niveau nommée `Global` dans cet objet `messages`.

    _Exemple de structure de l'objet `messages` final pour la locale `fr` :_

    ```javascript
    {
      // Provenant de src/messages/fr.json
      "HomePage": { /* ... */ },
      "ProductPage": { /* ... */ },
      // ... autres namespaces spécifiques

      // Provenant de src/i18n/messages/fr/Global.json
      "Global": {
        "LocaleSwitcher": { /* ... */ },
        "Header": { /* ... */ },
        "openCart": "Ouvrir le Panier",
        // ... autres clés globales
      }
    }
    ```

    Des logs détaillés dans `src/i18n.ts` (`[i18n] Before || {}...`, `[i18n] After || {}...`, `[i18n] Final mergedMessages structure...`) permettent de tracer ce processus de chargement et de fusion.

## 4. Utilisation des Traductions dans les Composants

`next-intl` fournit des hooks et des fonctions pour accéder aux traductions :

- **Server Components :**

  - Utilisez `await getTranslations()` pour charger les messages.
  - On peut passer l'objet `t` ou des messages spécifiques aux Client Components si nécessaire.

- **Client Components (`'use client'`) :**

  - Utilisez le hook `useTranslations()` de `next-intl`.

- **Accès aux Clés :**
  - Les traductions sont accessibles en utilisant une chaîne de caractères qui représente le chemin vers la clé, en utilisant le namespace comme préfixe.
    - `const t = useTranslations('HomePage'); const title = t('title');`
    - `const tGlobal = useTranslations('Global'); const openCartLabel = tGlobal('openCart');`
    - `const tHeader = useTranslations('Global.Header'); const homeLink = tHeader('home');`
  - Si aucun namespace n'est fourni à `useTranslations()` ou `getTranslations()`, vous pouvez accéder à n'importe quelle clé de premier niveau (comme `HomePage` ou `Global` directement, bien que ce soit moins courant pour les traductions finales).

## 5. Internationalisation du Routage

- **Routes Localisées :** Les routes de l'application sont préfixées par la locale, par exemple : `/fr/produits`, `/en/products`. Ceci est géré par la structure de dossiers `/app/[locale]/...`.
- **Middleware (`src/middleware.ts`) :** Un middleware `next-intl` est configuré pour :
  - Détecter la locale préférée de l'utilisateur (depuis l'URL, les cookies, ou l'en-tête `Accept-Language`).
  - Rediriger vers la route localisée appropriée si nécessaire.
  - Gérer les locales par défaut.
- **Navigation :** Les composants `Link` et les fonctions de navigation (comme `useRouter`, `redirect`) fournis par `next-intl/navigation` doivent être utilisés pour assurer une navigation correcte qui préserve la locale.

## 6. Fournisseur de Contexte (`NextIntlClientProvider`)

Dans le layout racine (`src/app/[locale]/layout.tsx`), le composant `<NextIntlClientProvider messages={messages}>` est utilisé pour mettre les messages chargés à disposition des Client Components dans l'arbre de composants. Les `messages` ici sont ceux récupérés via `getRequestConfig` (et donc déjà fusionnés).

## 7. Conventions de Nommage

- **Namespaces (clés de premier niveau dans JSON) :** `PascalCase` (par exemple, `HomePage`, `ProductDetail`, `Global`).
- **Clés de traduction (dans les namespaces) :** `camelCase` (par exemple, `pageTitle`, `addToCart`, `validationError`).

## 8. Améliorations Futures Envisagées (Non Implémentées)

- **Validation en CI :** Un script pour valider le format JSON des fichiers de traduction et vérifier l'exhaustivité des clés entre les différentes locales (en se basant sur une locale de référence) avant chaque déploiement.
- **Typage Fort des Traductions :** Génération automatique de types TypeScript à partir des fichiers JSON pour fournir une autocomplétion et une vérification des types lors de l'utilisation de `useTranslations()` et `t()`, afin de détecter les clés manquantes ou incorrectes au moment de la compilation.

---

## 9. Points d'Attention et Dépannage Courant

Lors de l'utilisation de `next-intl`, certains problèmes courants peuvent survenir. Voici quelques points à vérifier :

- **Unicité des Clés de Namespace (JSON) :**

  - **Problème :** Des erreurs de lint JSON (comme "Duplicate object key") ou des traductions manquantes/incorrectes peuvent survenir si une clé de premier niveau (un "namespace" comme `HomePage`, `PasswordPage`) est accidentellement dupliquée dans un fichier de traduction (par exemple, `src/messages/fr.json`).
  - **Solution :** Assurez-vous que chaque clé de namespace est strictement unique dans chaque fichier de traduction. Inspectez attentivement les fichiers pour toute duplication.

- **Fourniture des Variables pour les Chaînes Formatées (`FORMATTING_ERROR`) :**

  - **Problème :** Une erreur `FORMATTING_ERROR: The intl string context variable "nomVariable" was not provided...` se produit si une chaîne de traduction attend une variable (par exemple, `"Message avec {nomVariable}"`) mais que cette variable n'est pas fournie lors de l'appel à `t()`.
  - **Solution :** Toujours fournir les variables attendues à la fonction `t()`. Exemple : `t("maCleAvecVariable", { nomVariable: "valeur" })`.

- **Portée des Clés avec `useTranslations` / `getTranslations` :**

  - **Problème :** Confusion sur la manière d'accéder aux clés lorsque `useTranslations("MonNamespace.MonSousNamespace")` est utilisé.
  - **Solution :** Si vous initialisez `t` avec un namespace complet (par exemple, `const t = useTranslations("PasswordPage.validation");`), alors pour accéder à une clé comme `PasswordPage.validation.maCle`, vous devez appeler `t("maCle")`. Le préfixe est déjà pris en compte. Appeler `t("validation.maCle")` chercherait `PasswordPage.validation.validation.maCle`, ce qui est incorrect.

- **Accès Asynchrone aux Paramètres de Route (Next.js 15+) :**
  - **Problème :** Dans les Server Components avec Next.js 15+, un accès direct comme `props.params.locale` pour récupérer la locale dans des fonctions comme `generateMetadata` ou le composant de page lui-même peut entraîner une erreur (`Route "..." used params.locale. params should be awaited...`).
  - **Solution :** Toujours utiliser `await` pour accéder aux propriétés de `props.params`. Exemple : `const { locale } = await props.params;`.
