# Documentation : Internationalisation (i18n)

Ce document est le guide de référence pour l'internationalisation (i18n) du projet HerbisVeritas. Il explique l'architecture, les conventions et les procédures pour ajouter et gérer les traductions.

**Bibliothèque principale :** [`next-intl`](https://next-intl.dev/)

---

## 1. Guide Rapide : Ajouter une Traduction

Pour un développeur souhaitant ajouter ou modifier une traduction, voici le processus en 3 étapes :

1.  **Identifier ou Créer le Fichier de "Namespace" :**
    - Les traductions sont dans `src/i18n/messages/[locale]/`.
    - Chaque fichier (ex: `HomePage.json`, `Global.json`) est un "namespace".
    - Choisissez le namespace le plus pertinent.
    - **Si vous créez un nouveau namespace** (ex: `NewFeature.json`), vous devez l'ajouter dans les dossiers de chaque locale (`en`, `fr`, etc.) ET **l'enregistrer dans le tableau `namespaces` du fichier `src/i18n.ts`**.

2.  **Ajouter la clé de traduction :**
    - Utilisez la convention `camelCase` pour la clé.
    - Ajoutez la paire `"maNouvelleCle": "Ma traduction"` dans les fichiers JSON de **toutes les langues**.
    - **Exemple dans `.../fr/Global.json`**: `"seeDetails": "Voir les détails"`
    - **Exemple dans `.../en/Global.json`**: `"seeDetails": "See details"`

3.  **Utiliser la traduction dans le code :**
    - **Server Component**:

      ```tsx
      import { getTranslations } from "next-intl/server";

      export default async function MyComponent() {
        const t = await getTranslations("Global"); // Charger le namespace
        return <p>{t("seeDetails")}</p>;
      }
      ```

    - **Client Component**:

      ```tsx
      "use client";
      import { useTranslations } from "next-intl";

      export default function MyComponent() {
        const t = useTranslations("Global"); // Le namespace doit être chargé par un parent
        return <p>{t("seeDetails")}</p>;
      }
      ```

---

## 2. Architecture Détaillée

### a. Structure des Fichiers

L'organisation des fichiers est la pierre angulaire de notre système i18n.

- **Répertoire principal :** `src/i18n/messages/`
- **Structure :** `[locale]/[NamespaceName].json`
  - `[locale]`: Code de la langue (ex: `en`, `fr`).
  - `[NamespaceName].json`: Fichier contenant les traductions pour un contexte spécifique (ex: `ProductPage.json`). Le nom du fichier, en `PascalCase`, définit le nom du namespace.

Chaque fichier JSON contient un objet plat de paires clé-valeur.

_Exemple : `src/i18n/messages/fr/ProductPage.json`_

```json
{
  "addToCart": "Ajouter au panier",
  "productDescription": "Description du produit",
  "relatedProducts": "Produits similaires"
}
```

### b. Configuration et Chargement

L'architecture de chargement est conçue pour être maintenable, performante et compatible avec l'Edge Runtime de Next.js.

- **`src/i18n.ts` (Le Cœur du Système) :**
  - **Source de vérité :** Un tableau `namespaces` liste tous les namespaces utilisés dans l'application.
  - **Chargement Dynamique et Parallèle :** Pour une locale donnée, ce fichier charge en parallèle tous les fichiers JSON correspondants listés dans le tableau `namespaces`.
  - **Robustesse :** Une gestion d'erreurs intégrée logue les problèmes de chargement (fichier manquant, JSON invalide) sans faire planter l'application en production.
  - **Pour ajouter un namespace, c'est la seule modification nécessaire (en plus de créer les fichiers JSON).**

- **`src/i18n-config.ts` (Configuration du Routage) :**
  - Ce fichier léger définit les locales supportées (`locales`) et la configuration des `pathnames`.
  - Il mappe les chemins canoniques de l'application (ex: `/products/[slug]`) aux URLs localisées visibles par l'utilisateur (ex: `/fr/produits/[slug]`).
  - **C'est ici qu'il faut intervenir pour traduire les URLs.**

- **`src/middleware.ts` :**
  - Le middleware `next-intl` utilise **uniquement** `i18n-config.ts` pour gérer la détection de la locale et le routage, ce qui garantit sa compatibilité avec l'Edge Runtime.
  - Il gère également la sécurité des routes (voir [ADMIN_AND_ROUTES.md](./ADMIN_AND_ROUTES.md)).

- **`src/app/[locale]/layout.tsx` :**
  - Le layout racine enveloppe l'application dans le `<NextIntlClientProvider>`, fournissant les messages de traduction à tous les Client Components.

### c. Conventions

- **Noms de Fichiers (Namespaces) :** `PascalCase` (ex: `CheckoutFlow.json`).
- **Clés de Traduction :** `camelCase` (ex: `billingAddress`).

### d. Internationalisation des Données (Base de Données)

En plus des chaînes de l'interface utilisateur, le contenu de la base de données (comme les noms et descriptions de produits) est également internationalisé. La stratégie consiste à utiliser des tables de traduction dédiées.

- **Exemple :** La table `products` contient les données non traduisibles (prix, stock). La table `product_translations` contient les champs traduisibles (`name`, `description`) avec une colonne `language_code` qui la lie à une langue spécifique et une clé étrangère vers la table `products`.

Pour plus de détails, consultez la documentation [DATABASE.md](./DATABASE.md).

---

## 3. Dépannage et Points d'Attention

Cette section, tirée de l'expérience, liste les problèmes courants et leurs solutions.

- **Erreur `FORMATTING_ERROR`**:
  - **Cause :** Une traduction attend une variable (ex: `"Bonjour {name}"`) mais elle n'est pas fournie à l'appel `t()`.
  - **Solution :** Toujours passer les variables attendues. `t('welcomeMessage', { name: 'Omar' })`.

- **Clés dupliquées dans un JSON**:
  - **Cause :** Un même fichier JSON contient deux fois la même clé.
  - **Solution :** Les linters JSON devraient détecter cela. Assurez une unicité stricte.

- **Confusion de portée avec `useTranslations`**:
  - **Cause :** `const t = useTranslations('Namespace.subKey')` puis `t('subKey.finalKey')`.
  - **Solution :** Le préfixe est déjà appliqué. Utilisez `t('finalKey')`.

---

## 4. Évolutions Futures

- **Validation en CI :** Un script pour vérifier que toutes les clés existent dans toutes les langues.
- **Typage Fort :** Génération de types TypeScript à partir des JSON pour l'autocomplétion et la détection d'erreurs à la compilation.
